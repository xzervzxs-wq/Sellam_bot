<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>المصمم المحترف - نظام المقابض المتطور</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            /* سمحنا بالتمرير هنا وحصرناه في الحاوية */
            overscroll-behavior: none;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background-color: #f1f5f9;
        }
        #workspace-container {
            height: calc(100vh - 120px);
            overflow: auto;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 100px;
            /* تسمح ببدء التمرير من هنا */
            touch-action: pan-x pan-y pinch-zoom;
        }
        #mainCanvas {
            background-color: white;
            box-shadow: 0 0 0 1px rgba(0,0,0,0.05), 0 30px 60px -12px rgba(0,0,0,0.3);
            display: block;
            /* تسمح بالتمرير عند لمس المساحات الفارغة */
            touch-action: auto; 
            transform: translateZ(0);
        }
        .tool-btn { 
            @apply p-2.5 rounded-2xl transition-all duration-200 flex items-center justify-center;
        }
        .tool-btn.active {
            @apply bg-blue-600 text-white shadow-lg scale-110;
        }
        .hide-scrollbar::-webkit-scrollbar { display: none; }
        input[type="number"]::-webkit-inner-spin-button { display: none; }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden">

    <!-- Header / Toolbar -->
    <header class="bg-white/90 backdrop-blur-md border-b z-30 p-3 flex flex-wrap items-center justify-between gap-4 shadow-sm">
        
        <div class="flex items-center gap-2">
            <!-- Tools -->
            <div class="flex bg-gray-100 p-1 rounded-2xl border gap-1 shadow-inner">
                <button onclick="setTool('select')" id="btn-select" class="tool-btn active">
                    <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="m3 3 7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/><path d="m13 13 6 6"/></svg>
                </button>
                <button onclick="setTool('rect')" id="btn-rect" class="tool-btn">
                    <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2"/></svg>
                </button>
                <button onclick="setTool('circle')" id="btn-circle" class="tool-btn">
                    <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/></svg>
                </button>
                <!-- Image Upload Tool -->
                <button onclick="triggerImageUpload()" class="tool-btn hover:bg-gray-200 text-gray-700">
                    <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><circle cx="9" cy="9" r="2"/><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/></svg>
                </button>
                <input type="file" id="imageInput" accept="image/*" class="hidden" onchange="handleImageUpload(event)">
            </div>

            <!-- Text Input -->
            <div class="flex items-center gap-1 bg-gray-100 p-1 rounded-2xl border shadow-inner">
                <input type="text" id="textInput" placeholder="أضف نصاً..." class="bg-white border-none rounded-xl px-4 py-2 text-sm w-32 md:w-48 outline-none">
                <button onclick="addText()" class="bg-blue-600 text-white px-4 py-2 rounded-xl text-sm font-bold shadow-sm active:scale-95 transition">إضافة</button>
            </div>

            <button onclick="deleteEl()" class="p-2.5 text-red-500 hover:bg-red-50 rounded-xl transition-colors">
                <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/></svg>
            </button>
        </div>

        <!-- Canvas Settings -->
        <div class="flex items-center gap-4 flex-wrap">
            <div class="flex items-center gap-2 bg-blue-50 px-3 py-2 rounded-2xl border border-blue-100 shadow-sm">
                <span class="text-[10px] font-black text-blue-700">سم:</span>
                <input type="number" id="wCm" value="21" class="w-10 bg-transparent text-sm font-bold text-center outline-none">
                <span class="text-blue-300">×</span>
                <input type="number" id="hCm" value="21" class="w-10 bg-transparent text-sm font-bold text-center outline-none">
                <button onclick="resizeCanvas()" class="text-blue-600 hover:bg-blue-100 rounded-lg p-0.5">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><path d="M20 6 9 17l-5-5"/></svg>
                </button>
            </div>

            <div class="flex items-center gap-2 bg-orange-50 px-3 py-2 rounded-2xl border border-orange-100 shadow-sm">
                <span class="text-[10px] font-black text-orange-700 uppercase text-center">Zoom</span>
                <input type="range" id="zoomRange" min="0.1" max="1.5" step="0.01" value="0.7" class="w-20 md:w-32 accent-orange-600">
                <span id="zoomLabel" class="text-[10px] font-mono font-bold w-10 text-center text-orange-800">70%</span>
            </div>
        </div>

        <!-- Style & Export -->
        <div class="flex items-center gap-3">
            <div class="flex items-center gap-2 bg-gray-50 p-1 rounded-2xl border">
                <input type="color" id="mainColor" value="#2563eb" class="w-9 h-9 rounded-xl cursor-pointer border-2 border-white shadow-sm overflow-hidden">
                <input type="range" id="mainSize" min="12" max="600" value="100" class="w-16 md:w-24 accent-blue-600">
            </div>
            <button onclick="exportPNG()" class="bg-black text-white px-6 py-2.5 rounded-2xl text-sm font-black shadow-xl hover:bg-gray-800 transition">تصدير</button>
        </div>
    </header>

    <!-- Workspace Container (This is where scrolling happens) -->
    <main id="workspace-container" class="hide-scrollbar">
        <canvas id="mainCanvas"></canvas>
    </main>

    <script>
        // Global Variables
        let canvas, ctx, zoomRange, zoomLabel, colorPicker, sizePicker, textInput, wCmInput, hCmInput;
        let elements = [];
        let selected = null;
        let tool = 'select';
        let activeHandle = null; 
        let dragOffset = { x: 0, y: 0 };
        let zoom = 0.7;

        const DPI = 200;
        const CM_INCH = 2.54;

        window.addEventListener('DOMContentLoaded', () => {
            canvas = document.getElementById('mainCanvas');
            zoomRange = document.getElementById('zoomRange');
            zoomLabel = document.getElementById('zoomLabel');
            colorPicker = document.getElementById('mainColor');
            sizePicker = document.getElementById('mainSize');
            textInput = document.getElementById('textInput');
            wCmInput = document.getElementById('wCm');
            hCmInput = document.getElementById('hCm');

            if (canvas) {
                ctx = canvas.getContext('2d', { alpha: false });
                
                if (zoomRange) zoomRange.oninput = updateZoom;
                
                if (colorPicker) {
                    colorPicker.oninput = () => { if(selected) { selected.color = colorPicker.value; requestRedraw(); } };
                }
                if (sizePicker) {
                    sizePicker.oninput = () => { if(selected && selected.type === 'text') { selected.size = parseInt(sizePicker.value); requestRedraw(); } };
                }
                if (textInput) {
                    textInput.oninput = () => { if(selected && selected.type === 'text') { selected.text = textInput.value; requestRedraw(); } };
                }

                canvas.addEventListener('pointerdown', handlePointerDown);
                canvas.addEventListener('pointermove', handlePointerMove);
                canvas.addEventListener('pointerup', handlePointerUp);

                resizeCanvas();
                requestAnimationFrame(renderLoop);
            }
        });

        function renderLoop() { requestAnimationFrame(renderLoop); }

        function resizeCanvas() {
            if (!canvas || !wCmInput || !hCmInput) return;
            const w = parseFloat(wCmInput.value) || 21;
            const h = parseFloat(hCmInput.value) || 21;
            canvas.width = Math.round((w / CM_INCH) * DPI);
            canvas.height = Math.round((h / CM_INCH) * DPI);
            updateZoom();
            requestRedraw();
        }

        function updateZoom() {
            if (!zoomRange || !canvas || !zoomLabel) return;
            zoom = parseFloat(zoomRange.value);
            zoomLabel.innerText = Math.round(zoom * 100) + "%";
            canvas.style.width = (canvas.width * zoom) + "px";
            canvas.style.height = (canvas.height * zoom) + "px";
        }

        function getCoords(e) {
            if (!canvas) return {x:0, y:0};
            const rect = canvas.getBoundingClientRect();
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            return {
                x: (clientX - rect.left) * (canvas.width / rect.width),
                y: (clientY - rect.top) * (canvas.height / rect.height)
            };
        }

        function triggerImageUpload() {
            document.getElementById('imageInput').click();
        }

        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(f) {
                const img = new Image();
                img.onload = function() {
                    // Default scale to fit canvas nicely
                    const maxWidth = canvas.width * 0.5;
                    const scale = Math.min(maxWidth / img.width, 1);
                    const newEl = {
                        type: 'image',
                        img: img,
                        x: canvas.width / 2 - (img.width * scale) / 2,
                        y: canvas.height / 2 - (img.height * scale) / 2,
                        w: img.width * scale,
                        h: img.height * scale
                    };
                    elements.push(newEl);
                    selected = newEl;
                    setTool('select');
                    requestRedraw();
                };
                img.src = f.target.result;
            };
            reader.readAsDataURL(file);
            // Reset input
            event.target.value = '';
        }

        function addText() {
            if (!textInput || !canvas) return;
            const val = textInput.value.trim();
            if(!val) return;
            const size = parseInt(sizePicker.value);
            const el = { type: 'text', text: val, x: canvas.width/2, y: canvas.height/2, color: colorPicker.value, size: size, w: 0, h: 0 };
            elements.push(el);
            selected = el;
            setTool('select');
        }

        function setTool(t) {
            tool = t;
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            const btn = document.getElementById('btn-'+t);
            if(btn) btn.classList.add('active');
            if(t !== 'select') selected = null;
            requestRedraw();
        }

        function handlePointerDown(e) {
            const p = getCoords(e);
            
            // 1. Check if we hit a handle
            if (selected) {
                const handle = getHandleAt(p, selected);
                if (handle) {
                    activeHandle = handle;
                    if (handle === 'move') {
                        dragOffset = { x: p.x - selected.x, y: p.y - selected.y };
                    }
                    canvas.setPointerCapture(e.pointerId);
                    // Prevent browser scrolling when designing
                    canvas.style.touchAction = 'none'; 
                    return;
                }
            }

            // 2. Check if we hit an element
            const padding = 35 / zoom;
            const hit = elements.slice().reverse().find(el => isPointIn(p, el, padding));
            if (hit) {
                selected = hit;
                activeHandle = 'move';
                dragOffset = { x: p.x - hit.x, y: p.y - hit.y };
                elements = [...elements.filter(i => i !== hit), hit];
                if (colorPicker && hit.color) colorPicker.value = hit.color;
                if(hit.type === 'text') {
                    if (sizePicker) sizePicker.value = hit.size;
                    if (textInput) textInput.value = hit.text;
                }
                setTool('select');
                canvas.setPointerCapture(e.pointerId);
                canvas.style.touchAction = 'none'; // Lock scroll
            } else {
                // 3. No hit -> ALLOW BROWSER SCROLL
                canvas.style.touchAction = 'auto'; 
                if(tool === 'select') {
                    selected = null;
                    if (textInput) textInput.value = "";
                } else if(['rect', 'circle'].includes(tool)) {
                    const newEl = { type: tool, x: p.x, y: p.y, w: 10, h: 10, color: colorPicker.value };
                    elements.push(newEl);
                    selected = newEl;
                    activeHandle = 'br';
                    setTool('select');
                    canvas.setPointerCapture(e.pointerId);
                    canvas.style.touchAction = 'none';
                }
            }
            requestRedraw();
        }

        function handlePointerMove(e) {
            if (!activeHandle || !selected) return;
            const p = getCoords(e);
            const el = selected;

            if (activeHandle === 'move') {
                el.x = p.x - dragOffset.x;
                el.y = p.y - dragOffset.y;
            } else {
                const bounds = getBounds(el);
                if (activeHandle === 'br') {
                    if(el.type === 'circle') el.w = Math.hypot(p.x - el.x, p.y - el.y) * 2;
                    else { el.w = p.x - el.x; el.h = p.y - el.y; }
                } else if (activeHandle === 'tl') {
                    const dx = el.x - p.x; const dy = el.y - p.y;
                    el.x = p.x; el.y = p.y; el.w += dx; el.h += dy;
                } else if (activeHandle === 'tr') {
                    el.w = p.x - el.x; const dy = el.y - p.y;
                    el.y = p.y; el.h += dy;
                } else if (activeHandle === 'bl') {
                    const dx = el.x - p.x; el.x = p.x; el.w += dx; el.h = p.y - el.y;
                }
                if (el.type === 'text') el.size = Math.max(12, Math.abs(el.w / 1.5));
            }
            requestRedraw();
        }

        function handlePointerUp(e) {
            activeHandle = null;
            if (canvas) {
                canvas.releasePointerCapture(e.pointerId);
                canvas.style.touchAction = 'auto'; // Return to scroll-ready state
            }
            requestRedraw();
        }

        function getBounds(el) {
            if (el.type === 'circle') { const r = Math.abs(el.w/2); return { x: el.x-r, y: el.y-r, w: r*2, h: r*2 }; }
            if (el.type === 'text') return { x: el.x - el.w, y: el.y, w: el.w, h: el.h };
            return { x: el.x, y: el.y, w: el.w, h: el.h };
        }

        function isPointIn(p, el, pad = 0) {
            const b = getBounds(el);
            if(el.type === 'circle') return Math.hypot(p.x-el.x, p.y-el.y) <= Math.abs(el.w/2) + pad;
            return p.x >= b.x - pad && p.x <= b.x + b.w + pad && p.y >= b.y - pad && p.y <= b.y + b.h + pad;
        }

        function getHandleAt(p, el) {
            const b = getBounds(el);
            const r = 55 / zoom; 
            if (Math.hypot(p.x - b.x, p.y - b.y) < r) return 'tl';
            if (Math.hypot(p.x - (b.x + b.w), p.y - b.y) < r) return 'tr';
            if (Math.hypot(p.x - b.x, p.y - (b.y + b.h)) < r) return 'bl';
            if (Math.hypot(p.x - (b.x + b.w), p.y - (b.y + b.h)) < r) return 'br';
            const moveHandleY = b.y - (30 / zoom);
            const moveHandleX = b.x + b.w / 2;
            if (Math.hypot(p.x - moveHandleX, p.y - moveHandleY) < r) return 'move';
            return null;
        }

        function requestRedraw() { requestAnimationFrame(render); }

        function render() {
            if (!ctx || !canvas) return;
            ctx.fillStyle = "white";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            elements.forEach(el => drawElement(el));
            if(selected) drawSelectionUI(selected);
        }

        function drawElement(el) {
            ctx.save();
            if (el.color) ctx.fillStyle = el.color;
            
            if (el.type === 'rect') ctx.fillRect(el.x, el.y, el.w, el.h);
            else if (el.type === 'circle') { ctx.beginPath(); ctx.arc(el.x, el.y, Math.abs(el.w/2), 0, Math.PI * 2); ctx.fill(); }
            else if (el.type === 'text') {
                ctx.font = `bold ${el.size}px Arial`;
                ctx.textBaseline = 'top'; ctx.textAlign = 'right';
                ctx.fillText(el.text, el.x, el.y);
                const m = ctx.measureText(el.text); el.w = m.width; el.h = el.size;
            } else if (el.type === 'image') {
                ctx.drawImage(el.img, el.x, el.y, el.w, el.h);
            }
            ctx.restore();
        }

        function drawSelectionUI(el) {
            ctx.save();
            const b = getBounds(el);
            const strokeW = Math.max(1, 1 / zoom);
            const dash = [10/zoom, 10/zoom];
            ctx.strokeStyle = '#2563eb';
            ctx.lineWidth = strokeW;
            ctx.setLineDash(dash);
            ctx.strokeRect(b.x - 5, b.y - 5, b.w + 10, b.h + 10);
            const moveDist = 30 / zoom;
            const moveY = b.y - moveDist;
            const moveX = b.x + b.w / 2;
            ctx.beginPath();
            ctx.moveTo(moveX, b.y - 5);
            ctx.lineTo(moveX, moveY);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillStyle = '#2563eb';
            const hRadius = Math.max(14, 14 / zoom);
            ctx.beginPath();
            ctx.arc(moveX, moveY, hRadius * 1.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = strokeW * 2;
            const iconSize = hRadius * 0.5;
            ctx.beginPath();
            ctx.moveTo(moveX - iconSize, moveY); ctx.lineTo(moveX + iconSize, moveY);
            ctx.moveTo(moveX, moveY - iconSize); ctx.lineTo(moveX, moveY + iconSize);
            ctx.stroke();
            ctx.fillStyle = 'white';
            ctx.strokeStyle = '#2563eb';
            ctx.lineWidth = strokeW;
            const cornerR = Math.max(10, 10 / zoom);
            const pts = [[b.x-5, b.y-5], [b.x+b.w+5, b.y-5], [b.x-5, b.y+b.h+5], [b.x+b.w+5, b.y+b.h+5]];
            pts.forEach(p => {
                ctx.beginPath(); ctx.arc(p[0], p[1], cornerR, 0, Math.PI*2);
                ctx.fill(); ctx.stroke();
            });
            ctx.restore();
        }

        function deleteEl() { 
            if(selected) { 
                elements = elements.filter(i => i !== selected); 
                selected = null; 
                if (textInput) textInput.value = ""; 
                requestRedraw(); 
            } 
        }

        function exportPNG() {
            if (!canvas) return;
            const sel = selected; selected = null; render();
            setTimeout(() => {
                const link = document.createElement('a');
                link.download = `تصميم_احترافي_${Date.now()}.png`;
                link.href = canvas.toDataURL('image/png', 1.0);
                link.click();
                selected = sel; requestRedraw();
            }, 100);
        }
    </script>
</body>
</html>