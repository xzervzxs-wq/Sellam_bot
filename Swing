import pandas as pd
import warnings
from datetime import datetime, time, timedelta
import requests
import os
import json
import time as tm
import pytz
from dotenv import load_dotenv

# =========================================================
# 1. Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
# =========================================================
load_dotenv()
API_KEY = os.getenv('FMP_API_KEY')
if not API_KEY: API_KEY = "YOUR_FMP_API_KEY_HERE"

TELEGRAM_BOT_TOKEN = "8355940634:AAGasYk02DUp8y5h8XvtPt4hcwJvU8SYtKA"
TELEGRAM_CHAT_ID = "237657512"

warnings.simplefilter(action='ignore', category=FutureWarning)
FLOAT_CACHE_FILE = "float_cache.json"

# ØªÙˆÙ‚ÙŠØª Ù†ÙŠÙˆÙŠÙˆØ±Ùƒ
NY_TZ = pytz.timezone('America/New_York')
TARGET_TIME = "15:45"  # Ø§Ù„Ø³Ø§Ø¹Ø© Ø§Ù„Ù„ÙŠ Ù†ÙØ­Øµ ÙÙŠÙ‡Ø§ Ø§Ù„Ø£Ø³Ù‡Ù…

# =========================================================
# 2. Ø£Ø¯ÙˆØ§Øª Ù…Ø³Ø§Ø¹Ø¯Ø©
# =========================================================
def fmt_shares(n):
    if not isinstance(n, (int, float)): return "N/A"
    if n >= 1_000_000: return f"{n/1_000_000:.1f}M".replace(".0M", "M")
    if n >= 1_000: return f"{n/1_000:.1f}K"
    return str(int(n))

def load_json_file(filename):
    if os.path.exists(filename):
        try:
            with open(filename, 'r') as f: return json.load(f)
        except: return {}
    return {}

def save_json_file(filename, data):
    try:
        with open(filename, 'w') as f: json.dump(data, f, indent=4)
    except: pass

float_data_store = load_json_file(FLOAT_CACHE_FILE)

def load_cache():
    """ØªØ­Ù…ÙŠÙ„ Ø§Ù„ÙƒØ§Ø´ Ù…Ù† Ù…Ù„Ù JSON"""
    if os.path.exists(FLOAT_CACHE_FILE):
        try:
            with open(FLOAT_CACHE_FILE, 'r') as f:
                data = json.load(f)
                # Ø¥Ø°Ø§ Ø§Ù„ÙƒØ§Ø´ Ù‚Ø¯ÙŠÙ… (Ø¯ÙŠÙƒØ´Ù†Ø±ÙŠ Ø¨Ù€ value/isEtf)ØŒ Ø­ÙˆÙ„Ù‡ Ù„ØµÙŠØºØ© Ø¬Ø¯ÙŠØ¯Ø©
                cache = {}
                for symbol, val in data.items():
                    if isinstance(val, dict):
                        cache[symbol] = val.get('value', 0)
                    else:
                        cache[symbol] = val
                return cache
        except:
            return {}
    return {}

def save_cache(cache):
    """Ø­ÙØ¸ Ø§Ù„ÙƒØ§Ø´"""
    try:
        with open(FLOAT_CACHE_FILE, 'w') as f:
            json.dump(cache, f, indent=4)
    except:
        pass

# ğŸ›‘ Ø¯Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø©: ÙƒØ´Ù Ø§Ù„ØµÙ†Ø§Ø¯ÙŠÙ‚ (ETF Filter)
def is_etf(symbol):
    try:
        # Ù†Ø³ØªØ®Ø¯Ù… Ø§Ù„ÙƒØ§Ø´ Ø­Ù‚ Ø§Ù„ÙÙ„ÙˆØª Ø¹Ø´Ø§Ù† Ù…Ø§ Ù†ÙƒØ«Ø± Ø·Ù„Ø¨Ø§ØªØŒ Ù„Ø£Ù†Ù†Ø§ Ù†Ø®Ø²Ù† Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ù‡Ù†Ø§Ùƒ
        global float_data_store
        cached = float_data_store.get(symbol)

        # Ø¥Ø°Ø§ Ù…Ø¹Ù„ÙˆÙ…Ø© Ø£Ù†Ù‡ ETF Ù…Ø®Ø²Ù†Ø© Ø³Ø§Ø¨Ù‚Ø§Ù‹ØŒ Ù†Ø³ØªØ®Ø¯Ù…Ù‡Ø§
        if isinstance(cached, dict) and 'isEtf' in cached:
            return cached['isEtf']

        # Ø¥Ø°Ø§ Ù…Ùˆ Ù…Ø®Ø²Ù†Ø©ØŒ Ù†Ø·Ù„Ø¨Ù‡Ø§ Ù…Ù† Ø§Ù„Ù€ Profile
        url = f"https://financialmodelingprep.com/api/v3/profile/{symbol}?apikey={API_KEY}"
        data = requests.get(url, timeout=5).json()

        if data and isinstance(data, list):
            is_etf_val = data[0].get('isEtf', False)

            # Ù†Ø®Ø²Ù† Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø© Ø¹Ø´Ø§Ù† Ø§Ù„Ù…Ø±Ø§Øª Ø§Ù„Ø¬Ø§ÙŠØ©
            if isinstance(cached, dict):
                cached['isEtf'] = is_etf_val
            else:
                float_data_store[symbol] = {'value': cached if cached else 0, 'isEtf': is_etf_val}

            save_json_file(FLOAT_CACHE_FILE, float_data_store)
            return is_etf_val

    except: return False # ÙÙŠ Ø­Ø§Ù„ Ø§Ù„Ø®Ø·Ø£ Ù†Ø¹ØªØ¨Ø±Ù‡ Ø³Ù‡Ù… ÙˆÙ†Ù…Ø´ÙŠÙ‡
    return False

def get_float_shares(symbol):
    global float_data_store

    # Ø§Ù‚Ø±Ø£ Ù…Ù† Ø§Ù„ÙƒØ§Ø´ Ø£ÙˆÙ„Ø§Ù‹
    if symbol in float_data_store:
        val = float_data_store[symbol]
        if isinstance(val, dict): val = val.get('value', 0)
        if isinstance(val, (int, float)): return val

    # Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† ÙÙŠ Ø§Ù„ÙƒØ§Ø´ØŒ Ø§Ø·Ù„Ø¨ Ù…Ù† API
    val = 0
    try:
        url = f"https://financialmodelingprep.com/api/v4/shares_float?symbol={symbol}&apikey={API_KEY}"
        data = requests.get(url, timeout=5).json()
        if data and isinstance(data, list): val = float(data[0].get('floatShares', 0))
    except: pass

    if not val:
        try:
            url = f"https://financialmodelingprep.com/api/v3/profile/{symbol}?apikey={API_KEY}"
            data = requests.get(url, timeout=5).json()
            if data and isinstance(data, list):
                val = float(data[0].get('mktCap', 0)) / float(data[0].get('price', 1))
        except: pass

    val = val if val else 0

    # Ø§Ø­ÙØ¸ ÙÙŠ Ø§Ù„ÙƒØ§Ø´ Ø¯Ø§Ø¦Ù…Ù‹Ø§ Ø¨Ø¹Ø¯ Ø§Ù„Ø·Ù„Ø¨ Ù…Ù† API
    current_entry = float_data_store.get(symbol, {})
    if not isinstance(current_entry, dict): current_entry = {'value': val}
    current_entry['value'] = val
    float_data_store[symbol] = current_entry
    save_json_file(FLOAT_CACHE_FILE, float_data_store)

    return val

def send_telegram(message):
    if not TELEGRAM_BOT_TOKEN: return
    try:
        requests.post(
            f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage",
            data={'chat_id': TELEGRAM_CHAT_ID, 'text': message, 'parse_mode': 'Markdown'},
            timeout=5
        )
    except: pass

def wait_for_target_time():
    """ÙŠÙ†ØªØ¸Ø± Ù„Ø­Ø¯ 15:45 Ø¨ØªÙˆÙ‚ÙŠØª Ù†ÙŠÙˆÙŠÙˆØ±Ùƒ"""
    while True:
        now = datetime.now(NY_TZ)
        current_time = now.strftime('%H:%M')
        
        target_hour, target_min = map(int, TARGET_TIME.split(':'))
        current_hour, current_min = map(int, current_time.split(':'))
        
        # Ø¥Ø°Ø§ ØªØ¬Ø§ÙˆØ²Ù†Ø§ Ø§Ù„ÙˆÙ‚ØªØŒ Ø§Ø®Ø±Ø¬ Ù…Ù† Ø§Ù„Ø­Ù„Ù‚Ø©
        if current_hour > target_hour or (current_hour == target_hour and current_min >= target_min):
            print(f"âœ… Ø§Ù„Ø³Ø§Ø¹Ø© {current_time} - Ø¨Ø¯Ø¡ Ø§Ù„ÙØ­Øµ!")
            break
        
        # Ø§Ø­Ø³Ø¨ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ
        target_datetime = now.replace(hour=target_hour, minute=target_min, second=0, microsecond=0)
        if target_datetime < now:
            target_datetime += timedelta(days=1)  # ØºØ¯Ø§Ù‹ ÙÙŠ Ù†ÙØ³ Ø§Ù„Ø³Ø§Ø¹Ø©
        
        remaining = target_datetime - now
        minutes = remaining.total_seconds() / 60
        
        print(f"â³ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ø­Ø§Ù„ÙŠ: {current_time} | Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ø­ØªÙ‰ {TARGET_TIME} ({minutes:.0f} Ø¯Ù‚ÙŠÙ‚Ø© Ù…ØªØ¨Ù‚ÙŠØ©)")
        tm.sleep(30)  # ÙØ­Øµ ÙƒÙ„ 30 Ø«Ø§Ù†ÙŠØ©

# =========================================================
# 3. Ø¬Ù„Ø¨ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© (1000 Ø³Ù‡Ù… Ø«Ù… ÙÙ„ØªØ±Ø© Ø¥Ù„Ù‰ 100)
# =========================================================
def get_watchlist():
    cache = load_cache()
    print("ğŸ“¦ Ø¬Ø§Ø±ÙŠ Ø³Ø­Ø¨ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø­ÙŠØ© Ù…Ù† Company Screener...")
    
    url = (f"https://financialmodelingprep.com/stable/company-screener"
           f"?priceMoreThan=0.02&priceLowerThan=10&volumeMoreThan=150000"
           f"&isEtf=false&exchange=nasdaq,nyse,amex&isActivelyTrading=true&limit=1000&apikey={API_KEY}")
    
    try:
        results = requests.get(url, timeout=20).json()
        if not results: 
            print("âŒ Ù„Ù… ÙŠØªÙ… Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª")
            return []
        
        # ØªØ±ØªÙŠØ¨ Ø­Ø³Ø¨ Ø§Ù„ÙÙˆÙ„ÙŠÙˆÙ…
        results.sort(key=lambda x: x.get('volume', 0), reverse=True)
        
        final_list = []
        for item in results:
            # Ø¥Ø°Ø§ Ø§ÙƒØªÙÙŠÙ†Ø§ Ø¨Ù€ 100 Ø³Ù‡Ù… Ù†ÙˆÙ‚Ù
            if len(final_list) >= 100: 
                break
            
            try:
                sym = item.get('symbol')
                if not sym or len(sym) > 5: 
                    continue 
                
                # Ø¬Ù„Ø¨ Ø§Ù„ÙÙ„ÙˆØª Ù…Ù† Ø§Ù„ÙƒØ§Ø´ Ø£ÙˆÙ„Ø§Ù‹
                if sym in cache:
                    raw_val = cache[sym]
                else:
                    try:
                        f_url = f"https://financialmodelingprep.com/stable/shares-float?symbol={sym}&apikey={API_KEY}"
                        f_data = requests.get(f_url, timeout=1).json()
                        if f_data and isinstance(f_data, list):
                            raw_val = f_data[0].get('floatShares', 0)
                        else:
                            raw_val = 0
                        
                        cache[sym] = raw_val
                        tm.sleep(0.05)
                    except: 
                        raw_val = 0
                
                # ØªØµØ­ÙŠØ­ Ø§Ù„ÙÙ„ÙˆØª Ø¥Ø¬Ø¨Ø§Ø±ÙŠ
                try:
                    f_shares = float(raw_val)
                except (ValueError, TypeError):
                    f_shares = 0

                # Ø§Ù„Ø´Ø±Ø· Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ
                if 0 < f_shares <= 150_000_000:
                    final_list.append(sym)
                    print(f"ğŸ“Œ {len(final_list)}/100: {sym}")

            except Exception as loop_error:
                continue
        
        save_cache(cache)
        print(f"âœ… ØªÙ… Ø¬Ù„Ø¨ {len(final_list)} Ø³Ù‡Ù… Ù…Ù† Ø£ØµÙ„ 1000")
        return final_list

    except Exception as e:
        print(f"âŒ Ø®Ø·Ø£ Ø¨Ø§Ù„Ø³ÙƒØ±ÙŠÙ†Ø±: {e}")
        return []

def get_fmp_data(symbol):
    url = f"https://financialmodelingprep.com/stable/historical-chart/5min?symbol={symbol}&apikey={API_KEY}"
    try:
        r = requests.get(url, timeout=10).json()
        if not r: return pd.DataFrame()
        df = pd.DataFrame(r)
        df['date'] = pd.to_datetime(df['date'])
        df = df.set_index('date').sort_index()
        
        # Ø§Ø®Ø° ÙÙ‚Ø· Ø¢Ø®Ø± 6 Ø´Ù…ÙˆØ¹ (Ø¢Ø®Ø± 5 + Ø´Ù…Ø¹Ø© 15:45)
        df = df.tail(6)
        return df
    except: return pd.DataFrame()

# =========================================================
# 4. Ø§Ù„Ù…Ù†Ø·Ù‚: Ø³ÙŠÙˆÙ„Ø© 15:45 + Ø´Ø±ÙˆØ· Ø³ÙˆÙŠÙ†Ù‚
# =========================================================
def check_power_hour_volume(df, ticker):
    target_candles = df.between_time('15:45', '15:45')

    if target_candles.empty: return False, None, "Ù„Ø§ ØªÙˆØ¬Ø¯ Ø´Ù…Ø¹Ø© 15:45"

    last_candle = target_candles.iloc[-1]
    last_candle_idx = target_candles.index[-1]

    try:
        loc = df.index.get_loc(last_candle_idx)
    except: return False, None, "Index Error"

    if loc < 5: return False, None, "Ø¨ÙŠØ§Ù†Ø§Øª Ù†Ø§Ù‚ØµØ©"

    prev_candles = df.iloc[loc-5 : loc]
    avg_volume = prev_candles['volume'].mean()
    current_volume = last_candle['volume']

    if avg_volume == 0: return False, None, "Avg Vol 0"

    vol_ratio = current_volume / avg_volume

    if vol_ratio < 1.5: return False, None, "ÙÙˆÙ„ÙŠÙˆÙ… Ø¶Ø¹ÙŠÙ"
    if last_candle['close'] <= last_candle['open']: return False, None, "Ø´Ù…Ø¹Ø© Ø­Ù…Ø±Ø§Ø¡"

    candle_gain = (last_candle['close'] - last_candle['open']) / last_candle['open'] * 100

    return True, {
        'ratio': vol_ratio,
        'price': last_candle['close'],
        'volume': current_volume,
        'time': last_candle_idx,
        'change': candle_gain
    }, "SWING_CANDIDATE"

# =========================================================
# 5. Ø§Ù„ØªØ´ØºÙŠÙ„
# =========================================================
def main():
    print("ğŸ¦… Ø§Ù„Ø¨ÙˆØª Ø¬Ø§Ù‡Ø² (ÙÙ„ØªØ± Ø§Ù„ØµÙ†Ø§Ø¯ÙŠÙ‚ Ù…ÙØ¹Ù„ - Anti ETF)...")
    print("â° ÙÙŠ Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„Ø³Ø§Ø¹Ø© 15:45 (Ø¢Ø®Ø± 15 Ø¯Ù‚ÙŠÙ‚Ø© Ù…Ù† Ø§Ù„Ø³ÙˆÙ‚)...\n")
    
    # Ø§Ù†ØªØ¸Ø± Ù„Ø­Ø¯ 15:45
    wait_for_target_time()

    market_list = get_watchlist()
    matches = 0

    print(f"\nğŸ” Ø¨Ø¯Ø¡ Ø§Ù„Ø¨Ø­Ø« ÙÙŠ {len(market_list)} Ø³Ù‡Ù…...\n")

    for ticker in market_list:
        # ğŸ›‘ Ø§Ù„ÙÙ„ØªØ± Ù‡Ù†Ø§: Ø¥Ø°Ø§ ÙƒØ§Ù† ETF Ø§Ø·Ø±Ø¯ Ø§Ù„Ø³Ù‡Ù… ÙˆØªØ¬Ø§Ù‡Ù„Ù‡
        if is_etf(ticker):
            print(f"ğŸš« ØªÙ… ØªØ¬Ø§Ù‡Ù„ Ø§Ù„ØµÙ†Ø¯ÙˆÙ‚: {ticker}")
            continue

        try:
            df = get_fmp_data(ticker)
            if df.empty: continue

            is_hit, data, reason = check_power_hour_volume(df, ticker)

            if is_hit:
                float_val = get_float_shares(ticker)
                candle_time_str = data['time'].strftime('%Y-%m-%d %H:%M')

                msg = (
                    f"ğŸ¦… **ÙØ±ØµØ© Ø³ÙˆÙŠÙ†Ù‚ (Swing Setup)** ğŸ¦…\n\n"
                    f"Ø§Ù„Ø±Ù…Ø²: *{ticker}*\n"
                    f"ğŸ’° Ø§Ù„Ø³Ø¹Ø±: *${data['price']:.4f}*\n"
                    f"ğŸ“… ØªÙˆÙ‚ÙŠØª Ø§Ù„Ø³ÙŠÙˆÙ„Ø©: {candle_time_str}\n\n"
                    f"ğŸ“Š **ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø­Ø¯Ø«:**\n"
                    f"Ø¯Ø®ÙˆÙ„ Ø³ÙŠÙˆÙ„Ø© ØªØ¬Ù…ÙŠØ¹ÙŠØ© Ø¨Ù†Ø³Ø¨Ø© *{data['ratio']:.1f}x* ÙÙŠ Ø¢Ø®Ø± Ø§Ù„Ø³ÙˆÙ‚.\n"
                    f"ğŸ“ˆ Ø§Ù„Ø§Ø±ØªÙØ§Ø¹ Ø§Ù„Ù„Ø­Ø¸ÙŠ: *{data['change']:.2f}%*\n"
                    f"ğŸ“¦ Ø­Ø¬Ù… Ø§Ù„ØªØ¬Ù…ÙŠØ¹: *{fmt_shares(data['volume'])}*\n"
                    f"ğŸª¶ Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø³Ù‡Ù… Ø§Ù„Ø­Ø±Ø©: *{fmt_shares(float_val)}*\n"
                    f"-----------------------\n"
                    f"ğŸ’¡ **Ø§Ù„Ø®Ø·Ø© Ø§Ù„Ù…Ù‚ØªØ±Ø­Ø©:**\n"
                    f"Ù‡Ø°Ø§ Ø§Ù„Ø³Ù‡Ù… Ù…Ø±Ø´Ø­ Ù„Ø§ÙØªØªØ§Ø­ Ù‚ÙˆÙŠ ØºØ¯Ø§Ù‹ (Gap Up).\n"
                    f"Ø±Ø§Ù‚Ø¨ Ø§Ù„Ø¥ØºÙ„Ø§Ù‚ Ø£Ùˆ Ø§Ø¯Ø®Ù„ Ù…Ø¹ Ø§Ù„Ø§ÙØªØªØ§Ø­."
                )

                send_telegram(msg)
                print(f"âœ… ØªÙ… Ø§Ù„Ø¥Ø±Ø³Ø§Ù„: {ticker} (Ratio: {data['ratio']:.1f}x)")
                matches += 1

        except Exception as e:
            continue

    if matches == 0:
        print("\nâŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ÙØ±Øµ Ø³ÙˆÙŠÙ†Ù‚ Ø§Ù„ÙŠÙˆÙ….")
    else:
        print(f"\nğŸ ØªÙ…. Ø¹Ø¯Ø¯ Ø§Ù„ÙØ±Øµ: {matches}")
    
    # Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø¨Ø±Ù†Ø§Ù…Ø¬ Ø¨Ø¹Ø¯ Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡
    print("\nğŸ›‘ Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø¨ÙˆØª...")
    exit()

if __name__ == "__main__":
    main()