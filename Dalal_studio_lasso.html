<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ø§Ø³ØªÙˆØ¯ÙŠÙˆ Ø§Ù„Ù…ØµÙ…Ù…ÙŠÙ† | Studio</title>
    
    <!-- Ù…ÙƒØªØ¨Ø§Øª Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ ÙˆØ§Ù„Ø®Ø·ÙˆØ· -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html-to-image/1.11.11/html-to-image.min.js"></script>
    <!-- Ø¥Ø¶Ø§ÙØ© Ù…ÙƒØªØ¨Ø© jsPDF -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- Ø¥Ø¶Ø§ÙØ© Ù…ÙƒØªØ¨Ø© UTIF Ù„Ù‚Ø±Ø§Ø¡Ø© Ù…Ù„ÙØ§Øª TIF -->
    <script src="https://cdn.jsdelivr.net/npm/utif@3.1.0/UTIF.js"></script>
    <!-- Ø¥Ø¶Ø§ÙØ© Ù…ÙƒØªØ¨Ø© PDF.js Ù„Ù‚Ø±Ø§Ø¡Ø© Ù…Ù„ÙØ§Øª PDF -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    
    <!-- ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£ØµÙˆÙ„ Ù…Ù† GitHub - ÙŠØªÙ… Ø¹Ø¨Ø± fetch -->
    <!-- Ø³ÙŠØªÙ… ØªØ­Ù…ÙŠÙ„ official3.json Ø¹Ø¨Ø± JavaScript -->
    
    <!-- Ù…ÙƒØªØ¨Ø© Ø§Ù„Ø£ÙŠÙ‚ÙˆÙ†Ø§Øª -->
    <link id="fa-stylesheet" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous">
    
    <!-- ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø®Ø·ÙˆØ· Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ù…ÙƒØªØ¨Ø© Ù…ÙˆØ³Ø¹Ø© - 37 Ø®Ø·) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Akatab:wght@400;700&family=Alexandria:wght@400;700&family=Almarai:wght@400;700&family=Amiri:wght@400;700&family=Aref+Ruqaa:wght@400;700&family=Baloo+Bhaijaan+2:wght@400;700&family=Blaka&family=Blaka+Hollow&family=Blaka+Ink&family=Cairo:wght@400;700&family=Changa:wght@400;700&family=El+Messiri:wght@400;700&family=Gulzar&family=Harmattan:wght@400;700&family=IBM+Plex+Sans+Arabic:wght@400;700&family=Katibeh&family=Kufam:wght@400;700&family=Lalezar&family=Lateef:wght@400;700&family=Lemonada:wght@400;700&family=Mada:wght@400;700&family=Marhey:wght@400;700&family=Markazi+Text:wght@400;700&family=Mirza:wght@400;700&family=Noto+Kufi+Arabic:wght@400;700&family=Noto+Sans+Arabic:wght@400;700&family=Noto+Serif+Arabic:wght@400;700&family=Rakkas&family=Readex+Pro:wght@400;700&family=Reem+Kufi:wght@400;700&family=Rubik:wght@400;700&family=Scheherazade+New:wght@400;700&family=Tajawal:wght@400;700&family=Vazirmatn:wght@400;700&family=Zain:wght@400;700&display=swap" rel="stylesheet" crossorigin="anonymous">

    <script>
        // Ø¥Ø¹Ø¯Ø§Ø¯ PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';
    </script>

    <style>
        /* Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø£Ù„ÙˆØ§Ù† Ø§Ù„Ø¹ØµØ±ÙŠØ© (Ø«ÙŠÙ… Ø¯Ù„Ø§Ù„) */
        :root {
            --paper-bg: #f8fafc;      /* Slate 50 */
            --paper-dark: #e2e8f0;    /* Slate 200 */
            --primary-color: #6366f1; /* Indigo 500 */
            --primary-hover: #4f46e5; /* Indigo 600 */
            --accent-color: #ec4899;  /* Pink 500 */
            --text-dark: #1e293b;     /* Slate 800 */
            --border-color: #cbd5e1;  /* Slate 300 */
        }

        /* Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø£Ø³Ø§Ø³ÙŠØ© */
        body { 
            font-family: 'Cairo', sans-serif; 
            background-color: var(--paper-bg); 
            color: var(--text-dark); 
            user-select: none; 
            -webkit-tap-highlight-color: transparent; 
            overscroll-behavior: none;
            background-image: radial-gradient(var(--border-color) 1px, transparent 1px);
            background-size: 20px 20px;
        }
        
        /* Ø´Ø§Ø´Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„ */
        #startup-overlay { 
            position: fixed; inset: 0; 
            background: #1e1b4b; 
            z-index: 99999; 
            display: flex; flex-direction: column; justify-content: center; align-items: center; 
            transition: opacity 0.3s; 
        }
        #startup-overlay .spinner {
            width: 50px; height: 50px; 
            border: 5px solid #312e81; 
            border-top-color: var(--primary-color); 
            border-radius: 50%; 
            animation: spin 1s linear infinite;
        }
        #startup-overlay .loading-text {
            color: white; 
            font-weight: bold; 
            font-family: 'Cairo', sans-serif;
            margin-top: 10px;
        }

        /* Ø´Ø§Ø´Ø© Ø§Ù„ØªØµØ¯ÙŠØ± */
        #export-overlay { 
            position: fixed; inset: 0; 
            background: rgba(30, 27, 75, 0.95); 
            z-index: 100000; 
            display: none; 
            flex-direction: column; justify-content: center; align-items: center; 
            transition: opacity 0.3s; 
        }
        #export-overlay .spinner { 
            width: 50px; height: 50px; 
            border: 5px solid rgba(255,255,255,0.1); 
            border-top-color: var(--accent-color); 
            border-radius: 50%; 
            animation: spin 1s linear infinite; 
        }
        
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø¹Ù…Ù„ */
        .preview-area {
            background-color: white;
            border-radius: 20px; min-height: 400px; display: flex; justify-content: center; align-items: flex-start;
            overflow: auto; 
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -1px rgba(0, 0, 0, 0.03);
            padding: 50px; position: relative; /* increased padding for rulers */
        }

        /* Ø­Ø§ÙˆÙŠ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø© ÙˆØ§Ù„Ù…Ø³Ø·Ø±Ø© */
        #card-wrapper {
            position: relative;
            margin: 0 auto 40px auto;
            transform-origin: center top;
            transform: scale(var(--card-zoom, 1));
            transition: transform 0.2s ease;
            display: inline-block;
        }

        /* Crop Overlay */
        #crop-overlay {
            z-index: 50000;
        }

        /* Ø§Ù„Ø¨Ø·Ø§Ù‚Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© */
        #card {
            background-color: white; 
            position: relative; 
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04); 
            overflow: hidden; 
            /* Ù‡Ø§Ù…Ø´ ÙˆØªØ­ÙˆÙŠÙ„ ØªÙ… Ù†Ù‚Ù„Ù‡Ù…Ø§ Ù„Ù„ØºÙ„Ø§Ù Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³Ø·Ø±Ø© */
            margin: 0;
            transform: none;
            direction: rtl;
            width: 100%; height: 100%;
            flex-shrink: 0; 
        }

        /* ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù…Ø³Ø§Ø·Ø± */
        .ruler {
            position: absolute;
            background-color: #f1f5f9;
            pointer-events: none;
            overflow: visible;
            z-index: 50;
            font-family: sans-serif;
            font-size: 8px;
            color: #64748b;
        }
        .ruler-h {
            top: -20px;
            left: 0;
            right: 0;
            height: 20px;
            border-bottom: 1px solid #cbd5e1;
        }
        .ruler-v {
            top: 0;
            left: -20px;
            bottom: 0;
            width: 20px;
            border-right: 1px solid #cbd5e1;
        }
        .tick {
            position: absolute;
            background-color: #cbd5e1;
        }
        .tick-num {
            position: absolute;
            font-size: 10px; /* ØªÙ… Ø§Ù„ØªÙƒØ¨ÙŠØ± */
            font-weight: 900; /* Ø®Ø· Ø£Ø¹Ø±Ø¶ */
            color: #475569;
        }
        /* Vertical Numbers */
        .ruler-v .tick-num {
            transform: rotate(-90deg);
            transform-origin: center;
        }

        /* Ø§Ù„ØªØ¯Ø±Ø¬ Ø§Ù„Ù„ÙˆÙ†ÙŠ */
        #card-gradient {
            position: absolute; 
            bottom: 0; left: 0; right: 0; 
            height: 50%; 
            background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
            z-index: 10; 
            pointer-events: none; 
            display: none;
        }

        /* Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„Ø³Ø­Ø¨ */
        .draggable-el { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            cursor: grab; touch-action: none; 
            border: 1px solid transparent;
        }
        .draggable-el:active { cursor: grabbing; }
        
        /* Ø­Ø§Ù„Ø© Ø§Ù„Ù‚ÙÙ„ */
        .draggable-el.is-locked { cursor: default; }

        /* Ø·Ø¨Ù‚Ø§Øª Ø§Ù„ØµÙˆØ± ÙˆØ§Ù„Ù†ØµÙˆØµ ÙˆØ§Ù„Ø¥Ø·Ø§Ø±Ø§Øª */
        .image-layer { /* z-index ÙŠØªÙ… Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ù‡ Ù…Ù† JavaScript */ }
        .image-layer.bg-image { width: 100% !important; height: 100% !important; top: 0 !important; left: 0 !important; transform: none !important; z-index: 1 !important; }
        .image-layer img { width: 100%; height: 100%; object-fit: cover; pointer-events: auto; }
        
        /* Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªÙ„ÙˆÙŠÙ† */
        .image-layer[data-colorable="true"] { 
            background-color: transparent;
            overflow: visible;
        }
        .image-layer[data-colorable="true"]::before {
            content: '';
            position: absolute;
            inset: 0;
            z-index: 0;
            background: transparent;
        }
        .image-layer[data-colorable="true"] .content-wrapper {
            width: 100%;
            height: 100%;
            position: relative;
            pointer-events: auto;
            z-index: 1;
        }
        
        .frame-layer { width: 80%; height: 80%; background: transparent; border-style: solid; border-width: 2px; border-color: #334155; pointer-events: auto; box-shadow: 0 0 0 3px transparent; transition: box-shadow 0.2s; }
        
        /* Ø§Ù„Ù†ØµÙˆØµ */
        .text-layer { width: auto; min-width: 100px; text-align: center; padding: 5px; cursor: text; }
        .user-text { 
            line-height: 1.6; display: block; white-space: pre-wrap; outline: none; 
            background: transparent; border: none; text-align: center; width: 100%; 
            resize: none; overflow: visible; 
            user-select: text !important;
            -webkit-user-select: text !important;
            cursor: text;
            touch-action: manipulation; 
            pointer-events: auto;
            -webkit-touch-callout: none;
        }
        
        /* Ø£Ø¯ÙˆØ§Øª Ø§Ù„ØªØ­ÙƒÙ… (Ø§Ù„Ù…Ù‚Ø§Ø¨Ø¶) */
        .draggable-el.selected { border: 1px dashed var(--primary-color); z-index: 100; }
        .draggable-el.selected.is-locked { border-color: #ef4444; border-style: dotted; }
        
        .handle { position: absolute; background: white; border: 2.5px solid var(--primary-color); width: 26px; height: 26px; border-radius: 50%; z-index: 101; display: none; box-shadow: 0 2px 5px rgba(0,0,0,0.3); }
        .draggable-el.selected .handle { display: block; }
        
        /* Ø§ØªØ¬Ø§Ù‡Ø§Øª Ø§Ù„Ù…Ù‚Ø§Ø¨Ø¶ */
        .resize-nw { top: -13px; left: -13px; cursor: nw-resize; }
        .resize-ne { top: -13px; right: -13px; cursor: ne-resize; }
        .resize-sw { bottom: -13px; left: -13px; cursor: sw-resize; }
        .resize-se { bottom: -13px; right: -13px; cursor: se-resize; }
        .resize-n { top: -13px; left: 50%; transform: translateX(-50%); cursor: n-resize; }
        .resize-e { top: 50%; right: -13px; transform: translateY(-50%); cursor: e-resize; }
        .resize-s { bottom: -13px; left: 50%; transform: translateX(-50%); cursor: s-resize; }
        
        .control-btn { position: absolute; width: 36px; height: 36px; border-radius: 50%; color: white; display: none; align-items: center; justify-content: center; font-size: 16px; cursor: pointer; z-index: 102; box-shadow: 0 2px 6px rgba(0,0,0,0.3); transition: transform 0.2s; }
        .control-btn:hover { transform: scale(1.1); }
        .delete-btn { top: -50px; left: -18px; background: #ef4444; }
        .duplicate-btn { top: -50px; left: 28px; background: #3b82f6; }
        .rotate-btn { top: -50px; left: 74px; background: #8b5cf6; }
        .layer-up-btn { top: -50px; left: 120px; background: #64748b; }
        .layer-down-btn { top: -50px; left: 166px; background: #64748b; }
        .move-handle { position: absolute; top: -50px; left: 50%; transform: translateX(-50%); width: 56px; height: 40px; background: var(--primary-color); border-radius: 8px; cursor: move; display: none; align-items: center; justify-content: center; z-index: 102; color: white; box-shadow: 0 2px 6px rgba(0,0,0,0.3); transition: transform 0.2s; font-size: 16px; }

        
        .draggable-el.selected .control-btn, .draggable-el.selected .move-handle { display: flex; }
        .draggable-el.is-locked .control-btn, .draggable-el.is-locked .handle, .draggable-el.is-locked .move-handle { display: none !important; }

        /* Ø¹Ù†Ø§ØµØ± Ù…ÙƒØªØ¨Ø© Ø§Ù„Ø£ØµÙˆÙ„ */
        .asset-item { transition: all 0.2s ease; border: 2px solid transparent; }
        .asset-item:hover { border-color: #6366f1; transform: scale(1.05); }
        #assets-grid::-webkit-scrollbar { width: 6px; }
        #assets-grid::-webkit-scrollbar-track { background: #f1f5f9; border-radius: 3px; }
        #assets-grid::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        #assets-grid::-webkit-scrollbar-thumb:hover { background: #94a3b8; }

        /* Ù…ÙˆØ¯Ø§Ù„ Ø§Ù„Ø­ÙØ¸ */
        #save-modal { display: none; position: fixed; inset: 0; background: rgba(15, 23, 42, 0.98); z-index: 100000; align-items: center; justify-content: center; padding: 0; }
        #save-img { border: none; border-radius: 0; box-shadow: 0 10px 30px rgba(0,0,0,0.3); }
        
        /* Ø§Ù„Ù†Ø§ÙØ°Ø© Ø§Ù„Ø¹Ø§Ø¦Ù…Ø© Ù„Ù„Ø£ØµÙˆÙ„ (Assets) */
        #asset-window {
            position: fixed;
            top: 20%; left: 20%;
            width: 250px;
            max-height: 400px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            border: 1px solid #cbd5e1;
            z-index: 5000;
            display: none;
            flex-direction: column;
            overflow: hidden;
        }
        #asset-header {
            background: #1e293b;
            color: white;
            padding: 10px;
            font-size: 12px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
        }
        #asset-content {
            padding: 10px;
            overflow-y: auto;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        .asset-item {
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.2s;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f8fafc;
        }
        .asset-item:hover {
            border-color: #6366f1;
            transform: scale(1.05);
        }
        .asset-item img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        .asset-item-text {
            font-size: 10px;
            color: #1e293b;
            text-align: center;
            padding: 4px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø®Ø·ÙˆØ· Ø§Ù„Ù…Ø®ÙÙŠ */
        #hidden-font-loader { opacity: 0; pointer-events: none; position: absolute; top: -9999px; }

        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: var(--paper-bg); }
        ::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--primary-color); }
        
        /* ØªÙ†Ø³ÙŠÙ‚ Ø£Ø¯ÙˆØ§Øª Ø§Ù„ØªØ­ÙƒÙ… Ø§Ù„Ù…Ø±Ù†Ø© */
        .controls-row {
            width: 100%;
            margin-top: 0.5rem;
            padding-top: 0.5rem;
            border-top: 1px dashed var(--border-color);
            display: none; 
            flex-wrap: wrap;
            align-items: center;
            gap: 0.5rem;
            order: 99; 
        }
        .controls-row.active { display: flex; }
        
        /* ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø­Ù‚ÙˆÙ„ */
        input[type="number"], input[type="text"], textarea, select {
            transition: all 0.2s;
        }
        input[type="number"]:focus, input[type="text"]:focus, textarea:focus, select:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.1);
        }

        /* ØªÙ†Ø³ÙŠÙ‚ Ø´Ø§Ø´Ø© ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ */
        #login-overlay {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            z-index: 99999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .login-container {
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 400px;
            width: 100%;
            text-align: center;
            animation: slideUp 0.5s ease-out;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .login-title {
            font-size: 28px;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 10px;
            font-family: 'Cairo', sans-serif;
        }

        .login-subtitle {
            color: #94a3b8;
            margin-bottom: 30px;
            font-family: 'Cairo', sans-serif;
            font-size: 14px;
        }

        .login-input {
            width: 100%;
            padding: 12px 15px;
            font-size: 16px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            margin-bottom: 15px;
            transition: all 0.3s;
            font-family: 'Cairo', sans-serif;
            text-align: center;
            direction: ltr;
        }

        .login-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .login-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Cairo', sans-serif;
        }

        .login-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .login-btn:active {
            transform: translateY(0);
        }

        .login-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .login-error {
            color: #dc2626;
            font-size: 14px;
            margin-top: 10px;
            font-family: 'Cairo', sans-serif;
            display: none;
        }

        .login-loading {
            display: none;
            text-align: center;
            margin-top: 10px;
        }

        .login-spinner {
            width: 30px;
            height: 30px;
            border: 3px solid #e2e8f0;
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
    </style>
</head>
<body class="min-h-screen" onclick="deselect(event); closeShapesDropdown(); closeFramesDropdown();">

    <!-- ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø®Ø·ÙˆØ· -->
    <div id="hidden-font-loader">
        <span style="font-family: 'Amiri', serif;">Ø£</span>
        <!-- ... (Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ø®Ø·ÙˆØ·) ... -->
        <span style="font-family: 'Tajawal', sans-serif;">Ø£</span>
    </div>

    <!-- Ø´Ø§Ø´Ø© ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ -->
    <div id="login-overlay">
        <div class="login-container">
            <div class="login-title">ğŸ¨ Ø§Ø³ØªÙˆØ¯ÙŠÙˆ Ø§Ù„Ù…ØµÙ…Ù…ÙŠÙ†</div>
            <div style="text-align: center; font-size: 14px; color: #94a3b8; font-family: 'Cairo', sans-serif; margin-bottom: 20px;">
                Ø§Ø³ØªÙˆØ¯ÙŠÙˆ Ù…ØªØ®ØµØµ | Ù…Ø³Ø§Ø­Ø§Øª Ù„Ù„Ø¥Ø¨Ø¯Ø§Ø¹ âœ¨
            </div>
            <div class="login-subtitle">Ø£Ø¯Ø®Ù„ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ</div>
            <input 
                type="text" 
                id="login-code-input" 
                class="login-input" 
                placeholder="Ø§Ù„ÙƒÙˆØ¯" 
                autocomplete="off"
                onkeypress="if(event.key==='Enter') verifyCode()"
            >
            <button id="login-btn" class="login-btn" onclick="verifyCode()">Ø¯Ø®ÙˆÙ„</button>
            <div class="login-loading" id="login-loading">
                <div class="login-spinner"></div>
            </div>
            <div class="login-error" id="login-error"></div>
            
            <!-- Ù‚Ø³Ù… Ø§Ù„Ø®Ø¯Ù…Ø§Øª -->
            <div style="margin-top: 25px; padding-top: 20px; border-top: 1px solid #e2e8f0;">
                <p style="font-size: 12px; color: #64748b; font-family: 'Cairo', sans-serif; margin-bottom: 14px; text-align: center; font-weight: bold;">
                    ØªÙˆØ§ØµÙ„ Ù…Ø¹Ù†Ø§ Ø¹Ø¨Ø± ÙˆØ§ØªØ³ Ø§Ø¨
                </p>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                    <!-- ØªØ¬Ø¯ÙŠØ¯ Ø§Ù„Ø§Ø´ØªØ±Ø§ÙƒØ§Øª -->
                    <a href="https://wa.me/966531333714?text=Ø£Ø±ØºØ¨%20ÙÙŠ%20ØªØ¬Ø¯ÙŠØ¯%20Ø§Ø´ØªØ±Ø§ÙƒÙŠ" target="_blank" style="display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 4px; padding: 10px; background-color: #6366f1; color: white; border-radius: 8px; text-decoration: none; font-size: 11px; font-weight: bold; font-family: 'Cairo', sans-serif; transition: all 0.3s ease; border: none; cursor: pointer;">
                        <i class="fas fa-sync" style="font-size: 16px;"></i>
                        ØªØ¬Ø¯ÙŠØ¯ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ
                    </a>
                    
                    <!-- Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª -->
                    <a href="https://wa.me/966531333714?text=Ù„Ø¯ÙŠ%20Ø§Ù‚ØªØ±Ø§Ø­" target="_blank" style="display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 4px; padding: 10px; background-color: #6366f1; color: white; border-radius: 8px; text-decoration: none; font-size: 11px; font-weight: bold; font-family: 'Cairo', sans-serif; transition: all 0.3s ease; border: none; cursor: pointer;">
                        <i class="fas fa-lightbulb" style="font-size: 16px;"></i>
                        Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª
                    </a>
                    
                    <!-- Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ -->
                    <a href="https://wa.me/966531333714?text=Ø£Ø­ØªØ§Ø¬%20Ø¥Ù„Ù‰%20Ø¯Ø¹Ù…%20ÙÙ†ÙŠ" target="_blank" style="display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 4px; padding: 10px; background-color: #6366f1; color: white; border-radius: 8px; text-decoration: none; font-size: 11px; font-weight: bold; font-family: 'Cairo', sans-serif; transition: all 0.3s ease; border: none; cursor: pointer;">
                        <i class="fas fa-headset" style="font-size: 16px;"></i>
                        Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ
                    </a>
                    
                    <!-- Ø§Ø³ØªÙØ³Ø§Ø±Ø§Øª -->
                    <a href="https://wa.me/966531333714?text=Ù„Ø¯ÙŠ%20Ø§Ø³ØªÙØ³Ø§Ø±" target="_blank" style="display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 4px; padding: 10px; background-color: #6366f1; color: white; border-radius: 8px; text-decoration: none; font-size: 11px; font-weight: bold; font-family: 'Cairo', sans-serif; transition: all 0.3s ease; border: none; cursor: pointer;">
                        <i class="fas fa-question-circle" style="font-size: 16px;"></i>
                        Ø§Ø³ØªÙØ³Ø§Ø±Ø§Øª
                    </a>
                </div>
            </div>
        </div>
    </div>

    <!-- Ø´Ø§Ø´Ø© Ø§Ù„ØªÙ†Ø¨ÙŠÙ‡ (Ù„Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠ) -->
    <div id="startup-overlay" style="display: none;">
        <div class="spinner mb-4"></div>
        <div class="loading-text">Ø¬Ø§Ø±ÙŠ ØªØ¬Ù‡ÙŠØ² Ø§Ø³ØªÙˆØ¯ÙŠÙˆ Ø§Ù„Ù…ØµÙ…Ù…ÙŠÙ†...</div>
    </div>
    
    <!-- Ù†Ø§ÙØ°Ø© Ø§Ù„Ø£ØµÙˆÙ„ Ø§Ù„Ø¹Ø§Ø¦Ù…Ø© -->
    <div id="asset-window">
        <div id="asset-header">
            <span>ğŸ¨ Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù‚Ø§Ù„Ø¨</span>
            <button onclick="document.getElementById('asset-window').style.display='none'" class="text-white hover:text-red-400"><i class="fas fa-times"></i></button>
        </div>
        <div id="asset-content">
            <!-- Ø³ÙŠØªÙ… ØªØ¹Ø¨Ø¦Ø© Ø§Ù„Ø¹Ù†Ø§ØµØ± Ù‡Ù†Ø§ -->
        </div>
    </div>

    <!-- Ø´Ø§Ø´Ø© Ø§Ù„ØªØµØ¯ÙŠØ± -->
    <div id="export-overlay"><div class="spinner mb-4"></div><div class="text-white font-bold text-xl">Ø¬Ø§Ø±ÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØµÙˆØ±Ø©...</div></div>
    
    <!-- Ù†Ø§ÙØ°Ø© Ø§Ù„ØªÙ†Ø¨ÙŠÙ‡ Ø§Ù„Ø¬Ù…ÙŠÙ„Ø© (Ø§Ù„Ù…ØµØºØ±Ø©) -->
    <div id="info-modal" style="display: none; position: fixed; inset: 0; background: rgba(15, 23, 42, 0.4); z-index: 100001; align-items: center; justify-content: center; backdrop-filter: blur(2px);">
        <div class="bg-white/95 backdrop-blur rounded-2xl shadow-2xl border border-indigo-100 p-4 max-w-[280px] mx-4 text-center transform animate-bounce-in relative">
            
            <div class="flex items-center gap-2 justify-center mb-2 border-b border-gray-100 pb-2">
                <div id="info-modal-icon" class="text-xl">ğŸ’¡</div>
                <h3 id="info-modal-title" class="text-sm font-bold text-slate-800">ØªÙ†Ø¨ÙŠÙ‡</h3>
            </div>
            
            <p id="info-modal-message" class="text-slate-600 text-xs font-semibold mb-3 leading-relaxed"></p>
            
            <button onclick="closeInfoModal()" class="w-full bg-[#6366f1] text-white hover:bg-[#4f46e5] px-4 py-1.5 rounded-lg text-xs font-bold transition shadow-md hover:shadow-lg">
                Ø­Ø³Ù†Ø§Ù‹
            </button>
        </div>
    </div>
    
    <div id="save-modal">
        <div class="w-full h-full max-w-[95vw] md:max-w-6xl max-h-[95vh] bg-slate-900 rounded-2xl shadow-2xl flex overflow-hidden border border-slate-700 mx-4">
            
            <!-- Ø§Ù„Ù‚Ø³Ù… Ø§Ù„Ø£ÙŠÙ…Ù†: Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© -->
            <div class="flex-1 bg-[#0f172a] relative p-6 flex items-center justify-center">
                <!-- Ø®Ù„ÙÙŠØ© Ø´Ø¨ÙƒÙŠØ© Ø®ÙÙŠÙØ© -->
                <div class="absolute inset-0 opacity-10" style="background-image: radial-gradient(#6366f1 1px, transparent 1px); background-size: 20px 20px;"></div>
                
                <div class="relative shadow-2xl h-full w-full flex items-center justify-center z-10 pb-4">
                    <img id="save-img" class="max-h-full max-w-full object-contain bg-white transition-transform duration-300 shadow-xl" alt="Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„Ø·Ø¨Ø§Ø¹Ø©">
                </div>
            </div>

            <!-- Ø§Ù„Ù‚Ø³Ù… Ø§Ù„Ø£ÙŠØ³Ø±: Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª -->
            <div class="w-[320px] bg-slate-800 border-r border-slate-700 flex flex-col z-20 shadow-xl">
                 <!-- Ø±Ø£Ø³ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© -->
                 <div class="p-6 pb-4 border-b border-slate-700/50">
                     <h2 class="text-xl font-extrabold text-white mb-1 flex items-center gap-2">
                        <i class="fas fa-print text-[#6366f1]"></i> Ø·Ø¨Ø§Ø¹Ø© ÙˆØªØµØ¯ÙŠØ±
                     </h2>
                     <p class="text-slate-400 text-[11px] font-bold">Ù…Ø¹Ø§ÙŠÙ†Ø© ÙˆØªØ®ØµÙŠØµ Ø·Ø¨Ø§Ø¹Ø© A4</p>
                 </div>
                 
                 <!-- Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù‚Ø§Ø¨Ù„ Ù„Ù„ØªÙ…Ø±ÙŠØ± -->
                 <div class="flex-1 overflow-y-auto p-6 space-y-6">
                     
                     <!-- Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù†Ø³Ø® -->
                     <div class="bg-slate-700/30 p-4 rounded-xl border border-slate-600/50">
                         <div class="flex items-center justify-between mb-3">
                             <label class="text-slate-200 text-xs font-bold"><i class="fas fa-copy ml-1"></i> Ø¹Ø¯Ø¯ Ø§Ù„Ù†Ø³Ø®:</label>
                             <span class="text-sm text-slate-200 font-bold bg-slate-600/70 px-3 py-1 rounded-full" id="a4-max-text"></span>
                         </div>
                         
                         <div class="flex items-center gap-2">
                             <input type="text" inputmode="numeric" id="a4-count" class="w-full bg-slate-900 border border-slate-600 rounded-lg h-10 text-center font-bold text-white text-lg focus:ring-1 focus:ring-[#6366f1] focus:border-[#6366f1] outline-none transition" oninput="this.value = arabicToEnglish(this.value); updateA4Count()" min="1">
                         </div>
                     </div>

                     <!-- Ø®ÙŠØ§Ø±Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ© -->
                     <div class="bg-slate-700/30 p-4 rounded-xl border border-slate-600/50 space-y-4">
                         <label class="flex items-center justify-between cursor-pointer group select-none">
                             <div class="flex items-center gap-2">
                                 <div class="w-8 h-8 rounded-full bg-slate-600/50 flex items-center justify-center group-hover:bg-[#6366f1] transition duration-300 text-white">
                                     <i class="fas fa-scissors text-xs"></i>
                                 </div>
                                 <span class="text-slate-200 text-xs font-bold group-hover:text-white transition">ÙÙˆØ§ØµÙ„ Ø§Ù„Ù‚Øµ</span>
                             </div>
                             <div class="relative inline-flex items-center cursor-pointer">
                                <input type="checkbox" id="show-cut-lines" checked onchange="updateA4Count()" class="sr-only peer">
                                <div class="w-9 h-5 bg-slate-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-[#6366f1]"></div>
                             </div>
                         </label>
                     </div>

                     <!-- Ù…Ù„Ø§Ø­Ø¸Ø© -->
                     <div class="bg-blue-500/10 border border-blue-500/20 rounded-lg p-3">
                         <p class="text-[10px] text-blue-200 leading-relaxed font-bold flex gap-2">
                             <i class="fas fa-info-circle mt-0.5"></i>
                             ÙŠØªÙ… ØªØ±ØªÙŠØ¨ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ù„Ø§Ø³ØªØºÙ„Ø§Ù„ Ù…Ø³Ø§Ø­Ø© Ø§Ù„ÙˆØ±Ù‚Ø© Ø¨Ø§Ù„ÙƒØ§Ù…Ù„.
                         </p>
                     </div>
                 </div>

                 <!-- Ø°ÙŠÙ„ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© (Ø§Ù„Ø£Ø²Ø±Ø§Ø±) -->
                 <div class="p-6 pt-4 border-t border-slate-700/50 bg-slate-800 flex flex-col gap-3">
                     <button onclick="printDesignDirect()" class="w-full bg-gradient-to-r from-[#6366f1] to-[#4f46e5] text-white py-3.5 rounded-xl font-bold hover:shadow-lg hover:shadow-[#6366f1]/25 border border-white/10 active:scale-[0.98] transition flex items-center justify-center gap-2 group">
                        <i class="fas fa-print text-lg group-hover:animate-pulse"></i> <span>Ø·Ø¨Ø§Ø¹Ø© ÙÙˆØ±ÙŠØ©</span>
                     </button>
                     
                     <div class="grid grid-cols-2 gap-3">
                         <button onclick="downloadImage()" class="bg-slate-700 hover:bg-slate-600 text-white py-3 rounded-xl font-bold transition flex items-center justify-center gap-2 text-xs border border-white/5 active:scale-[0.98]">
                            <i class="fas fa-image text-emerald-400"></i> ØµÙˆØ±Ø©
                         </button>
                         <button onclick="downloadPDF()" class="bg-slate-700 hover:bg-slate-600 text-white py-3 rounded-xl font-bold transition flex items-center justify-center gap-2 text-xs border border-white/5 active:scale-[0.98]">
                            <i class="fas fa-file-pdf text-red-400"></i> PDF
                         </button>
                     </div>

                     <button onclick="closeA4Modal()" class="mt-3 text-slate-300 hover:text-white text-xs font-bold py-2 px-4 transition text-center hover:bg-slate-700/50 rounded-lg border border-slate-600 hover:border-slate-500">
                         Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ù†Ø§ÙØ°Ø©
                     </button>
                 </div>
            </div>
            
            <!-- Ø²Ø± Ù‚Ø¯ÙŠÙ… Ù…Ø®ÙÙŠ Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„ØªÙˆØ§ÙÙ‚ -->
            <button id="btn-modal-a4" onclick="generateA4Sheet()" class="hidden"></button>
        </div>
    </div>

    <!-- Ù…ÙˆØ¯Ø§Ù„ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ Ø§Ù„Ø¬Ø¯ÙŠØ¯ - Ù†Ø§Ø¹Ù… ÙˆØ®ÙÙŠÙ Ù…Ø¹ Ù„ÙˆÙ† ÙˆØ±Ø¯ÙŠ -->
    <div id="new-project-modal" class="hidden fixed inset-0 bg-black/40 z-50 flex items-center justify-center" onclick="if(event.target.id === 'new-project-modal') closeNewProjectModal()">
        <div class="bg-white rounded-2xl p-5 shadow-lg max-w-sm w-full mx-4" onclick="event.stopPropagation()">
            <!-- Ø§Ù„Ø±Ø£Ø³ Ø§Ù„Ø¨Ø³ÙŠØ· -->
            <div class="text-center mb-4">
                <h2 class="text-lg font-bold text-[#1e293b]">Ù‡Ù„ ØªØ±ÙŠØ¯ Ø­ÙØ¸ Ø§Ù„Ø¹Ù…Ù„ØŸ</h2>
                <p class="text-xs text-[#94a3b8] mt-1">Ù„Ø¯ÙŠÙƒ Ø¹Ù…Ù„ Ø­Ø§Ù„ÙŠ Ù„Ù… ÙŠØªÙ… Ø­ÙØ¸Ù‡</p>
            </div>
            
            <!-- Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø«Ù„Ø§Ø« Ø¨Ø¬Ø§Ù†Ø¨ Ø¨Ø¹Ø¶ -->
            <div class="flex gap-2 justify-center">
                <button onclick="saveCurrentAsTemplateAndNew()" class="flex-1 bg-[#ec4899] text-white px-3 py-2.5 rounded-lg text-xs font-bold hover:bg-[#db2777] transition-all shadow-sm flex items-center justify-center gap-2 group">
                    <i class="fas fa-save group-hover:scale-110 transition-transform"></i>
                    <span>Ø­ÙØ¸ Ø§Ù„Ø¹Ù…Ù„</span>
                </button>
                
                <button onclick="resetCanvasWithoutSave()" class="flex-1 bg-white border border-[#ef4444] text-[#ef4444] px-3 py-2.5 rounded-lg text-xs font-bold hover:bg-[#fef2f2] hover:border-[#dc2626] transition-all shadow-sm flex items-center justify-center gap-2 group">
                    <i class="fas fa-trash-alt group-hover:scale-110 transition-transform"></i>
                    <span>Ø¹Ø¯Ù… Ø§Ù„Ø­ÙØ¸</span>
                </button>
                
                <button onclick="closeNewProjectModal()" class="flex-1 bg-white border border-[#cbd5e1] text-[#64748b] px-3 py-2.5 rounded-lg text-xs font-bold hover:bg-[#f8fafc] hover:border-[#94a3b8] transition-all shadow-sm flex items-center justify-center gap-2 group">
                    <i class="fas fa-times group-hover:scale-110 transition-transform"></i>
                    <span>Ø¥Ù„ØºØ§Ø¡</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Ù…ÙˆØ¯Ø§Ù„ Ø­ÙØ¸ Ø¨Ø§Ø³Ù… - Ù†Ø§Ø¹Ù… ÙˆØ®ÙÙŠÙ Ù…Ø¹ Ù„ÙˆÙ† ÙˆØ±Ø¯ÙŠ -->
    <div id="save-as-modal" class="hidden fixed inset-0 bg-black/40 z-50 flex items-center justify-center" onclick="if(event.target.id === 'save-as-modal') closeSaveAsModal()">
        <div class="bg-white rounded-2xl p-5 shadow-lg max-w-sm w-full mx-4" onclick="event.stopPropagation()">
            <!-- Ø§Ù„Ø±Ø£Ø³ Ø§Ù„Ø¨Ø³ÙŠØ· -->
            <div class="text-center mb-4">
                <h2 class="text-lg font-bold text-[#1e293b] flex items-center justify-center gap-2">
                    <i class="fas fa-save text-[#ec4899]"></i>
                    <span>Ø­ÙØ¸ Ø§Ù„Ø¹Ù…Ù„</span>
                </h2>
                <p class="text-xs text-[#94a3b8] mt-1">Ø§Ø­ÙØ¸ Ø¹Ù…Ù„Ùƒ ÙƒÙ‚Ø§Ù„Ø¨ Ù…Ø­ÙÙˆØ¸</p>
            </div>
            
            <!-- Ø­Ù‚Ù„ Ø§Ù„Ø§Ø³Ù… -->
            <div class="mb-4">
                <label class="text-xs font-bold text-[#1e293b] block mb-2">Ø§Ø³Ù… Ø§Ù„Ø¹Ù…Ù„:</label>
                <input type="text" id="save-as-name" placeholder="Ø£Ø¯Ø®Ù„ Ø§Ø³Ù… Ø§Ù„Ø¹Ù…Ù„..." class="w-full px-3 py-2.5 border border-[#e2e8f0] rounded-lg text-sm outline-none focus:border-[#6366f1] focus:bg-[#f0f9ff] text-[#1e293b] transition-all" />
                <p class="text-xs text-[#94a3b8] mt-1.5">ğŸ’¡ Ø³ÙŠØªÙ… Ø­ÙØ¸ Ø¬Ù…ÙŠØ¹ Ø¹Ù†Ø§ØµØ± Ø§Ù„Ø¹Ù…Ù„</p>
            </div>
            
            <!-- Ø§Ù„Ø£Ø²Ø±Ø§Ø± -->
            <div class="flex gap-2 justify-center mb-3">
                <button onclick="executeSaveAsFile()" class="flex-1 bg-[#ec4899] text-white px-3 py-2.5 rounded-lg text-xs font-bold hover:bg-[#db2777] transition-all shadow-sm flex items-center justify-center gap-2 group">
                    <i class="fas fa-save group-hover:scale-110 transition-transform"></i>
                    <span>Ø­ÙØ¸ Ø§Ù„Ø¢Ù†</span>
                </button>
                <button onclick="closeSaveAsModal()" class="flex-1 bg-white border border-[#cbd5e1] text-[#64748b] px-3 py-2.5 rounded-lg text-xs font-bold hover:bg-[#f8fafc] hover:border-[#94a3b8] transition-all shadow-sm flex items-center justify-center gap-2 group">
                    <i class="fas fa-times group-hover:scale-110 transition-transform"></i>
                    <span>Ø¥Ù„ØºØ§Ø¡</span>
                </button>
            </div>

            <!-- Ù…Ù„Ø§Ø­Ø¸Ø© ØµØºÙŠØ±Ø© Ù…Ø¹ Ø£ÙŠÙ‚ÙˆÙ†Ø© -->
            <div class="bg-[#f0f9ff] border border-[#bfdbfe] rounded-lg p-2.5 text-center">
                <p class="text-xs text-[#1e40af] font-medium">
                    <i class="fas fa-check-circle ml-1"></i> Ø³ÙŠØªÙ… Ø­ÙØ¸ Ø§Ù„Ø¹Ù…Ù„ ÙÙŠ Ø¬Ù‡Ø§Ø²Ùƒ Ù…Ø­Ù„ÙŠØ§Ù‹
                </p>
            </div>
            <input type="hidden" id="save-as-callback">
        </div>
    </div>

    <!-- Ù…ÙˆØ¯Ø§Ù„ Ø§Ù„Ù†Ø¬Ø§Ø­ - Ù†Ø§Ø¹Ù… ÙˆØ¹ØµØ±ÙŠ -->
    <div id="success-modal" class="hidden fixed inset-0 bg-black/40 z-[60] flex items-center justify-center backdrop-blur-sm transition-all duration-300 opacity-0" onclick="closeSuccessModal()">
        <div class="bg-white rounded-2xl p-6 shadow-2xl max-w-[300px] w-full mx-4 transform transition-all duration-300 scale-90" id="success-modal-content" onclick="event.stopPropagation()">
            <div class="text-center">
                <div class="w-14 h-14 bg-green-50 rounded-full flex items-center justify-center mx-auto mb-3 shadow-inner">
                    <i class="fas fa-check text-2xl text-green-500 animate-pulse"></i>
                </div>
                <h2 class="text-base font-bold text-[#1e293b] mb-1" id="success-modal-title">ØªÙ…Øª Ø§Ù„Ø¹Ù…Ù„ÙŠØ©</h2>
                <p class="text-[11px] text-[#64748b] mb-5 leading-relaxed" id="success-modal-message">ØªÙ… ØªÙ†ÙÙŠØ° Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ Ø¨Ù†Ø¬Ø§Ø­</p>
                <button onclick="closeSuccessModal()" class="w-full bg-[#ec4899] text-white px-4 py-2.5 rounded-xl text-xs font-bold hover:bg-[#db2777] transition-all shadow-md flex items-center justify-center gap-2 group hover:shadow-lg hover:-translate-y-0.5">
                    <span>Ø­Ø³Ù†Ø§Ù‹</span>
                </button>
            </div>
        </div>
    </div>


    <!-- Ù…ÙˆØ¯Ø§Ù„ Ø§Ù„ØªØ¯Ø±Ø¬ Ø§Ù„Ù„ÙˆÙ†ÙŠ - ØªÙ… Ø¥Ù„ØºØ§Ø¤Ù‡ ÙˆØ§Ø³ØªØ¨Ø¯Ø§Ù„Ù‡ Ø¨Ø£Ø¯ÙˆØ§Øª ÙÙŠ Ø§Ù„Ø´Ø±ÙŠØ· Ø§Ù„Ø¹Ù„ÙˆÙŠ -->


    <!-- ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ -->
    <div class="max-w-7xl mx-auto p-4 grid grid-cols-1 lg:grid-cols-12 gap-6 h-screen-lg">
        
        <!-- Ø§Ù„Ù„ÙˆØ­Ø© Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠØ© -->
        <div class="lg:col-span-4 bg-white p-5 rounded-2xl shadow-md border border-[#cbd5e1] flex flex-col gap-4 h-fit" onclick="event.stopPropagation()">
            <div class="flex items-center gap-3 border-b border-[#e2e8f0] pb-3">
                <div class="w-10 h-10 bg-[#6366f1] rounded-xl flex items-center justify-center text-white shadow-md transform rotate-3"><i class="fas fa-palette text-lg"></i></div>
                <div>
                    <h1 id="studio-name-display" class="font-bold text-[#1e293b] text-2xl">Ø§Ø³ØªÙˆØ¯ÙŠÙˆ Ø§Ù„Ù…ØµÙ…Ù…ÙŠÙ† ğŸ¨</h1>
                    <p class="text-[11px] text-[#94a3b8] font-medium" style="font-family: 'Noto Serif Arabic', serif;">Ø§Ø³ØªÙˆØ¯ÙŠÙˆ Ù…ØªØ®ØµØµ | Ù…Ø³Ø§Ø­Ø§Øª Ù„Ù„Ø¥Ø¨Ø¯Ø§Ø¹ âœ¨</p>
                </div>
            </div>

            <!-- Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù†ØµÙˆØµ -->
            <div class="space-y-2 bg-[#f8fafc] p-3 rounded-xl border border-[#e2e8f0]">
                <label class="text-xs font-bold text-[#1e293b]">Ø¥Ø¶Ø§ÙØ© Ù†ØµÙˆØµ</label>
                <div class="flex flex-col gap-2">
                    <textarea id="user-text-input" rows="2" placeholder="Ø§ÙƒØªØ¨ Ø§Ù„Ù†Øµ Ù‡Ù†Ø§..." class="w-full p-2 bg-white border border-[#cbd5e1] rounded-lg text-sm outline-none focus:border-[#6366f1] text-[#1e293b] resize-none"></textarea>
                    <button onclick="addUserText()" class="bg-[#6366f1] text-white px-4 py-2 rounded-lg hover:bg-[#4f46e5] flex items-center justify-center border border-[#6366f1] text-sm font-bold shadow-sm w-full">
                        <i class="fas fa-plus ml-2"></i> Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù†Øµ
                    </button>
                </div>
            </div>

            <!-- Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ø¥Ø¶Ø§ÙØ© -->
            <div class="grid grid-cols-3 gap-2">
                <label class="col-span-2 bg-white border border-dashed border-[#6366f1] py-3 rounded-lg text-[#1e293b] hover:bg-[#f8fafc] text-xs font-bold flex items-center justify-center gap-1 cursor-pointer transition group">
                    <i class="fas fa-image text-lg text-[#6366f1] group-hover:scale-110 transition-transform"></i> ØµÙˆØ±Ø©
                    <input type="file" onchange="addRegularImage(this)" class="hidden" accept="image/*">
                </label>
                <button onclick="createNewProject()" class="bg-white border border-[#cbd5e1] py-2 rounded-lg text-[#1e293b] text-[10px] font-bold hover:bg-[#f8fafc] hover:border-[#6366f1] flex flex-col items-center gap-1 group"><i class="fas fa-file-circle-plus text-[#6366f1] group-hover:scale-110 transition-transform"></i> Ø¬Ø¯ÙŠØ¯</button>
                
                <!-- Ø²Ø± Ø§Ù„Ø¥Ø·Ø§Ø±Ø§Øª Ù…Ø¹ Dropdown -->
                <div class="relative" onclick="event.stopPropagation();">
                    <button onclick="toggleFrameDropdown()" class="w-full bg-white border border-[#cbd5e1] py-2 rounded-lg text-[#1e293b] text-[10px] font-bold hover:bg-[#f8fafc] hover:border-[#6366f1] flex flex-col items-center gap-1 group min-w-[50px]">
                        <i class="far fa-square text-[#6366f1] group-hover:scale-110 transition-transform"></i> Ø¥Ø·Ø§Ø±
                    </button>
                    
                    <!-- Dropdown Menu -->
                    <div id="frames-dropdown" class="hidden absolute top-full left-0 mt-2 bg-white border border-[#cbd5e1] rounded-lg shadow-lg z-50 p-1 w-[110px]">
                        <button onclick="addFrameType('square')" class="w-full px-2 py-1.5 text-left text-[10px] font-bold text-[#1e293b] hover:bg-[#f0f4ff] hover:text-[#6366f1] rounded transition flex items-center gap-2 mb-1">
                            <i class="far fa-square text-sm"></i> Ù…Ø±Ø¨Ø¹
                        </button>
                        <button onclick="addFrameType('rounded')" class="w-full px-2 py-1.5 text-left text-[10px] font-bold text-[#1e293b] hover:bg-[#f0f4ff] hover:text-[#6366f1] rounded transition flex items-center gap-2 mb-1">
                            <i class="far fa-square text-sm" style="border-radius: 6px;"></i> Ù…Ù†Ø­Ù†ÙŠ
                        </button>
                        <button onclick="addFrameType('circle')" class="w-full px-2 py-1.5 text-left text-[10px] font-bold text-[#1e293b] hover:bg-[#f0f4ff] hover:text-[#6366f1] rounded transition flex items-center gap-2">
                             <i class="far fa-circle text-sm"></i> Ø¯Ø§Ø¦Ø±Ø©
                        </button>
                    </div>
                </div>
                
                <!-- Ø²Ø± Ø§Ù„Ø£Ø´ÙƒØ§Ù„ Ù…Ø¹ Dropdown -->
                <div class="relative" onclick="event.stopPropagation();">
                    <button onclick="addShape()" class="w-full bg-white border border-[#cbd5e1] py-2 rounded-lg text-[#1e293b] text-[10px] font-bold hover:bg-[#f8fafc] hover:border-[#6366f1] flex flex-col items-center gap-1 group"><i class="fas fa-square-full text-[#6366f1] group-hover:scale-110 transition-transform"></i> Ø´ÙƒÙ„</button>
                    
                    <!-- Dropdown Menu -->
                    <div id="shapes-dropdown" class="hidden absolute top-full left-0 right-0 mt-2 bg-white border border-[#cbd5e1] rounded-lg shadow-lg z-40 p-2">
                        <button onclick="addShapeType('square')" class="w-full px-3 py-2 text-left text-[11px] font-bold text-[#1e293b] hover:bg-[#f0f4ff] hover:border-l-4 hover:border-l-[#6366f1] rounded transition flex items-center gap-2">
                            <div class="w-4 h-4 bg-[#6366f1] rounded" style="border-radius: 2px;"></div> Ù…Ø±Ø¨Ø¹
                        </button>
                        <button onclick="addShapeType('circle')" class="w-full px-3 py-2 text-left text-[11px] font-bold text-[#1e293b] hover:bg-[#f0f4ff] hover:border-l-4 hover:border-l-[#6366f1] rounded transition flex items-center gap-2">
                            <div class="w-4 h-4 bg-[#6366f1] rounded-full"></div> Ø¯Ø§Ø¦Ø±Ø©
                        </button>
                        <button onclick="addShapeType('line')" class="w-full px-3 py-2 text-left text-[11px] font-bold text-[#1e293b] hover:bg-[#f0f4ff] hover:border-l-4 hover:border-l-[#6366f1] rounded transition flex items-center gap-2">
                            <div class="w-4 h-0.5 bg-[#6366f1]"></div> Ø®Ø·
                        </button>
                        <button onclick="addShapeType('rounded')" class="w-full px-3 py-2 text-left text-[11px] font-bold text-[#1e293b] hover:bg-[#f0f4ff] hover:border-l-4 hover:border-l-[#6366f1] rounded transition flex items-center gap-2">
                            <div class="w-4 h-4 bg-[#6366f1] rounded-lg" style="border-radius: 4px;"></div> Ù…Ù†Ø­Ù†Ù‰
                        </button>
                    </div>
                </div>
                
                <label class="bg-white border border-[#cbd5e1] py-2 rounded-lg text-[#1e293b] text-[10px] font-bold hover:bg-[#f8fafc] hover:border-[#6366f1] flex flex-col items-center gap-1 cursor-pointer group transition">
                    <i class="fas fa-folder-open text-[#6366f1] group-hover:scale-110 transition-transform"></i> ÙØªØ­ Ù…Ù„Ù
                    <input type="file" onchange="handleUniversalFile(this)" class="hidden" accept=".template,.json,.pdf,.tif,.tiff,.psd,.png,.jpg,.jpeg,.webp,.gif">
                </label>
            </div>

            <!-- Ù…Ù‚Ø§Ø³Ø§Øª Ø§Ù„Ø¹Ù…Ù„ (ÙŠØ¯ÙˆÙŠ ÙÙ‚Ø· - 10x10 Ø§ÙØªØ±Ø§Ø¶ÙŠ) -->
            <div class="bg-[#f8fafc] p-3 rounded-xl border border-[#e2e8f0]">
                <label class="text-xs font-bold text-[#1e293b] mb-2 block flex items-center gap-2">
                    <i class="fas fa-ruler-combined text-[#6366f1]"></i> Ø£Ø¨Ø¹Ø§Ø¯ Ø§Ù„ØªØµÙ…ÙŠÙ… (Ø³Ù…)
                </label>
                
                <div class="grid grid-cols-2 gap-2 mb-2">
                    <div class="relative">
                        <label class="text-[9px] text-[#64748b] font-bold block mb-1">Ø§Ù„Ø¹Ø±Ø¶ (Width)</label>
                        <input type="text" inputmode="decimal" id="custom-width" value="6" class="w-full pl-8 px-2 py-1.5 border border-[#cbd5e1] rounded-lg text-sm outline-none focus:border-[#6366f1] text-center font-bold text-[#1e293b]" onfocus="this.select()" oninput="this.value = arabicToEnglish(this.value); applyCustomSizeSimple()">
                        <span class="absolute left-2 top-[26px] text-[12px] font-bold text-black">Ø³Ù…</span>
                    </div>
                    <div class="relative">
                        <label class="text-[9px] text-[#64748b] font-bold block mb-1">Ø§Ù„Ø§Ø±ØªÙØ§Ø¹ (Height)</label>
                        <input type="text" inputmode="decimal" id="custom-height" value="6" class="w-full pl-8 px-2 py-1.5 border border-[#cbd5e1] rounded-lg text-sm outline-none focus:border-[#6366f1] text-center font-bold text-[#1e293b]" onfocus="this.select()" oninput="this.value = arabicToEnglish(this.value); applyCustomSizeSimple()">
                        <span class="absolute left-2 top-[26px] text-[12px] font-bold text-black">Ø³Ù…</span>
                    </div>
                </div>
                
                <div class="mt-2 text-center">
                    <span id="size-display" class="text-[10px] font-bold text-[#64748b] bg-white px-2 py-1 rounded border border-[#e2e8f0]">1181 Ã— 1181 px</span>
                </div>
                
                <!-- Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ù€ Zoom -->
                <div class="mt-4 bg-gradient-to-b from-[#f0f9ff] to-[#e0f2fe] p-3 rounded-lg border border-[#7dd3fc]">
                    <div class="flex justify-between items-center mb-2">
                        <label class="text-[9px] text-[#0c4a6e] font-bold">ğŸ” Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø²ÙˆÙ…</label>
                        <span id="zoom-display" class="text-[10px] font-bold text-[#0c4a6e] bg-white px-2 py-0.5 rounded">100%</span>
                    </div>
                    <input type="range" id="zoom-slider" min="25" max="200" value="100" class="w-full cursor-pointer" oninput="setCustomZoom(this.value)">
                    <div class="flex gap-1 mt-2">
                        <button onclick="setCustomZoom(50)" class="flex-1 bg-white border border-[#7dd3fc] text-[#0c4a6e] text-[9px] font-bold py-1 rounded hover:bg-[#e0f2fe]">50%</button>
                        <button onclick="setCustomZoom(75)" class="flex-1 bg-white border border-[#7dd3fc] text-[#0c4a6e] text-[9px] font-bold py-1 rounded hover:bg-[#e0f2fe]">75%</button>
                        <button onclick="setCustomZoom(100)" class="flex-1 bg-white border border-[#7dd3fc] text-[#0c4a6e] text-[9px] font-bold py-1 rounded hover:bg-[#e0f2fe]">100%</button>
                        <button onclick="setCustomZoom(150)" class="flex-1 bg-white border border-[#7dd3fc] text-[#0c4a6e] text-[9px] font-bold py-1 rounded hover:bg-[#e0f2fe]">150%</button>
                    </div>
                </div>
            </div>

            <!-- Ù‚Ø³Ù… Ù…ÙƒØªØ¨Ø© Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ø±Ø³Ù…ÙŠØ© -->
            <div class="bg-[#f8fafc] p-3 rounded-xl border border-[#e2e8f0]">
                <div class="flex justify-between items-center cursor-pointer" onclick="toggleAssetsLibrary()">
                    <label class="text-xs font-bold text-[#1e293b] flex items-center gap-2 cursor-pointer">
                        <i class="fas fa-shapes text-[#6366f1]"></i> Ù…ÙƒØªØ¨Ø© Ø§Ù„Ø¹Ù†Ø§ØµØ±
                    </label>
                    <i id="assets-library-arrow" class="fas fa-chevron-left text-[#64748b] text-xs transition-transform duration-200"></i>
                </div>
                
                <div id="assets-library-content" class="hidden mt-3 flex-col gap-2">
                    <!-- Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ù†Ø³Ø¯Ù„Ø© Ù„Ù„ØªØµÙ†ÙŠÙØ§Øª -->
                    <div class="w-full">
                        <select id="assets-category-select" class="w-full p-2 text-[11px] font-bold bg-white border border-[#cbd5e1] rounded-lg text-[#1e293b] outline-none focus:border-[#6366f1]" onchange="loadAssetsCategory()">
                            <option value="">ğŸ“‚ Ø§Ø®ØªØ± ØªØµÙ†ÙŠÙØ§Ù‹...</option>
                        </select>
                    </div>
                    
                    <!-- Ø´Ø¨ÙƒØ© Ø§Ù„Ø¹Ù†Ø§ØµØ± -->
                    <div id="assets-grid" class="grid grid-cols-3 gap-2 max-h-[200px] overflow-y-auto p-1 bg-white rounded-lg border border-[#e2e8f0]">
                        <div class="col-span-3 text-center text-[10px] text-[#64748b] py-4">Ø§Ø®ØªØ± ØªØµÙ†ÙŠÙØ§Ù‹ Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø¹Ù†Ø§ØµØ±</div>
                    </div>
                </div>
            </div>

            <!-- Ù‚Ø³Ù… Ø§Ù„Ø®ØµØ§Ø¦Øµ ÙˆØ§Ù„Ø­ÙØ¸ -->
            <div id="style-panel" class="bg-white p-4 rounded-2xl shadow-lg border border-[#cbd5e1] transition-all" onclick="event.stopPropagation()">
                <div class="flex justify-between items-center mb-4 border-b border-[#e2e8f0] pb-2 flex-wrap gap-2">
                    <span class="text-xs font-black text-[#6366f1] uppercase tracking-wider" id="panel-title">Ø§Ù„ØªØµØ¯ÙŠØ±</span>
                    <!-- Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø­ÙØ¸ -->
                    <div class="flex gap-2 flex-wrap">
                        <button onclick="saveWorkDirectly()" class="bg-[#6366f1] text-white px-3 py-1.5 rounded-lg text-[10px] font-bold hover:bg-[#4f46e5] flex items-center gap-1 shadow-md transition">
                            <i class="fas fa-image"></i> Ø­ÙØ¸ ØµÙˆØ±Ø©
                        </button>
                        <button onclick="openSaveAsModal()" class="bg-[#6366f1] text-white px-3 py-1.5 rounded-lg text-[10px] font-bold hover:bg-[#4f46e5] flex items-center gap-1 shadow-md transition">
                            <i class="fas fa-download"></i> Ø­ÙØ¸ ÙƒÙ…Ù„Ù
                        </button>
                        <button onclick="generateA4Sheet()" class="bg-[#ec4899] text-white px-3 py-1.5 rounded-lg text-[10px] font-bold hover:bg-[#db2777] flex items-center gap-1 shadow-md transition">
                            <i class="fas fa-print"></i> Ø·Ø¨Ø§Ø¹Ø© A4
                        </button>
                    </div>
                </div>

                <div id="no-selection-msg" class="text-center py-4 text-[#64748b] text-xs font-bold opacity-70">
                    ØªØµØ¯ÙŠØ± Ø§Ù„Ø¹Ù…Ù„ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ
                </div>

                <div id="text-controls" class="hidden space-y-4">
                    <input type="hidden" id="font-size">
                    <input type="hidden" id="font-size-input">
                    <input type="hidden" id="font-family">
                </div>

                <div id="frame-controls" class="hidden space-y-4">
                </div>
            </div>
        </div>

        <!-- Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø¹Ù…Ù„ -->
        <div class="lg:col-span-8 flex flex-col gap-1">
            
            <!-- Ø´Ø±ÙŠØ· Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ø¹Ù„ÙˆÙŠ -->
            <div class="flex flex-wrap items-center bg-white p-2 rounded-xl border border-[#cbd5e1] shadow-sm justify-between gap-y-2" onclick="event.stopPropagation()">
                
                <!-- Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© -->
                <div class="flex items-center gap-1 md:gap-2">
                    <button onclick="undoAction()" class="p-1.5 md:p-2 text-[#64748b] hover:text-[#6366f1]"><i class="fas fa-undo"></i></button>
                    <button onclick="redoAction()" class="p-1.5 md:p-2 text-[#64748b] hover:text-[#6366f1]"><i class="fas fa-redo"></i></button>
                    <div class="w-px h-5 bg-[#e2e8f0] mx-1"></div>
                    
                    <!-- Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ø®Ù„ÙÙŠØ© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© -->
                    <div class="flex items-center gap-2 px-2 py-1 bg-[#f8fafc] rounded-lg border border-[#e2e8f0]">
                        <label class="text-[10px] md:text-xs font-bold text-[#1e293b] cursor-pointer flex items-center gap-2 hover:text-[#6366f1] transition group">
                            <i class="fas fa-fill-drip group-hover:scale-110 transition-transform"></i> Ù„ÙˆÙ† Ø§Ù„Ø®Ù„ÙÙŠØ©
                            <!-- Improved Color Circle: Div shows color, input is invisible overlay -->
                            <div id="bg-color-preview" class="relative w-6 h-6 rounded-full border border-slate-300 shadow-sm transition-transform hover:scale-110" style="background-color: #ffffff;">
                                <input type="color" id="main-bg-color" oninput="setCardBackgroundColor(this.value)" value="#ffffff" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer">
                            </div>
                        </label>
                        <div class="w-px h-4 bg-[#cbd5e1]"></div>
                        <button onclick="setCardTransparent()" class="text-[#64748b] hover:text-[#6366f1] transition p-1 rounded hover:bg-white" title="Ø®Ù„ÙÙŠØ© Ø´ÙØ§ÙØ©">
                            <i class="fas fa-chess-board text-sm"></i>
                        </button>
                    </div>
                </div>

                <!-- Ù…Ø¬Ù…ÙˆØ¹Ø© Ø£Ø¯ÙˆØ§Øª Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ -->
                <div class="flex items-center gap-1 md:gap-2">
                      <button onclick="toggleGradient()" id="btn-grad" class="px-2 py-1.5 rounded text-[10px] md:text-xs font-bold bg-[#f8fafc] text-[#1e293b] hover:bg-[#6366f1] hover:text-white transition flex items-center gap-1 border border-[#e2e8f0]">
                        <i class="fas fa-adjust"></i> Ø§Ù„ØªØ¯Ø±Ø¬
                    </button>
                    <!-- ØªØ¹Ø¯ÙŠÙ„ Ø²Ø± Ø§Ù„Ù…Ù…Ø­Ø§Ø© Ø­Ø³Ø¨ Ø§Ù„Ø·Ù„Ø¨ Ù„Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ù†Øµ Ø¯Ø§Ø¦Ù…Ø§Ù‹ -->
                    <button onclick="toggleEraserMode()" id="btn-eraser" class="px-2 py-1.5 rounded text-[10px] md:text-xs font-bold bg-[#f8fafc] text-[#1e293b] hover:bg-[#6366f1] hover:text-white transition flex items-center gap-1 border border-[#e2e8f0]">
                        <i class="fas fa-eraser"></i> <span class="ml-1 text-[9px] font-black">Ø§Ù„Ù…Ù…Ø­Ø§Ø©</span>
                    </button>
                    <!-- Ø²Ø± Ø§Ù„Ù‚Øµ Ø§Ù„Ø°ÙƒÙŠ (Lasso) Ø§Ù„Ø¬Ø¯ÙŠØ¯ -->
                    <button onclick="toggleLassoMode()" id="btn-lasso" class="px-2 py-1.5 rounded text-[10px] md:text-xs font-bold bg-[#f8fafc] text-[#1e293b] hover:bg-[#6366f1] hover:text-white transition flex items-center gap-1 border border-[#e2e8f0]">
                        <i class="fas fa-cut"></i> <span class="ml-1 text-[9px] font-black">Ù‚Øµ Ø°ÙƒÙŠ</span>
                    </button>
                    <!-- Ø²Ø± Ø§Ù„Ù‚Øµ (Crop) Ø§Ù„Ø¬Ø¯ÙŠØ¯ -->
                    <button onclick="toggleCropMode()" id="btn-crop" class="px-2 py-1.5 rounded text-[10px] md:text-xs font-bold bg-[#f8fafc] text-[#1e293b] hover:bg-[#6366f1] hover:text-white transition flex items-center gap-1 border border-[#e2e8f0]">
                        <i class="fas fa-crop"></i> <span class="ml-1 text-[9px] font-black">Ù‚Øµ</span>
                    </button>
                    <!-- Ø²Ø± Ø§Ù„ÙŠØ¯ (Hand Tool) Ù„Ù„ØªØ­Ø±ÙŠÙƒ -->
                    <button onclick="toggleHandMode()" id="btn-hand" class="w-8 h-8 rounded-lg text-lg bg-[#f8fafc] text-[#1e293b] hover:bg-[#6366f1] hover:text-white transition flex items-center justify-center border border-[#e2e8f0] shadow-sm hover:shadow-md" title="Ø£Ø¯Ø§Ø© Ø§Ù„ÙŠØ¯ - ØªØ­Ø±ÙŠÙƒ Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø¹Ù…Ù„">
                        <i class="fa-regular fa-hand"></i>
                    </button>
                    <!-- Universal File Input: Supports All Formats -->
                    <input type="file" onchange="handleUniversalFile(this)" class="hidden" accept=".tif,.tiff,.pdf,.psd,.ai,.eps,.svg,.png,.jpg,.jpeg,.webp,.bmp">
                </div>
                
                <!-- Ù„ÙˆØ­Ø§Øª Ø§Ù„ØªØ­ÙƒÙ… -->
                

                <!-- Ø§Ù„Ø£Ù„ÙˆØ§Ù† Ø§Ù„Ù…ÙØ¶Ù„Ø© -->
                <div id="fav-colors-row" class="bg-[#f8fafc] px-2 py-1.5 rounded-lg border border-[#e2e8f0] flex items-center gap-2 overflow-x-auto mb-2">
                    <span class="text-[9px] font-bold text-[#1e293b] whitespace-nowrap">Ù…ÙØ¶Ù„Ø©:</span>
                    <div id="fav-colors-container" class="flex items-center gap-1.5 flex-wrap">
                        <!-- Ø³ÙŠØªÙ… ØªØ¹Ø¨Ø¦ØªÙ‡Ø§ Ø¨ÙˆØ§Ø³Ø·Ø© JS -->
                    </div>
                    <div class="w-px h-4 bg-[#e2e8f0] mx-1"></div>
                    <div class="relative" title="Ø¥Ø¶Ø§ÙØ© Ù„ÙˆÙ† Ø¬Ø¯ÙŠØ¯">
                        <label for="add-fav-color" class="w-5 h-5 rounded-full bg-white border border-dashed border-gray-400 flex items-center justify-center cursor-pointer hover:border-[#6366f1] text-gray-400 hover:text-[#6366f1] transition shadow-sm">
                            <i class="fas fa-plus text-[8px]"></i>
                        </label>
                        <input type="color" id="add-fav-color" class="absolute opacity-0 w-0 h-0" onchange="addFavoriteColor(this.value)">
                    </div>

                    <!-- Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø¹Ù†ØµØ± Ø§Ù„Ù…Ø­Ø¯Ø¯ (Ø´ÙØ§ÙÙŠØ© Ø§Ù„ØµÙˆØ±Ø©) -->
                    <div id="quick-props" class="hidden flex items-center gap-1 border-r border-[#e2e8f0] pr-2 mr-2">
                        <span class="text-[9px] text-[#1e293b] font-bold whitespace-nowrap">Ø´ÙØ§ÙÙŠØ©:</span>
                        <input type="range" id="layer-opacity" min="0" max="100" value="100" oninput="updateLayerOpacity(this.value)" class="w-16 h-1.5 bg-[#e2e8f0] rounded-lg accent-[#6366f1] cursor-pointer">
                        <span id="opacity-value" class="text-[9px] font-bold text-[#6366f1] w-6">100%</span>
                        
                        <!-- Ø¹Ù†Ø§ØµØ± Ù…Ø®ÙÙŠØ© Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠ -->
                        <span id="text-color-section" class="hidden">
                             <input type="color" id="quick-color" oninput="updateStyle('color', this.value)">
                        </span>
                    </div>

                    <!-- Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¥Ø·Ø§Ø± (ØªÙ… Ù†Ù‚Ù„Ù‡Ø§ Ù‡Ù†Ø§) -->
                    <div id="frame-controls-toolbar" class="hidden flex items-center gap-1 border-r border-[#e2e8f0] pr-2 mr-2">
                        <span class="text-[9px] font-bold text-[#1e293b]">Ù„ÙˆÙ† Ø§Ù„Ø­Ø¯:</span>
                        <input type="color" id="border-color" oninput="updateStyle('borderColor', this.value)" class="w-5 h-5 rounded cursor-pointer border border-[#cbd5e1]">
                        <div class="w-px h-4 bg-[#cbd5e1] mx-1"></div>
                        <span class="text-[9px] font-bold text-[#1e293b]">Ø³Ù…Ùƒ:</span>
                        <input type="range" id="border-width" min="0" max="20" value="1" oninput="updateStyle('borderWidth', this.value + 'px')" class="w-16 h-1.5 bg-[#e2e8f0] rounded-lg accent-[#6366f1]">
                        <div class="w-px h-4 bg-[#cbd5e1] mx-1"></div>
                        <span class="text-[9px] font-bold text-[#1e293b]">Ù„ÙˆÙ†:</span>
                        <input type="color" id="bg-color" oninput="updateStyle('backgroundColor', this.value)" class="w-5 h-5 rounded cursor-pointer border border-[#cbd5e1]">
                    </div>
                </div>

                <!-- Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ¯Ø±Ø¬ -->
                <div id="grad-controls" class="controls-row bg-[#f8fafc] px-2 py-1.5 rounded-lg border border-[#e2e8f0]">
                    <!-- Global Overlay Controls -->
                    <div id="global-grad-inputs" class="flex items-center gap-2">
                        <span class="text-[9px] font-bold text-[#1e293b]">ØªØ¯Ø±Ø¬:</span>
                        <input type="color" id="global-grad-start" value="#000000" oninput="updateGlobalGradient()" class="w-5 h-5 rounded cursor-pointer border-none bg-transparent" title="Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„ØªØ¯Ø±Ø¬ (Ø£Ø³ÙÙ„)">
                        <input type="color" id="global-grad-end" value="#ffffff" oninput="updateGlobalGradient()" class="w-5 h-5 rounded cursor-pointer border-none bg-transparent" title="Ù†Ù‡Ø§ÙŠØ© Ø§Ù„ØªØ¯Ø±Ø¬ (Ø£Ø¹Ù„Ù‰)">
                        
                        <div class="w-px h-4 bg-[#6366f1] mx-1"></div>
                        <input type="range" min="0" max="1" step="0.1" value="0.8" oninput="updateGlobalGradient()" id="global-grad-opacity" class="w-16 h-1.5 accent-[#6366f1] cursor-pointer" title="Ø§Ù„Ø´ÙØ§ÙÙŠØ©">
                        <div class="w-px h-4 bg-[#6366f1] mx-1"></div>
                        <span class="text-[9px] font-bold text-[#1e293b]">Ø§Ù„ØªÙ…Ø¯Ø¯:</span>
                        <input type="range" min="10" max="100" value="50" oninput="updateGlobalGradient()" id="global-grad-height" class="w-16 h-1.5 accent-[#6366f1] cursor-pointer" title="Ø§Ø±ØªÙØ§Ø¹ Ø§Ù„ØªØ¯Ø±Ø¬">
                    </div>

                    <!-- Element Gradient Controls -->
                    <div id="element-grad-inputs" class="hidden items-center gap-2">
                        <span class="text-[9px] font-bold text-[#1e293b]">Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©:</span>
                        <input type="color" id="grad-start-color" value="#6366f1" oninput="syncFloatGradientInputs('start', this.value); updateElementGradient()" class="w-5 h-5 rounded cursor-pointer border-none bg-transparent">
                        
                        <span class="text-[9px] font-bold text-[#1e293b]">Ø§Ù„Ù†Ù‡Ø§ÙŠØ©:</span>
                        <input type="color" id="grad-end-color" value="#ec4899" oninput="syncFloatGradientInputs('end', this.value); updateElementGradient()" class="w-5 h-5 rounded cursor-pointer border-none bg-transparent">
                        
                        <div class="w-px h-4 bg-[#6366f1] mx-1"></div>
                        
                        <span class="text-[9px] font-bold text-[#1e293b]">Ø§Ù„Ø²Ø§ÙˆÙŠØ©:</span>
                        <input type="range" min="0" max="360" value="90" id="grad-angle" oninput="syncFloatGradientInputs('angle', this.value); updateElementGradient()" class="w-16 h-1.5 accent-[#6366f1] cursor-pointer" title="Ø²Ø§ÙˆÙŠØ© Ø§Ù„ØªØ¯Ø±Ø¬">

                        <div class="w-px h-4 bg-[#6366f1] mx-1"></div>

                        <span class="text-[9px] font-bold text-[#1e293b]">Ø§Ù„Ø´ÙØ§ÙÙŠØ©:</span>
                        <input type="range" min="0" max="1" step="0.1" value="1" id="grad-opacity" oninput="updateElementGradient()" class="w-16 h-1.5 accent-[#6366f1] cursor-pointer" title="Ø´ÙØ§ÙÙŠØ© Ø§Ù„ØªØ¯Ø±Ø¬">
                        
                        <div class="w-px h-4 bg-[#6366f1] mx-1"></div>
                        <button onclick="toggleGradient()" class="px-2 py-0.5 bg-red-500 text-white rounded text-[9px] font-bold hover:bg-red-600 transition" title="Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªØ¯Ø±Ø¬">
                            <i class="fas fa-times"></i> Ø¥Ù„ØºØ§Ø¡
                        </button>
                    </div>
                </div>

                <!-- ØªÙ… Ù†Ù‚Ù„ Ø£Ø¯ÙˆØ§Øª Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù†ØµÙˆØµ ÙˆØ§Ù„Ø£Ø·Ø± Ø¥Ù„Ù‰ Ù†Ø§ÙØ°Ø© Ø¹Ø§Ø¦Ù…Ø© -->


                <!-- Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ù…Ø­Ø§Ø© -->
                <div id="eraser-controls" class="controls-row bg-[#f8fafc] px-2 py-1.5 rounded-lg border border-[#e2e8f0]">
                    <div class="flex items-center gap-1 pl-2">
                        <label class="flex items-center gap-1 cursor-pointer">
                            <input type="checkbox" id="eraser-protect-bg" checked class="w-3 h-3 accent-[#6366f1]">
                            <span class="text-[9px] font-bold text-[#1e293b]">Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ø®Ù„ÙÙŠØ©</span>
                        </label>
                    </div>
                    
                    <div class="flex items-center gap-1">
                         <span class="text-[9px] font-bold text-[#1e293b]">Ø­Ø¬Ù…:</span>
                         <input type="range" min="5" max="100" value="30" id="eraser-size" class="w-12 h-1 accent-[#6366f1] cursor-pointer">
                         <span id="eraser-size-display" class="text-[9px] font-bold w-4">30</span>
                    </div>

                    <div class="flex items-center gap-1">
                        <span class="text-[9px] font-bold text-[#1e293b]">Ù†Ø¹ÙˆÙ…Ø©:</span>
                        <input type="range" min="0" max="50" value="0" id="eraser-softness" class="w-12 h-1 accent-[#6366f1] cursor-pointer">
                        <span id="eraser-softness-display" class="text-[9px] font-bold w-4">0</span>
                    </div>
                    
                    <div class="w-px h-4 bg-[#6366f1] mx-1"></div>
                    <!-- ØªØ¹Ø¯ÙŠÙ„ Ø²Ø± Ø§Ù„Ù…Ù…Ø­Ø§Ø© Ø§Ù„Ø³Ø­Ø±ÙŠØ© Ù„Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ù†Øµ -->
                    <button id="btn-magic" onclick="toggleMagicMode()" class="px-2 py-0.5 rounded text-[9px] font-bold bg-white border border-[#cbd5e1] text-[#1e293b] hover:bg-[#6366f1] hover:text-white transition flex items-center gap-1" title="Ù…Ù…Ø­Ø§Ø© Ø³Ø­Ø±ÙŠØ©">
                        <i class="fas fa-magic"></i> <span class="ml-1 text-[9px] font-black">Ø§Ù„Ù…Ù…Ø­Ø§Ø© Ø§Ù„Ø³Ø­Ø±ÙŠØ©</span>
                    </button>
                    
                    <div id="magic-tolerance-control" class="hidden items-center gap-1">
                         <span class="text-[9px] font-bold text-[#6366f1]">Ø¯Ù‚Ø©:</span>
                         <input type="range" min="1" max="100" value="30" id="magic-tolerance" class="w-10 h-1 accent-[#6366f1] cursor-pointer">
                         <span id="magic-tolerance-display" class="text-[9px] font-bold w-4">30</span>
                    </div>

                    <div class="w-px h-4 bg-[#6366f1] mx-1"></div>
                    <button onclick="exitEraserMode()" class="px-2 py-0.5 rounded text-[9px] font-bold bg-slate-300 text-slate-700 hover:bg-slate-400 transition">Ø¥Ù†Ù‡Ø§Ø¡</button>
                </div>
            </div>

            <div class="bg-[#f1f5f9] p-2 rounded text-[10px] text-[#1e293b] border border-[#e2e8f0] flex items-center gap-2 font-bold">
                <i class="fas fa-info-circle text-[#6366f1]"></i> <span>Ø§Ø¶ØºØ· Ù…Ø±ØªÙŠÙ† (Double Tap) Ù„Ù‚ÙÙ„/ÙØªØ­ Ø§Ù„Ø¹Ù†ØµØ±</span>
            </div>

            <div class="preview-area" onclick="deselect(event)">
                <div id="card-wrapper">
                    <div id="ruler-h" class="ruler ruler-h"></div>
                    <div id="ruler-v" class="ruler ruler-v"></div>
                    <div id="card" onmousedown="deselectOnCard(event)" ontouchstart="deselectOnCard(event); event.preventDefault(); event.stopPropagation();" ontouchend="event.preventDefault(); event.stopPropagation();">
                        <div id="card-gradient"></div>
                    </div>
                    <!-- Crop Overlay -->
                    <div id="crop-overlay" class="hidden absolute top-0 left-0 w-full h-full pointer-events-auto z-[50000]" style="background: rgba(0, 0, 0, 0.5);">
                        <!-- Crop Area (draggable and resizable) -->
                        <div id="crop-area" class="absolute border-2 border-yellow-400" style="box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5), inset 0 0 0 1000px rgba(0, 0, 0, 0); cursor: move; background-color: transparent;">
                            <!-- Top-left corner handle -->
                            <div id="crop-handle-tl" class="absolute w-3 h-3 bg-yellow-400 border border-white cursor-nwse-resize" style="top: -6px; left: -6px;"></div>
                            <!-- Top-right corner handle -->
                            <div id="crop-handle-tr" class="absolute w-3 h-3 bg-yellow-400 border border-white cursor-nesw-resize" style="top: -6px; right: -6px;"></div>
                            <!-- Bottom-left corner handle -->
                            <div id="crop-handle-bl" class="absolute w-3 h-3 bg-yellow-400 border border-white cursor-nesw-resize" style="bottom: -6px; left: -6px;"></div>
                            <!-- Bottom-right corner handle -->
                            <div id="crop-handle-br" class="absolute w-3 h-3 bg-yellow-400 border border-white cursor-nwse-resize" style="bottom: -6px; right: -6px;"></div>
                            <!-- Top edge handle -->
                            <div id="crop-handle-t" class="absolute w-6 h-2 bg-yellow-400 border border-white cursor-ns-resize" style="top: -5px; left: 50%; transform: translateX(-50%);"></div>
                            <!-- Bottom edge handle -->
                            <div id="crop-handle-b" class="absolute w-6 h-2 bg-yellow-400 border border-white cursor-ns-resize" style="bottom: -5px; left: 50%; transform: translateX(-50%);"></div>
                            <!-- Left edge handle -->
                            <div id="crop-handle-l" class="absolute w-2 h-6 bg-yellow-400 border border-white cursor-ew-resize" style="left: -5px; top: 50%; transform: translateY(-50%);"></div>
                            <!-- Right edge handle -->
                            <div id="crop-handle-r" class="absolute w-2 h-6 bg-yellow-400 border border-white cursor-ew-resize" style="right: -5px; top: 50%; transform: translateY(-50%);"></div>
                        </div>
                        <!-- Crop Buttons -->
                        <div class="absolute bottom-6 left-1/2 transform -translate-x-1/2 flex gap-2 z-[50001]">
                            <button onclick="applyCrop()" class="px-4 py-2 bg-green-500 text-white rounded font-bold text-sm hover:bg-green-600 transition">âœ“ ØªØ·Ø¨ÙŠÙ‚</button>
                            <button onclick="exitCropMode()" class="px-4 py-2 bg-red-500 text-white rounded font-bold text-sm hover:bg-red-600 transition">âœ• Ø¥Ù„ØºØ§Ø¡</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙÙˆØªØ± -->

    <!-- Ù†Ø§ÙØ°Ø© Ø£Ø¯ÙˆØ§Øª Ø¹Ø§Ø¦Ù…Ø© (Ø¨Ø¯ÙŠÙ„Ø© Ø¹Ù† Ø§Ù„Ø´Ø±ÙŠØ· Ø§Ù„Ø¹Ù„ÙˆÙŠ Ù„Ù…Ù†Ø¹ Ø¥Ø²Ø§Ø­Ø© Ø§Ù„ØªØµÙ…ÙŠÙ…) -->
    <div id="floating-context-toolbar" class="hidden fixed top-[18%] left-1/2 transform -translate-x-1/2 z-[99999] bg-white/95 backdrop-blur shadow-2xl rounded-2xl border border-indigo-100 p-2 flex flex-col gap-2 transition-all duration-300 pointer-events-auto min-w-[280px] max-h-[80vh] overflow-y-auto" style="box-shadow: 0 4px 16px -4px rgba(0,0,0,0.10);">
        
        <!-- Header with Close Button (Draggable Handle) -->
        <div id="floating-toolbar-header" class="flex justify-between items-center px-1 mb-1 border-b border-gray-100 pb-1 cursor-move select-none sticky top-0 bg-white/95" title="Ø§Ø¶ØºØ· ÙˆØ§Ø³Ø­Ø¨ Ù„Ù„ØªØ­Ø±ÙŠÙƒ">
            <span class="text-[10px] text-gray-400 font-bold pointer-events-none">Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø¹Ù†ØµØ±</span>
            <button onclick="closeFloatingToolbar()" class="text-red-500 hover:text-red-700 w-5 h-5 flex items-center justify-center rounded-full hover:bg-red-50 transition" title="Ø¥ØºÙ„Ø§Ù‚">
                <i class="fas fa-times text-[12px]"></i>
            </button>
        </div>

        <!-- Ø§Ù„ØµÙ Ø§Ù„Ø£ÙˆÙ„: Ø²Ø± Ø§Ù„ØªØ¯Ø±Ø¬ + Ù„ÙˆÙ† Ø§Ù„Ù†Øµ + Ø­Ø¬Ù… Ø§Ù„Ø®Ø· -->
        <div id="gradient-toggle-row" class="hidden controls-row px-2 py-1 rounded items-center gap-2 justify-start flex-wrap">
            <button id="btn-toggle-gradient" onclick="toggleGradientMode()" class="px-2 py-1 rounded text-[9px] font-bold bg-[#f8fafc] text-[#334155] hover:bg-[#6366f1] hover:text-white transition flex items-center gap-1 border border-[#e2e8f0] shadow-sm">
                <i class="fas fa-fill-drip text-[8px]"></i> ØªØ¯Ø±Ø¬
            </button>
            <div class="w-px h-4 bg-[#e2e8f0]"></div>
            <span class="text-[9px] font-bold text-[#1e293b] whitespace-nowrap">Ù„ÙˆÙ† Ø§Ù„Ù†Øµ:</span>
            <input type="color" id="top-text-color" value="#1e293b" onchange="applyTextColor(this.value)" oninput="applyTextColor(this.value)" class="w-6 h-6 rounded cursor-pointer border border-[#cbd5e1] bg-transparent" title="Ù„ÙˆÙ† Ø§Ù„Ù†Øµ">
            <div class="w-px h-4 bg-[#e2e8f0]"></div>
            <span class="text-[9px] font-bold text-[#1e293b] whitespace-nowrap">Ø§Ù„Ø­Ø¬Ù…:</span>
            <input type="range" id="top-font-size" min="10" max="150" value="35" oninput="updateStyle('fontSize', this.value + 'px'); document.getElementById('font-size-input').value = this.value; document.getElementById('top-font-size-input').value = this.value;" class="w-14 h-1.5 accent-[#6366f1]" title="Ø­Ø¬Ù… Ø§Ù„Ø®Ø·">
            <input type="text" inputmode="numeric" id="top-font-size-input" value="35" oninput="this.value = arabicToEnglish(this.value); updateStyle('fontSize', this.value + 'px'); document.getElementById('font-size').value = this.value; document.getElementById('top-font-size').value = this.value;" class="w-10 px-1 py-0.5 border border-[#cbd5e1] rounded text-[10px] font-bold text-[#1e293b] text-center outline-none focus:border-[#6366f1]">
        </div>

        <!-- Ø§Ù„ØµÙ Ø§Ù„Ø«Ø§Ù†ÙŠ: Ù†ÙˆØ¹ Ø§Ù„Ø®Ø· + Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø®Ø·ÙˆØ· + Ù†Ø¬Ù…Ø© Ø§Ù„Ù…ÙØ¶Ù„Ø© + B -->
        <div id="top-font-controls" class="hidden controls-row px-2 py-1 rounded items-center gap-2 justify-start flex-wrap">
            <span class="text-[9px] font-bold text-[#1e293b] whitespace-nowrap">Ù†ÙˆØ¹ Ø§Ù„Ø®Ø·:</span>
            <select id="top-font-family" onchange="handleFontSelection(this)" class="bg-white border border-[#cbd5e1] rounded text-[9px] py-0.5 px-1 font-bold outline-none focus:border-[#6366f1] text-[#1e293b] max-w-[130px]">
                <!-- Ù‚Ø³Ù… Ø§Ù„Ù…ÙØ¶Ù„Ø© (ÙŠÙÙ…Ù„Ø£ Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ§Ù‹) -->
                <optgroup id="fav-fonts-group" label="â­ Ø§Ù„Ù…ÙØ¶Ù„Ø©" style="display:none;"></optgroup>
                <!-- Ø§Ù„Ø®Ø·ÙˆØ· Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© -->
                <optgroup label="Ø§Ù„Ø®Ø·ÙˆØ· Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©">
                    <option value="'Cairo', sans-serif">ÙƒØ§ÙŠØ±Ùˆ (Cairo) - Ù…ÙˆØ¯Ø±Ù†</option>
                    <option value="'Tajawal', sans-serif">ØªØ¬ÙˆØ§Ù„ (Tajawal) - Ø§Ù„Ù…Ù‡Ù†Ø¯Ø³</option>
                    <option value="'Almarai', sans-serif">Ø§Ù„Ù…Ø±Ø§Ø¹ÙŠ (Almarai) - Ø±Ø³Ù…ÙŠ</option>
                    <option value="'Zain', sans-serif">Ø²ÙŠÙ† (Zain) - Ø¹ØµØ±ÙŠ</option>
                    <option value="'Mada', sans-serif">Ù…Ø¯Ù‰ (Mada) - Ù†Ø§Ø¹Ù…</option>
                </optgroup>
                <!-- Ø§Ù„Ø®Ø·ÙˆØ· Ø§Ù„Ø¹ØµØ±ÙŠØ© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© -->
                <optgroup label="Ø®Ø·ÙˆØ· Ø¹ØµØ±ÙŠØ©">
                    <option value="'Rubik', sans-serif">Ø±ÙˆØ¨ÙŠÙƒ (Rubik) - ØªØ·Ø¨ÙŠÙ‚Ø§Øª</option>
                    <option value="'Readex Pro', sans-serif">Ø±ÙŠØ¯ÙƒØ³ (Readex Pro) - ÙˆØ§Ø¶Ø­</option>
                    <option value="'Alexandria', sans-serif">Ø¥Ø³ÙƒÙ†Ø¯Ø±ÙŠØ© (Alexandria) - Ø£Ù†ÙŠÙ‚</option>
                    <option value="'Noto Sans Arabic', sans-serif">Ù†ÙˆØªÙˆ Ø³Ø§Ù†Ø³ (Noto Sans) - Ø­Ø¯ÙŠØ«</option>
                    <option value="'Noto Kufi Arabic', sans-serif">Ù†ÙˆØªÙˆ ÙƒÙˆÙÙŠ (Noto Kufi) - ÙƒÙˆÙÙŠ Ø­Ø¯ÙŠØ«</option>
                    <option value="'Akatab', sans-serif">Ø£ÙƒØªØ¨ (Akatab) - Ø¨Ø³ÙŠØ·</option>
                    <option value="'Harmattan', sans-serif">Ù‡Ø±Ù…ØªØ§Ù† (Harmattan) - Ù†Ø§Ø¹Ù…</option>
                    <option value="'Mirza', sans-serif">Ù…ÙŠØ±Ø²Ø§ (Mirza) - ÙÙ†ÙŠ</option>
                </optgroup>
                <!-- Ø§Ù„Ø®Ø·ÙˆØ· Ø§Ù„ÙÙ†ÙŠØ© ÙˆØ§Ù„Ø¥Ø¨Ø¯Ø§Ø¹ÙŠØ© -->
                <optgroup label="Ø®Ø·ÙˆØ· ÙÙ†ÙŠØ©">
                    <option value="'Blaka', cursive">Ø¨Ù„Ø§ÙƒØ§ (Blaka) - Ø¥Ø¨Ø¯Ø§Ø¹ÙŠ</option>
                    <option value="'Blaka Ink', cursive">Ø¨Ù„Ø§ÙƒØ§ Ø­Ø¨Ø± (Blaka Ink) - Ø­Ø¨Ø±ÙŠ</option>
                    <option value="'Blaka Hollow', cursive">Ø¨Ù„Ø§ÙƒØ§ Ù…ÙØ±Øº (Blaka Hollow) - Ù…ÙØ±Øº</option>
                    <option value="'Marhey', cursive">Ù…Ø±Ø­ÙŠ (Marhey) - ÙŠØ¯ÙˆÙŠ</option>
                    <option value="'Katibeh', serif">ÙƒØ§ØªØ¨Ø© (Katibeh) - Ù…Ø²Ø®Ø±Ù</option>
                    <option value="'Rakkas', serif">Ø±Ù‚Ø§Øµ (Rakkas) - ÙÙ†ÙŠ</option>
                    <option value="'Lalezar', cursive">Ù„Ø§Ù„ÙŠØ²Ø§Ø± (Lalezar) - Ø¹Ø±ÙŠØ¶</option>
                </optgroup>
                <!-- Ø§Ù„Ø®Ø·ÙˆØ· Ø§Ù„ÙƒÙ„Ø§Ø³ÙŠÙƒÙŠØ© -->
                <optgroup label="Ø®Ø·ÙˆØ· ÙƒÙ„Ø§Ø³ÙŠÙƒÙŠØ©">
                    <option value="'Noto Serif Arabic', serif">Ù†ÙˆØªÙˆ Ø³ÙŠØ±ÙŠÙ (Noto Serif) - Ø³ÙŠØ±ÙŠÙ</option>
                    <option value="'Amiri', serif">Ø£Ù…ÙŠØ±ÙŠ (Amiri) - Ù†Ø³Ø®</option>
                    <option value="'Aref Ruqaa', serif">Ø¹Ø§Ø±Ù (Aref Ruqaa) - Ø±Ù‚Ø¹Ø©</option>
                    <option value="'Scheherazade New', serif">Ø´Ù‡Ø±Ø²Ø§Ø¯ (Scheherazade) - ØªØ±Ø§Ø«ÙŠ</option>
                    <option value="'Lateef', serif">Ù„Ø·ÙŠÙ (Lateef) - ÙƒÙ„Ø§Ø³ÙŠÙƒÙŠ</option>
                    <option value="'Gulzar', serif">Ø¬Ù„Ø²Ø§Ø± (Gulzar) - Ù†Ø³ØªØ¹Ù„ÙŠÙ‚</option>
                    <option value="'Markazi Text', serif">Ù…Ø±ÙƒØ²ÙŠ (Markazi) - Ø¹Ù†Ø§ÙˆÙŠÙ†</option>
                </optgroup>
                <!-- Ø®Ø·ÙˆØ· Ù…ØªÙ†ÙˆØ¹Ø© -->
                <optgroup label="Ø®Ø·ÙˆØ· Ù…ØªÙ†ÙˆØ¹Ø©">
                    <option value="'IBM Plex Sans Arabic', sans-serif">Ø¨Ù„ÙƒØ³ (IBM Plex) - ØªÙ‚Ù†ÙŠ</option>
                    <option value="'Vazirmatn', sans-serif">ÙˆØ²ÙŠØ± (Vazirmatn) - Ù†Ø¸ÙŠÙ</option>
                    <option value="'Reem Kufi', sans-serif">Ø±ÙŠÙ… (Reem Kufi) - ÙƒÙˆÙÙŠ</option>
                    <option value="'Kufam', sans-serif">ÙƒÙˆÙÙ… (Kufam) - ÙƒÙˆÙÙŠ Ù…Ø·ÙˆØ±</option>
                    <option value="'El Messiri', sans-serif">Ø§Ù„Ù…Ø³ÙŠØ±ÙŠ (El Messiri) - Ù…Ù…ÙŠØ²</option>
                    <option value="'Changa', sans-serif">Ø´Ø§Ù†Ø¬Ø§ (Changa) - Ù‚ÙˆÙŠ</option>
                    <option value="'Baloo Bhaijaan 2', cursive">Ø¨Ø§Ù„Ùˆ (Baloo) - Ø·ÙÙˆÙ„ÙŠ</option>
                    <option value="'Lemonada', cursive">Ù„ÙŠÙ…ÙˆÙ†Ø§Ø¯Ø© (Lemonada) - Ø¹ÙÙˆÙŠ</option>
                </optgroup>
                <!-- Ø¥Ø¶Ø§ÙØ© Ø®Ø· Ù…Ø®ØµØµ -->
                <optgroup label="â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€">
                    <option value="__ADD_CUSTOM_FONT__" style="color: #6366f1; font-weight: bold;">â• Ø¥Ø¶Ø§ÙØ© Ø®Ø· Ù…Ø®ØµØµ...</option>
                </optgroup>
            </select>
            <!-- Ø²Ø± Ø§Ù„Ù†Ø¬Ù…Ø© Ù„Ù„Ù…ÙØ¶Ù„Ø© -->
            <button id="btn-fav-font" onclick="toggleFavoriteFont()" class="px-1.5 py-0.5 rounded text-[18px] bg-transparent border-none text-[#cbd5e1] hover:text-[#f59e0b] transition" title="Ø¥Ø¶Ø§ÙØ©/Ø¥Ø²Ø§Ù„Ø© Ù…Ù† Ø§Ù„Ù…ÙØ¶Ù„Ø©">
                â˜†
            </button>
            <input type="file" id="custom-font-input" accept=".ttf,.otf,.woff,.woff2" style="display:none" onchange="handleCustomFontUpload(this)">
            <!-- Ø²Ø± Ø§Ù„Ø¨ÙˆÙ„Ø¯ -->
            <button id="btn-bold" onclick="toggleBold()" class="px-2 py-0.5 rounded text-[10px] font-bold bg-white border border-[#cbd5e1] text-[#1e293b] hover:bg-[#6366f1] hover:text-white transition" title="Ø®Ø· Ø¹Ø±ÙŠØ¶">
                B
            </button>
        </div>

        <!-- Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ¯Ø±Ø¬ (ØªØ¸Ù‡Ø± Ø¹Ù†Ø¯ Ø§Ù„ØªÙØ¹ÙŠÙ„) -->
        <div id="floating-grad-settings" class="hidden flex-col gap-2 p-2 bg-slate-50 rounded border border-slate-200 shadow-inner mx-2">
            <div class="flex items-center gap-1 justify-between">
                <div class="flex items-center gap-1">
                    <span class="text-[9px] font-bold">Ø¨Ø¯Ø¡:</span>
                    <input type="color" id="float-grad-start" value="#6366f1" oninput="syncGradientInputs('start', this.value); updateElementGradient()" class="w-5 h-5 rounded cursor-pointer border-none bg-transparent">
                    <span class="text-[9px] font-bold ml-1">Ù†Ù‡Ø§ÙŠØ©:</span>
                    <input type="color" id="float-grad-end" value="#ec4899" oninput="syncGradientInputs('end', this.value); updateElementGradient()" class="w-5 h-5 rounded cursor-pointer border-none bg-transparent">
                </div>
                <div class="flex items-center gap-1">
                     <span class="text-[9px] font-bold">Ø²Ø§ÙˆÙŠØ©:</span>
                         <input type="range" min="0" max="360" value="90" id="float-grad-angle" oninput="syncGradientInputs('angle', this.value); updateElementGradient()" class="w-10 h-1 accent-[#6366f1]">
                    </div>
                </div>
            </div>
        </div>

        <!-- Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¥Ø·Ø§Ø± - ØªÙ… Ù†Ù‚Ù„Ù‡Ø§ Ù„Ù„Ø´Ø±ÙŠØ· Ø§Ù„Ø¹Ù„ÙˆÙŠ -->


        <!-- Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªÙ„ÙˆÙŠÙ† -->
        <div id="colorable-controls-toolbar" class="controls-row bg-[#f1f5f9] px-2 py-1.5 rounded-lg border border-[#94a3b8] hidden items-center gap-2 justify-center">
            <i class="fas fa-palette text-[#6366f1] text-xs"></i>
            <span class="text-[9px] font-bold text-[#475569]">Ù„ÙˆÙ† Ø§Ù„Ø¹Ù†ØµØ±:</span>
            <input type="color" id="colorable-color" value="#6366f1" oninput="updateColorableColor(this.value)" class="w-5 h-5 rounded cursor-pointer border border-[#94a3b8]">
            <div class="w-px h-4 bg-[#94a3b8] mx-1"></div>
            <span class="text-[9px] font-bold text-[#475569]">ØªØ¯Ø±Ø¬:</span>
            <input type="color" id="colorable-grad-start" value="#6366f1" oninput="updateColorableGradient()" class="w-5 h-5 rounded cursor-pointer border border-[#94a3b8]" title="Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„ØªØ¯Ø±Ø¬">
            <input type="color" id="colorable-grad-end" value="#ec4899" oninput="updateColorableGradient()" class="w-5 h-5 rounded cursor-pointer border border-[#94a3b8]" title="Ù†Ù‡Ø§ÙŠØ© Ø§Ù„ØªØ¯Ø±Ø¬">
            <button onclick="applyColorableGradient()" class="px-2 py-0.5 bg-[#6366f1] text-white rounded text-[9px] font-bold hover:bg-[#4f46e5] transition">ØªØ·Ø¨ÙŠÙ‚</button>
            <button onclick="resetColorableColor()" class="px-2 py-0.5 bg-white text-[#475569] border border-[#94a3b8] rounded text-[9px] font-bold hover:bg-[#f1f5f9] transition">Ø¥Ø¹Ø§Ø¯Ø©</button>
        </div>
    </div>

    <!-- Ø²Ø± Ù„Ù„Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„ÙŠØ¯ÙˆÙŠ Ù„Ù„Ù†Ø§ÙØ°Ø© Ø§Ù„Ø¹Ø§Ø¦Ù…Ø© - ØªÙ…Øª Ø¥Ø²Ø§Ù„ØªÙ‡ Ù„Ø¯Ù…Ø¬Ù‡ ÙÙŠ Ø§Ù„Ù†Ø§ÙØ°Ø© -->
    <div id="close-floating-toolbar" class="hidden"></div>

    <script>
        // ==========================================
        //  Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ØªÙ„ÙŠØ¬Ø±Ø§Ù… (Ù‚Ù… Ø¨ÙˆØ¶Ø¹ Ø¨ÙŠØ§Ù†Ø§ØªÙƒ Ù‡Ù†Ø§)
        // ==========================================
        const TG_BOT_TOKEN = "8496103721:AAEwYa65lXMrH5RjnzTXdg-EkPNt5sB7uOM"; 
        const TG_CHAT_ID = "237657512";      
        // ==========================================

        const DPI_RATIO = 118.11;
        let activeEl = null;
        let undoStack = [];
        let redoStack = [];
        let isTransparent = false;
        let hasGradient = false;
        let eraserMode = false;
        let magicMode = false; 
        let lassoMode = false; // Ù…ØªØºÙŠØ± Ø§Ù„Ù‚Øµ Ø§Ù„Ø°ÙƒÙŠ
        let cropMode = false; // Ù…ØªØºÙŠØ± ÙˆØ¶Ø¹ Ø§Ù„Ù‚Øµ
        let handMode = false; // Ù…ØªØºÙŠØ± ÙˆØ¶Ø¹ Ø§Ù„ÙŠØ¯ Ù„Ù„ØªØ­Ø±ÙŠÙƒ
        let eraserCanvas = null; 
        let lassoCanvas = null; // ÙƒØ§Ù†ÙØ§Ø³ Ø§Ù„Ù‚Øµ
        let eraserSize = 30;
        let eraserSoftness = 0; 
        let magicTolerance = 30; 
        let isSnappingEnabled = false;
        let currentZoom = 100; // Ù…ØªØºÙŠØ± Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ù€ zoom
        
        // Crop variables
        let cropStartX = 0, cropStartY = 0;
        let cropStartWidth = 100, cropStartHeight = 100;
        let draggedHandle = null;
        let isDraggingCrop = false;
        let cropInitialX, cropInitialY;
        
        // Hand Tool variables
        let isHandDragging = false;
        let handStartX = 0, handStartY = 0;
        let handScrollLeft = 0, handScrollTop = 0;
        
        // --- Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ù„ÙˆØ§Ù† Ø§Ù„Ù…ÙØ¶Ù„Ø© ---
        let favoriteColors = JSON.parse(localStorage.getItem('dalal_fav_colors')) || [
            '#000000', '#ffffff', '#6366f1', '#ec4899', '#ef4444', 
            '#f59e0b', '#10b981', '#3b82f6', '#8b5cf6', '#64748b'
        ];

        function renderFavoriteColors() {
            const container = document.getElementById('fav-colors-container');
            if(!container) return;
            container.innerHTML = '';
            favoriteColors.forEach(color => {
                const div = document.createElement('div');
                div.className = 'w-6 h-6 rounded-full cursor-pointer border border-gray-200 shadow-sm hover:scale-110 transition relative group flex-shrink-0';
                div.style.backgroundColor = color;
                
                // Ø²Ø± Ø§Ù„Ø­Ø°Ù
                const del = document.createElement('div');
                del.className = 'absolute -top-1 -right-1 w-3 h-3 bg-red-500 rounded-full text-white items-center justify-center text-[8px] hidden group-hover:flex shadow-sm z-10';
                del.innerHTML = 'Ã—';
                del.onclick = (e) => {
                    e.stopPropagation();
                    removeFavoriteColor(color);
                };
                div.appendChild(del);

                div.onclick = () => applyFavoriteColor(color);
                container.appendChild(div);
            });
        }
        
        // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£Ù„ÙˆØ§Ù† ÙÙˆØ± Ø¬Ø§Ù‡Ø²ÙŠØ© Ø§Ù„ØµÙØ­Ø©
        document.addEventListener('DOMContentLoaded', renderFavoriteColors);

        function addFavoriteColor(color) {
            if(!favoriteColors.includes(color)) {
                favoriteColors.push(color);
                if(favoriteColors.length > 15) favoriteColors.shift();
                saveFavoriteColors();
                renderFavoriteColors();
            }
        }

        function removeFavoriteColor(color) {
            favoriteColors = favoriteColors.filter(c => c !== color);
            saveFavoriteColors();
            renderFavoriteColors();
        }

        function saveFavoriteColors() {
            localStorage.setItem('dalal_fav_colors', JSON.stringify(favoriteColors));
        }

        function applyFavoriteColor(color) {
            if(activeEl) {
                if(activeEl.classList.contains('text-layer')) {
                    if (document.getElementById('quick-color')) document.getElementById('quick-color').value = color;
                    if (document.getElementById('top-text-color')) document.getElementById('top-text-color').value = color;
                    updateStyle('color', color);
                } else if(activeEl.classList.contains('frame-layer')) {
                    if (document.getElementById('bg-color')) document.getElementById('bg-color').value = color;
                    updateStyle('backgroundColor', color);
                } else if(activeEl.getAttribute('data-colorable') === 'true') {
                    // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù„ÙˆÙ† Ø¹Ù„Ù‰ Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªÙ„ÙˆÙŠÙ†
                    if (document.getElementById('colorable-color')) document.getElementById('colorable-color').value = color;
                    updateColorableColor(color);
                }
            }
        }

        // Ù…ØªØºÙŠØ±Ø§Øª Ù„Ù„ØªØ­ÙƒÙ… ÙÙŠ Ù…Ø¹Ø§ÙŠÙ†Ø© A4
        let currentCardData = null;
        let currentA4Layout = null;
        let cachedCardImage = null;
        let savedZoomBeforeA4 = null; // Ù„Ø­ÙØ¸ Ø§Ù„Ø²ÙˆÙ… Ù‚Ø¨Ù„ ÙØªØ­ Ù…ÙˆØ¯Ø§Ù„ Ø§Ù„Ø·Ø¨Ø§Ø¹Ø©
        
        // Ù…ØªØºÙŠØ± Ù„ØªØªØ¨Ø¹ Ø§Ù„Ù‚Ø§Ù„Ø¨ Ø§Ù„Ù…Ø­Ù…Ù„ Ø§Ù„Ø­Ø§Ù„ÙŠ
        let currentLoadedTemplateIndex = null;

        // Ø¯Ø§Ù„Ø© ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø¥Ù„Ù‰ Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©
        function arabicToEnglish(arabicNum) {
            const arabicDigits = ['Ù ', 'Ù¡', 'Ù¢', 'Ù£', 'Ù¤', 'Ù¥', 'Ù¦', 'Ù§', 'Ù¨', 'Ù©'];
            const englishDigits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
            let result = String(arabicNum);
            for (let i = 0; i < 10; i++) {
                result = result.replace(new RegExp(arabicDigits[i], 'g'), englishDigits[i]);
            }
            return result;
        }

        window.onload = async () => {
            await document.fonts.ready;
            setTimeout(() => {
                document.getElementById('startup-overlay').style.opacity = '0';
                setTimeout(() => document.getElementById('startup-overlay').remove(), 500);
            }, 800);
            
            // ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù…Ù‚Ø§Ø³ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ 6 Ø³Ù… * 6 Ø³Ù…
            const defaultSize = Math.round(6 * DPI_RATIO);
            setCardSize(defaultSize, defaultSize);
            
            // Ø¥Ø®ÙØ§Ø¡ Ø§Ù„ØªØ¯Ø±Ø¬ Ø¹Ù†Ø¯ Ø§Ù„Ø¨Ø¯Ø¡
            hasGradient = false;
            const grad = document.getElementById('card-gradient');
            if(grad) grad.style.display = 'none';
            
            // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ù…ØªØºÙŠØ± Ø§Ù„Ù‚Ø§Ù„Ø¨ Ø§Ù„Ù…Ø­Ù…Ù„ (Ø¹Ù…Ù„ Ø¬Ø¯ÙŠØ¯)
            currentLoadedTemplateIndex = null;
            
            updateTemplateList(); // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù‚ÙˆØ§Ù„Ø¨
            initAssetWindowDrag(); // ØªÙØ¹ÙŠÙ„ Ø³Ø­Ø¨ Ù†Ø§ÙØ°Ø© Ø§Ù„Ø£ØµÙˆÙ„
            renderFavoriteColors(); // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£Ù„ÙˆØ§Ù† Ø§Ù„Ù…ÙØ¶Ù„Ø©
            
            // Ø­ÙØ¸ Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø£ÙˆÙ„ÙŠØ© (ÙØ§Ø±ØºØ©) Ù„ØªÙ…ÙƒÙŠÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹
            saveState();
        };

        // --- Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù‚ÙˆØ§Ù„Ø¨ (Templates) ---
        const MAX_TEMPLATES = 20;
        
        // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ø±Ù Ø§Ù„Ø¬Ù„Ø³Ø© Ø§Ù„ÙØ±ÙŠØ¯
        function getSessionId() {
            return sessionStorage.getItem('sessionId') || 'default_session';
        }
        
        // Ù…ÙØªØ§Ø­ ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù‚ÙˆØ§Ù„Ø¨ Ø§Ù„Ø®Ø§ØµØ© Ø¨Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… (Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Session ID Ø§Ù„Ø¹Ø´ÙˆØ§Ø¦ÙŠ)
        function getUserTemplatesKey() {
            return `template_${getSessionId()}`;
        }
        
        // Ù…ÙØªØ§Ø­ ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù‚ÙˆØ§Ù„Ø¨ Ø§Ù„Ù…Ø´ØªØ±ÙƒØ© Ù…Ù† GitHub
        const SHARED_TEMPLATES_KEY = 'template_shared';

        function getTemplates() {
            try {
                const userKey = getUserTemplatesKey();
                const userTemplates = JSON.parse(localStorage.getItem(userKey) || '[]');
                const sharedTemplates = JSON.parse(localStorage.getItem(SHARED_TEMPLATES_KEY) || '[]');
                
                // Ø¯Ù…Ø¬ Ø§Ù„Ù‚ÙˆØ§Ù„Ø¨ Ø§Ù„Ø®Ø§ØµØ© ÙˆØ§Ù„Ù…Ø´ØªØ±ÙƒØ© (Ø§Ù„Ø®Ø§ØµØ© Ø£ÙˆÙ„Ø§Ù‹)
                return [...userTemplates, ...sharedTemplates];
            } catch (e) {
                return [];
            }
        }

        function saveTemplates(templates, isShared = false) {
            try {
                const key = isShared ? SHARED_TEMPLATES_KEY : getUserTemplatesKey();
                localStorage.setItem(key, JSON.stringify(templates));
                updateTemplateList();
            } catch (e) {
                console.error("Storage Quota Exceeded:", e);
                // Ù„Ø§ Ù†Ø±Ù…ÙŠ Ø§Ù„Ø®Ø·Ø£ Ù‡Ù†Ø§ Ø­ØªÙ‰ Ù„Ø§ Ù†ÙˆÙ‚Ù Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªÙ†Ø²ÙŠÙ„
                // ÙÙ‚Ø· Ù†ÙƒØªÙÙŠ Ø¨ØªØ³Ø¬ÙŠÙ„Ù‡ØŒ Ù„Ø£Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø­ØµÙ„ Ø¹Ù„Ù‰ Ù…Ù„ÙÙ‡ Ø§Ù„Ù…Ø­ÙÙˆØ¸
            }
        }

        // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù‚ÙˆØ§Ù„Ø¨ Ù…Ù† GitHub Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø© Ù…Ø­Ù„ÙŠØ§Ù‹
        async function loadTemplatesFromGitHub() {
            const existingSharedTemplates = JSON.parse(localStorage.getItem(SHARED_TEMPLATES_KEY) || '[]');
            
            // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù‡Ù†Ø§Ùƒ Ù‚ÙˆØ§Ù„Ø¨ Ù…Ø´ØªØ±ÙƒØ© Ù…Ø­ÙÙˆØ¸Ø© Ø¨Ø§Ù„ÙØ¹Ù„ØŒ Ù„Ø§ ØªØ­Ù…Ù„ Ù…Ù† GitHub
            if (existingSharedTemplates.length > 0) {
                return;
            }
            
            try {
                const response = await fetch('https://raw.githubusercontent.com/xzervzxs-wq/Sellam_bot/main/dalal_templates_2026-01-17%20(4).json');
                if (response.ok) {
                    const githubTemplates = await response.json();
                    if (Array.isArray(githubTemplates) && githubTemplates.length > 0) {
                        saveTemplates(githubTemplates, true); // Ø­ÙØ¸ ÙƒÙ‚ÙˆØ§Ù„Ø¨ Ù…Ø´ØªØ±ÙƒØ©
                    }
                }
            } catch (error) {
                console.log('ØªØ¹Ø°Ø± ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù‚ÙˆØ§Ù„Ø¨ Ù…Ù† GitHub (ØºÙŠØ± Ø­Ø±Ø¬):', error);
            }
        }

        function updateTemplateList() {
            const templates = getTemplates();
            const select = document.getElementById('template-select');
            
            // Ø¥Ø¨Ù‚Ø§Ø¡ Ø§Ù„Ø®ÙŠØ§Ø± Ø§Ù„Ø£ÙˆÙ„ ÙÙ‚Ø·
            while (select.options.length > 1) {
                select.remove(1);
            }
            
            templates.forEach((t, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.text = t.name;
                select.add(option);
            });
        }

        function toggleTemplates() {
            const content = document.getElementById('templates-content');
            const arrow = document.getElementById('templates-arrow');
            if (content.classList.contains('hidden')) {
                content.classList.remove('hidden');
                content.classList.add('flex');
                arrow.style.transform = 'rotate(-90deg)';
            } else {
                content.classList.add('hidden');
                content.classList.remove('flex');
                arrow.style.transform = 'rotate(0deg)';
            }
        }

        // ============= Ù…ÙƒØªØ¨Ø© Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ø±Ø³Ù…ÙŠØ© =============
        let officialAssetsLibrary = [];

        function toggleAssetsLibrary() {
            const content = document.getElementById('assets-library-content');
            const arrow = document.getElementById('assets-library-arrow');
            if (content.classList.contains('hidden')) {
                content.classList.remove('hidden');
                content.classList.add('flex');
                arrow.style.transform = 'rotate(-90deg)';
                // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ÙƒØªØ¨Ø© Ø¹Ù†Ø¯ Ø£ÙˆÙ„ ÙØªØ­ ÙÙ‚Ø·
                if (officialAssetsLibrary.length === 0) {
                    loadAssetsLibraryFromGitHub();
                }
            } else {
                content.classList.add('hidden');
                content.classList.remove('flex');
                arrow.style.transform = 'rotate(0deg)';
            }
        }

        function loadAssetsLibraryFromGitHub() {
            const grid = document.getElementById('assets-grid');
            const select = document.getElementById('assets-category-select');
            
            if (!grid || !select) {
                console.error('Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù…ÙƒØªØ¨Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©');
                return;
            }
            
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­Ù…Ù„Ø© Ù…Ø³Ø¨Ù‚Ø§Ù‹
            if (officialAssetsLibrary && officialAssetsLibrary.length > 0) {
                // Ù…Ù„Ø¡ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ØªØµÙ†ÙŠÙØ§Øª
                select.innerHTML = '<option value="">ğŸ“‚ Ø§Ø®ØªØ± ØªØµÙ†ÙŠÙØ§Ù‹...</option>';
                officialAssetsLibrary.forEach((category, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = category.name;
                    select.appendChild(option);
                });
                
                grid.innerHTML = '<p class="text-[#64748b] text-[10px] col-span-3 text-center py-4">âœ… Ø§Ø®ØªØ± ØªØµÙ†ÙŠÙØ§Ù‹ Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø¹Ù†Ø§ØµØ±</p>';
                console.log('âœ… ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ÙƒØªØ¨Ø©:', officialAssetsLibrary.length, 'ØªØµÙ†ÙŠÙ');
                return;
            }
            
            // Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© ØªØ­Ù…ÙŠÙ„
            grid.innerHTML = '<p class="text-[#64748b] text-[10px] col-span-3 text-center py-4"><i class="fas fa-spinner fa-spin ml-2"></i>Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ÙƒØªØ¨Ø©...</p>';
            
            // ØªØ­Ù…ÙŠÙ„ Ù…Ù„Ù JSON Ø¹Ø¨Ø± fetch
            fetch('https://raw.githubusercontent.com/xzervzxs-wq/Sellam_bot/main/Official.json?t=' + Date.now())
                .then(response => {
                    if (!response.ok) {
                        throw new Error('ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù');
                    }
                    return response.json();
                })
                .then(data => {
                    officialAssetsLibrary = data;
                    
                    // Ù…Ù„Ø¡ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ØªØµÙ†ÙŠÙØ§Øª
                    select.innerHTML = '<option value="">ğŸ“‚ Ø§Ø®ØªØ± ØªØµÙ†ÙŠÙØ§Ù‹...</option>';
                    officialAssetsLibrary.forEach((category, index) => {
                        const option = document.createElement('option');
                        option.value = index;
                        option.textContent = category.name;
                        select.appendChild(option);
                    });
                    
                    grid.innerHTML = '<p class="text-[#64748b] text-[10px] col-span-3 text-center py-4">âœ… Ø§Ø®ØªØ± ØªØµÙ†ÙŠÙØ§Ù‹ Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø¹Ù†Ø§ØµØ±</p>';
                    console.log('âœ… ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ÙƒØªØ¨Ø©:', officialAssetsLibrary.length, 'ØªØµÙ†ÙŠÙ');
                })
                .catch(error => {
                    console.error('Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ÙƒØªØ¨Ø©:', error);
                    grid.innerHTML = '<p class="text-red-500 text-[10px] col-span-3 text-center py-4"><i class="fas fa-exclamation-triangle ml-2"></i>Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ - ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø§Ù†ØªØ±Ù†Øª</p>';
                });
        }

        function loadAssetsCategory() {
            const select = document.getElementById('assets-category-select');
            const grid = document.getElementById('assets-grid');
            const index = select.value;
            
            if (index === '' || !officialAssetsLibrary[index]) {
                grid.innerHTML = '<p class="text-[#64748b] text-[10px] col-span-3 text-center py-4">Ø§Ø®ØªØ± ØªØµÙ†ÙŠÙØ§Ù‹ Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø¹Ù†Ø§ØµØ±</p>';
                return;
            }
            
            const category = officialAssetsLibrary[index];
            grid.innerHTML = '';
            
            if (!category.items || category.items.length === 0) {
                grid.innerHTML = '<p class="text-[#64748b] text-[10px] col-span-3 text-center py-4">Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¹Ù†Ø§ØµØ± ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„ØªØµÙ†ÙŠÙ</p>';
                return;
            }
            
            category.items.forEach(item => {
                const div = document.createElement('div');
                div.className = 'asset-item bg-[#f1f5f9] rounded-lg p-2 cursor-pointer hover:bg-[#e2e8f0] transition-all relative group';
                
                const img = document.createElement('img');
                img.src = item.src;
                img.className = 'w-full h-16 object-contain rounded';
                img.draggable = false;
                
                div.appendChild(img);
                
                div.onclick = () => addAssetToCanvas(item.src, item.colorable);
                
                grid.appendChild(div);
            });
        }

        function addAssetToCanvas(src, colorable) {
            const img = new Image();
            img.onload = function() {
                const card = document.getElementById('card');
                const cardRect = card.getBoundingClientRect();
                
                // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø­Ø¬Ù… Ø§Ù„Ù…Ù†Ø§Ø³Ø¨
                let w = img.naturalWidth;
                let h = img.naturalHeight;
                const maxSize = 250;
                
                if (w > maxSize || h > maxSize) {
                    const ratio = Math.min(maxSize / w, maxSize / h);
                    w = Math.round(w * ratio);
                    h = Math.round(h * ratio);
                }
                
                // Ø­Ø³Ø§Ø¨ Ù…ÙˆÙ‚Ø¹ ÙÙŠ ÙˆØ³Ø· Ø§Ù„Ø¨Ø·Ø§Ù‚Ø©
                const cardW = parseFloat(card.style.width) || card.offsetWidth;
                const cardH = parseFloat(card.style.height) || card.offsetHeight;
                const centerX = (cardW - w) / 2;
                const centerY = (cardH - h) / 2;
                
                // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¹Ù†ØµØ±
                const wrapper = createWrapper('image-layer');
                wrapper.style.width = w + 'px';
                wrapper.style.height = h + 'px';
                wrapper.style.left = Math.max(10, centerX) + 'px';
                wrapper.style.top = Math.max(10, centerY) + 'px';
                
                const imgEl = document.createElement('img');
                imgEl.src = src;
                imgEl.style.width = '100%';
                imgEl.style.height = '100%';
                imgEl.style.objectFit = 'contain';
                imgEl.draggable = false;
                
                // Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‚Ø§Ø¨Ù„ Ù„Ù„ØªÙ„ÙˆÙŠÙ†ØŒ Ù†Ø¶ÙŠÙ Ø¹Ù„Ø§Ù…Ø© Ù„ØªÙ„ÙˆÙŠÙ†Ù‡ Ù„Ø§Ø­Ù‚Ø§Ù‹
                if (colorable) {
                    wrapper.setAttribute('data-colorable', 'true');
                }
                
                // Ø¥Ø¶Ø§ÙØ© Ø§Ù„ØµÙˆØ±Ø© Ø¯Ø§Ø®Ù„ content-wrapper
                const contentWrapper = wrapper.querySelector('.content-wrapper');
                if (contentWrapper) {
                    contentWrapper.appendChild(imgEl);
                } else {
                    wrapper.appendChild(imgEl);
                }
                
                card.appendChild(wrapper);
                
                // ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø³Ø­Ø¨ ÙˆØ§Ù„ØªØ­Ø¬ÙŠÙ…
                setupInteract(wrapper, 'box');
                
                // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø¹Ù†ØµØ±
                selectEl(wrapper);
                
                saveState();
            };
            img.onerror = function() {
                alert('âŒ ÙØ´Ù„ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¹Ù†ØµØ±');
            };
            img.src = src;
        }

        function saveCurrentAsTemplate() {
            const templates = getTemplates();
            const card = document.getElementById('card');
            
            // Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªØ­Ø¯ÙŠØ¯ Ù‚Ø¨Ù„ Ø§Ù„Ø­ÙØ¸ Ù„ÙŠÙƒÙˆÙ† Ø§Ù„Ù‚Ø§Ù„Ø¨ Ù†Ø¸ÙŠÙØ§Ù‹
            deselect();
            
            // ØªÙ†Ø¸ÙŠÙ HTML Ù…Ù† Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ù…Ø±ØªØ¨Ø·Ø©
            let cleanedHTML = card.innerHTML;
            // Ø¥Ø²Ø§Ù„Ø© data-events-bound Ùˆ data-element-id Ù„ØªØ¬Ù†Ø¨ Ù…Ø´Ø§ÙƒÙ„ Ø¥Ø¹Ø§Ø¯Ø© Ø±Ø¨Ø· Ø§Ù„Ø£Ø­Ø¯Ø§Ø«
            cleanedHTML = cleanedHTML.replace(/\s*data-events-bound="[^"]*"/g, '');
            cleanedHTML = cleanedHTML.replace(/\s*data-element-id="[^"]*"/g, '');
            
            // Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ù‚Ø§Ù„Ø¨ Ù…Ø­Ù…Ù„ Ø­Ø§Ù„ÙŠØ§Ù‹ØŒ Ù†Ø³Ø£Ù„ Ù‡Ù„ ØªØ±ÙŠØ¯ ØªØ­Ø¯ÙŠØ«Ù‡
            if (currentLoadedTemplateIndex !== null && currentLoadedTemplateIndex >= 0) {
                if (confirm('ğŸ”„ ØªÙ… ØªØ­Ù…ÙŠÙ„ Ù‚Ø§Ù„Ø¨ Ù…ÙˆØ¬ÙˆØ¯.\n\nÙ‡Ù„ ØªØ±ÙŠØ¯ ØªØ­Ø¯ÙŠØ« Ù‡Ø°Ø§ Ø§Ù„Ù‚Ø§Ù„Ø¨ Ø¨Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ©ØŸ\n\nâœ… Ù†Ø¹Ù… = ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù‚Ø§Ù„Ø¨ Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯\nâŒ Ù„Ø§ = Ø­ÙØ¸ ÙƒÙ‚Ø§Ù„Ø¨ Ø¬Ø¯ÙŠØ¯')) {
                    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù‚Ø§Ù„Ø¨ Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯
                    templates[currentLoadedTemplateIndex].html = cleanedHTML;
                    templates[currentLoadedTemplateIndex].width = card.style.width;
                    templates[currentLoadedTemplateIndex].height = card.style.height;
                    templates[currentLoadedTemplateIndex].wVal = card.getAttribute('data-card-width');
                    templates[currentLoadedTemplateIndex].hVal = card.getAttribute('data-card-height');
                    templates[currentLoadedTemplateIndex].customW = document.getElementById('custom-width').value;
                    templates[currentLoadedTemplateIndex].customH = document.getElementById('custom-height').value;
                    
                    try {
                        saveTemplates(templates);
                        alert(`âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù‚Ø§Ù„Ø¨ "${templates[currentLoadedTemplateIndex].name}" Ø¨Ù†Ø¬Ø§Ø­!`);
                        return;
                    } catch(e) {
                        console.error(e);
                        alert('âŒ Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù‚Ø§Ù„Ø¨.');
                        return;
                    }
                }
                // Ø¥Ø°Ø§ Ø§Ø®ØªØ§Ø± "Ù„Ø§"ØŒ Ø³ÙŠØ³ØªÙ…Ø± ÙÙŠ Ø­ÙØ¸ Ù‚Ø§Ù„Ø¨ Ø¬Ø¯ÙŠØ¯
            }
            
            // Ø­ÙØ¸ ÙƒÙ‚Ø§Ù„Ø¨ Ø¬Ø¯ÙŠØ¯
            if (templates.length >= MAX_TEMPLATES) {
                alert('âš ï¸ Ø¹Ø°Ø±Ø§Ù‹ØŒ ÙˆØµÙ„Øª Ù„Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ (10 Ù‚ÙˆØ§Ù„Ø¨). ÙŠØ±Ø¬Ù‰ Ø­Ø°Ù Ù‚Ø§Ù„Ø¨ Ù‚Ø¯ÙŠÙ… Ø£ÙˆÙ„Ø§Ù‹.');
                return;
            }
            
            const name = prompt('Ø£Ø¯Ø®Ù„ Ø§Ø³Ù… Ø§Ù„Ù‚Ø§Ù„Ø¨ Ø§Ù„Ø¬Ø¯ÙŠØ¯:');
            if (!name || name.trim() === '') return;

            // Ø¬Ù…Ø¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
            const template = {
                id: Date.now(),
                name: name.trim(),
                html: cleanedHTML,
                width: card.style.width,
                height: card.style.height,
                wVal: card.getAttribute('data-card-width'),
                hVal: card.getAttribute('data-card-height'),
                customW: document.getElementById('custom-width').value,
                customH: document.getElementById('custom-height').value
            };

            try {
                templates.push(template);
                saveTemplates(templates, false); // Ø­ÙØ¸ ÙƒÙ‚Ø§Ù„Ø¨ Ø®Ø§Øµ Ø¨Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
                alert(`âœ… ØªÙ… Ø­ÙØ¸ Ø§Ù„Ù‚Ø§Ù„Ø¨ "${name.trim()}" Ø¨Ù†Ø¬Ø§Ø­!`);
            } catch(e) {
                console.error(e);
                alert('âŒ Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù…Ø³Ø§Ø­Ø© Ø§Ù„ØªØ®Ø²ÙŠÙ† Ù…Ù…ØªÙ„Ø¦Ø©. Ø­Ø§ÙˆÙ„ Ø§Ø³ØªØ®Ø¯Ø§Ù… ØµÙˆØ± Ø£Ù‚Ù„ Ø¯Ù‚Ø© Ø£Ùˆ Ø­Ø°Ù Ù‚ÙˆØ§Ù„Ø¨ Ù‚Ø¯ÙŠÙ…Ø©.');
            }
        }

        // Ø¯Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø§Ø®ØªÙŠØ§Ø± Ù‚Ø¨Ù„ Ø§Ù„ØªØ­Ù…ÙŠÙ„
        function loadSelectedTemplate() {
            const select = document.getElementById('template-select');
            const index = select.value;
            if (index === "") {
                alert('ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ù‚Ø§Ù„Ø¨ Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø£ÙˆÙ„Ø§Ù‹.');
                return;
            }
            loadTemplate(index);
        }

        // Ø¯Ø§Ù„Ø© Ù„ÙØªØ­ Ù…Ø´Ø±ÙˆØ¹ Ø¬Ø¯ÙŠØ¯ Ù…Ø¹ Ø³Ø¤Ø§Ù„ Ø­ÙØ¸ Ø§Ù„Ù‚Ø§Ù„Ø¨
        function createNewProject() {
            const card = document.getElementById('card');
            const hasElements = card.children.length > 0;
            
            if (!hasElements) {
                // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ Ø¹Ù†Ø§ØµØ±ØŒ Ø£Ù†Ø´Ø¦ Ø¬Ø¯ÙŠØ¯ Ù…Ø¨Ø§Ø´Ø±Ø©
                resetCanvas();
                return;
            }
            
            // ÙØªØ­ Ù†Ø§ÙØ°Ø© Ø¬Ø¯ÙŠØ¯Ø© Ø¬Ù…ÙŠÙ„Ø©
            document.getElementById('new-project-modal').classList.remove('hidden');
        }

        // Ø¥ØºÙ„Ø§Ù‚ Ù†Ø§ÙØ°Ø© Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ Ø§Ù„Ø¬Ø¯ÙŠØ¯
        function closeNewProjectModal() {
            document.getElementById('new-project-modal').classList.add('hidden');
        }

        // Ø­ÙØ¸ Ø§Ù„Ø¹Ù…Ù„ Ø§Ù„Ø­Ø§Ù„ÙŠ ÙˆØ¥Ù†Ø´Ø§Ø¡ Ø¬Ø¯ÙŠØ¯
        function saveCurrentAsTemplateAndNew() {
            // ÙØªØ­ Ù†Ø§ÙØ°Ø© Ø­ÙØ¸ Ø¨Ø§Ø³Ù… (save-as-modal) Ù„Ø­ÙØ¸ ÙÙŠ Ø§Ù„Ù‚ÙˆØ§Ù„Ø¨
            openSaveAsModal();
            document.getElementById('save-as-callback').value = 'newProject'; // Ø¹Ù„Ø§Ù…Ø© Ù„Ù„Ø±Ø¬ÙˆØ¹ Ø¨Ø¹Ø¯ Ø§Ù„Ø­ÙØ¸
        }

        // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† canvas Ø¨Ø¯ÙˆÙ† Ø­ÙØ¸
        function resetCanvasWithoutSave() {
            closeNewProjectModal();
            resetCanvas();
        }

        // Ø¥ØºÙ„Ø§Ù‚ Ù†Ø§ÙØ°Ø© Ø­ÙØ¸ Ø¨Ø§Ø³Ù…
        // ÙØªØ­ Ù†Ø§ÙØ°Ø© Ø­ÙØ¸ Ø¨Ø§Ø³Ù…
        function openSaveAsModal() {
            document.getElementById('save-as-modal').classList.remove('hidden');
            document.getElementById('save-as-name').focus();
            // Ø¥Ø¹Ø·Ø§Ø¡ Ø§Ø³Ù… Ø§ÙØªØ±Ø§Ø¶ÙŠ (Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠ Ø¹Ø§Ù… Ù…Ø¹ Ø£Ø±Ù‚Ø§Ù… Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©)
            const randomNum = Math.floor(Math.random() * 1000000);
            const defaultName = `template_${randomNum}`; 
            document.getElementById('save-as-name').value = defaultName;
        }

        function closeSaveAsModal() {
            document.getElementById('save-as-modal').classList.add('hidden');
        }

        // --- ÙˆØ¸Ø§Ø¦Ù Ù…ÙˆØ¯Ø§Ù„ Ø§Ù„Ù†Ø¬Ø§Ø­ ---
        function showSuccessModal(message, title = 'ØªÙ…Øª Ø§Ù„Ø¹Ù…Ù„ÙŠØ©') {
            const modal = document.getElementById('success-modal');
            const content = document.getElementById('success-modal-content');
            
            document.getElementById('success-modal-title').textContent = title;
            document.getElementById('success-modal-message').innerHTML = message; // Use innerHTML for formatting
            
            modal.classList.remove('hidden');
            // Trigger animation
            setTimeout(() => {
                modal.classList.remove('opacity-0');
                content.classList.remove('scale-90');
                content.classList.add('scale-100');
            }, 10);
        }

        function closeSuccessModal() {
            const modal = document.getElementById('success-modal');
            const content = document.getElementById('success-modal-content');
            
            modal.classList.add('opacity-0');
            content.classList.remove('scale-100');
            content.classList.add('scale-90');
            
            setTimeout(() => {
                modal.classList.add('hidden');
            }, 300);
        }

        // ØªÙ†ÙÙŠØ° Ø­ÙØ¸ Ø§Ù„Ù…Ù„Ù Ø¨Ø§Ø³Ù… Ø¬Ø¯ÙŠØ¯ (ÙÙŠ Ø§Ù„Ù‚ÙˆØ§Ù„Ø¨ Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø©)
        async function executeSaveAsFile() {
            const fileName = document.getElementById('save-as-name').value.trim();
            const callback = document.getElementById('save-as-callback').value || '';
            
            if (!fileName) {
                alert('âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ø³Ù… Ø§Ù„Ù…Ø´Ø±ÙˆØ¹');
                return;
            }
            
            try {
                // Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙƒØ§Ù…Ù„Ø© Ù„Ù„Ø­ÙØ¸
                const card = document.getElementById('card');
                const projectData = {
                    name: fileName,
                    html: card.innerHTML,
                    width: card.style.width,
                    height: card.style.height,
                    wVal: card.getAttribute('data-card-width'),
                    hVal: card.getAttribute('data-card-height'),
                    customW: document.getElementById('custom-width').value,
                    customH: document.getElementById('custom-height').value,
                    timestamp: new Date().toLocaleString('ar-SA'),
                    version: "2.0" 
                };
                
                // 1. Ø§Ù„ØªÙ†Ø²ÙŠÙ„ Ø§Ù„Ù…Ø¨Ø§Ø´Ø± ÙƒÙ…Ù„Ù JSON (.dalal) Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
                const dataStr = JSON.stringify(projectData, null, 2);
                const blob = new Blob([dataStr], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `${fileName}.template`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                // 2. Ø§Ù„Ø­ÙØ¸ Ø£ÙŠØ¶Ø§Ù‹ ÙÙŠ Ø§Ù„Ù‚ÙˆØ§Ù„Ø¨ Ø§Ù„Ù…Ø­Ù„ÙŠØ© (Ù„Ù„ÙˆØµÙˆÙ„ Ø§Ù„Ø³Ø±ÙŠØ¹)
                try {
                    const templates = getTemplates();
                    // Ø§Ø³ØªØ®Ø¯Ø§Ù… try-catch Ø¯Ø§Ø®Ù„ÙŠ Ù„Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ù…Ø´ÙƒÙ„Ø© Ø§Ù…ØªÙ„Ø§Ø¡ Ø§Ù„ØªØ®Ø²ÙŠÙ†
                    if (templates.length < MAX_TEMPLATES) {
                        // Ø¥Ø¶Ø§ÙØ© Ù…Ø¹Ø±Ù ÙØ±ÙŠØ¯ Ù„ØªØ¬Ù†Ø¨ Ø§Ù„ØªÙƒØ±Ø§Ø±
                        projectData.id = Date.now();
                        templates.push(projectData);
                        saveTemplates(templates, false); // false = Ù„ÙŠØ³ Ù…Ø´ØªØ±Ùƒ (Ø®Ø§Øµ)
                    } else {
                        console.warn('Local templates full, file downloaded only.');
                    }
                } catch (storageError) {
                    console.error("Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø­Ù„ÙŠ:", storageError);
                    // Ù†ØªØ¬Ø§Ù‡Ù„ Ø®Ø·Ø£ Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø­Ù„ÙŠ Ù„Ø£Ù†Ù†Ø§ Ù‚Ù…Ù†Ø§ Ø¨ØªÙ†Ø²ÙŠÙ„ Ø§Ù„Ù…Ù„Ù Ø¨Ø§Ù„ÙØ¹Ù„
                    // ÙˆÙ‡Ø°Ø§ Ù‡Ùˆ Ø§Ù„Ø£Ù‡Ù… Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
                }
                
                showSuccessModal('ØªÙ… Ø­ÙØ¸ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ Ø¨Ù†Ø¬Ø§Ø­');
                closeSaveAsModal();
                document.getElementById('save-as-name').value = '';
                
                if (callback === 'newProject') {
                    closeNewProjectModal();
                    // ØªØ£Ø®ÙŠØ± Ø¨Ø³ÙŠØ· Ù„Ø¥Ø¸Ù‡Ø§Ø± Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø­ÙØ¸ Ù‚Ø¨Ù„ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ¹ÙŠÙŠÙ†
                    setTimeout(() => {
                         resetCanvas();
                         document.getElementById('save-as-callback').value = '';
                    }, 1000);
                }
                
            } catch (err) {
                console.error(err);
                alert('âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø­ÙØ¸: ' + err.message);
            }
        }

        // Ø¯Ø§Ù„Ø© Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ Ù…Ù† Ù…Ù„Ù
        function loadProjectFromFile(file) {
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const projectData = JSON.parse(e.target.result);
                    
                    // ØªØ­Ù‚Ù‚ Ù…Ù† Ø³Ù„Ø§Ù…Ø© Ø§Ù„Ù…Ù„Ù
                    if (!projectData.html && !projectData.wVal && !projectData.width) {
                         throw new Error("Invalid project file");
                    }

                    // Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
                    const card = document.getElementById('card');
                    card.innerHTML = projectData.html;
                    
                    // ØªØµØ­ÙŠØ­ Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª (ØªÙˆØ§ÙÙ‚ÙŠØ© Ù…Ø¹ Ø§Ù„Ø¥ØµØ¯Ø§Ø±Ø§Øª Ø§Ù„Ù…Ø®ØªÙ„ÙØ©)
                    const wVal = projectData.wVal || projectData.cardWidth;
                    const hVal = projectData.hVal || projectData.cardHeight;
                    const customW = projectData.customW || projectData.customWidth || '10';
                    const customH = projectData.customH || projectData.customHeight || '10';

                    // Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ ÙÙŠ Ø§Ù„Ø­Ù‚ÙˆÙ„
                    document.getElementById('custom-width').value = customW;
                    document.getElementById('custom-height').value = customH;
                    
                    if (wVal && hVal) {
                        // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¯Ø§Ù„Ø© setCardSize Ù„Ø¶Ù…Ø§Ù† ØªØ­Ø¯ÙŠØ« ÙƒÙ„ Ø´ÙŠØ¡ (Ø§Ù„Ù…Ø³Ø·Ø±Ø©ØŒ Ø§Ù„ØªÙƒØ¨ÙŠØ±ØŒ Ø§Ù„ÙˆØ±Ù‚Ø©)
                        setCardSize(parseFloat(wVal), parseFloat(hVal));
                        
                        // ØªØ­Ø¯ÙŠØ« Ø³Ù…Ø§Øª Ø§Ù„Ø¨Ø·Ø§Ù‚Ø© ÙŠØ¯ÙˆÙŠØ§Ù‹ Ù„Ù„ØªØ£ÙƒØ¯
                        card.setAttribute('data-card-width', wVal);
                        card.setAttribute('data-card-height', hVal);
                    } else if (projectData.width && projectData.height) {
                         // Fallback Ù„Ù„Ù†Ø³Ø® Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© Ø¬Ø¯Ø§Ù‹
                         card.style.width = projectData.width;
                         card.style.height = projectData.height;
                    }
                    
                    // Ø¥Ø¹Ø§Ø¯Ø© ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø£Ø­Ø¯Ø§Ø« Ù„Ù„Ø¹Ù†Ø§ØµØ± (Ø§Ù„Ø³Ø­Ø¨ØŒ Ø§Ù„ØªØ­Ø¯ÙŠØ¯ØŒ Ø¥Ù„Ø®)
                    rebindEvents();
                    
                    // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„ØªØ¯Ø±Ø¬ (Ù…Ø®ÙÙŠ Ø§ÙØªØ±Ø§Ø¶ÙŠØ§Ù‹)
                    hasGradient = false;
                    const grad = document.getElementById('card-gradient');
                    if(grad) grad.style.display = 'none';
                    const btn = document.getElementById('btn-grad');
                    if(btn) {
                        btn.classList.remove('bg-[#6366f1]', 'text-white');
                        btn.classList.add('bg-[#f8fafc]', 'text-[#1e293b]');
                    }
                    
                    // Ø¶Ø¨Ø· Ø§Ù„Ø²ÙˆÙ… Ø¹Ù„Ù‰ 50% Ø¯Ø§Ø¦Ù…Ø§Ù‹ Ø¹Ù†Ø¯ ÙØªØ­ Ù…Ù„Ù
                    setCustomZoom(50);
                    
                    // ØªÙˆØ³ÙŠØ· Ø§Ù„Ø¨Ø·Ø§Ù‚Ø© ÙÙŠ Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø¹Ù…Ù„
                    setTimeout(() => {
                        const workspace = document.getElementById('workspace');
                        if (workspace) {
                            const card = document.getElementById('card');
                            const cardRect = card.getBoundingClientRect();
                            const workspaceRect = workspace.getBoundingClientRect();
                            
                            // Ø­Ø³Ø§Ø¨ Ù…ÙˆÙ‚Ø¹ Ø§Ù„ØªÙ…Ø±ÙŠØ± Ù„Ù„ØªÙˆØ³ÙŠØ·
                            const scrollLeft = (workspace.scrollWidth - workspaceRect.width) / 2;
                            const scrollTop = (workspace.scrollHeight - workspaceRect.height) / 2;
                            
                            workspace.scrollLeft = Math.max(0, scrollLeft);
                            workspace.scrollTop = Math.max(0, scrollTop);
                        }
                    }, 100);
                    
                    showSuccessModal(`ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹: ${projectData.name || 'Ø¨Ø¯ÙˆÙ† Ø§Ø³Ù…'}`);
                    
                } catch (err) {
                    console.error(err);
                    alert('âŒ Ø®Ø·Ø£ ÙÙŠ Ù‚Ø±Ø§Ø¡Ø© Ù…Ù„Ù Ø§Ù„Ù…Ø´Ø±ÙˆØ¹. Ø§Ù„Ù…Ù„Ù Ù‚Ø¯ ÙŠÙƒÙˆÙ† ØªØ§Ù„ÙØ§Ù‹ Ø£Ùˆ Ø¨ØµÙŠØºØ© ØºÙŠØ± ØµØ­ÙŠØ­Ø©.');
                }
            };
            
            reader.readAsText(file);
        }

        // Ø¯Ø§Ù„Ø© Ù„Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† canvas Ù„Ù„Ù…Ø´Ø±ÙˆØ¹ Ø§Ù„Ø¬Ø¯ÙŠØ¯
        function resetCanvas() {
            const card = document.getElementById('card');
            card.innerHTML = '<div id="card-gradient"></div>'; // Ø¥Ø¹Ø§Ø¯Ø© Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªØ¯Ø±Ø¬ Ù…Ø®ÙÙŠØ§Ù‹
            
            // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
            const defaultSize = Math.round(6 * DPI_RATIO); // 6cm Ø§ÙØªØ±Ø§Ø¶ÙŠ
            document.getElementById('custom-width').value = '6';
            document.getElementById('custom-height').value = '6';
            
            setCardSize(defaultSize, defaultSize);
            
            // ØªØµÙÙŠØ± Ø§Ù„ undo/redo
            undoStack = [];
            redoStack = [];
            
            // Ø­ÙØ¸ Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø£ÙˆÙ„ÙŠØ©
            saveState();
            
            // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„ØªØ¯Ø±Ø¬
            hasGradient = false;
            const grad = document.getElementById('card-gradient');
            if(grad) grad.style.display = 'none';
            const btn = document.getElementById('btn-grad');
            if(btn) {
                btn.classList.remove('bg-[#6366f1]', 'text-white');
                btn.classList.add('bg-[#f8fafc]', 'text-[#1e293b]');
            }
            
            // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ù…ØªØºÙŠØ± Ø§Ù„Ù‚Ø§Ù„Ø¨ Ø§Ù„Ù…Ø­Ù…Ù„
            currentLoadedTemplateIndex = null;
            
            // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù‚ÙˆØ§Ù„Ø¨
            document.getElementById('template-select').value = '';
            
            showSuccessModal('ØªÙ… Ø¨Ø¯Ø¡ Ù…Ø´Ø±ÙˆØ¹ Ø¬Ø¯ÙŠØ¯ Ø¨Ù†Ø¬Ø§Ø­');
        }

        function loadTemplate(index) {
            if (index === "") return;
            
            if(!confirm('Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† ÙØªØ­ Ø§Ù„Ù‚Ø§Ù„Ø¨ØŸ Ø³ÙŠØªÙ… Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ø¹Ù…Ù„ Ø§Ù„Ø­Ø§Ù„ÙŠ.')) {
                return;
            }

            const templates = getTemplates();
            const template = templates[index];
            
            if (template) {
                const card = document.getElementById('card');
                
                // Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯
                card.style.width = template.width;
                card.style.height = template.height;
                card.setAttribute('data-card-width', template.wVal);
                card.setAttribute('data-card-height', template.hVal);
                
                // Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­ØªÙˆÙ‰
                card.innerHTML = template.html;
                
                // Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ù‚ÙŠÙ… Ø§Ù„Ø­Ù‚ÙˆÙ„
                if (template.customW) document.getElementById('custom-width').value = template.customW;
                if (template.customH) document.getElementById('custom-height').value = template.customH;
                
                // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø³Ø·Ø±Ø© ÙˆØ§Ù„Ø²ÙˆÙ…
                const w = parseFloat(template.wVal);
                const h = parseFloat(template.hVal);
                setCardSize(w, h); // Ù‡Ø°Ø§ Ø³ÙŠØ¹ÙŠØ¯ Ø±Ø³Ù… Ø§Ù„Ù…Ø³Ø·Ø±Ø©
                
                // Ø¥Ø¹Ø§Ø¯Ø© ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø£Ø­Ø¯Ø§Ø« Ù„Ù„Ø¹Ù†Ø§ØµØ±
                rebindEvents();
                
                // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„ØªØ¯Ø±Ø¬ (Ù…Ø®ÙÙŠ Ø§ÙØªØ±Ø§Ø¶ÙŠØ§Ù‹)
                hasGradient = false;
                const grad = document.getElementById('card-gradient');
                if(grad) grad.style.display = 'none';
                const btn = document.getElementById('btn-grad');
                if(btn) {
                    btn.classList.remove('bg-[#6366f1]', 'text-white');
                    btn.classList.add('bg-[#f8fafc]', 'text-[#1e293b]');
                }
                
                // ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù‚Ø§Ù„Ø¨ Ø§Ù„Ù…Ø­Ù…Ù„ Ø­Ø§Ù„ÙŠØ§Ù‹
                currentLoadedTemplateIndex = index;
                
                // Ø¥Ø¹Ø§Ø¯Ø© ØªØµÙÙŠØ± Ø§Ù„ØªØ­Ø¯ÙŠØ¯
                document.getElementById('template-select').value = "";
                undoStack = []; // ØªØµÙÙŠØ± Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ù„Ø¨Ø¯Ø§ÙŠØ© Ø¬Ø¯ÙŠØ¯Ø©
                redoStack = [];
            }
        }

        function deleteSelectedTemplate() {
            const select = document.getElementById('template-select');
            const index = select.value;
            
            if (index === "") {
                alert('ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ù‚Ø§Ù„Ø¨ Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø£ÙˆÙ„Ø§Ù‹ Ù„Ø­Ø°ÙÙ‡.');
                return;
            }
            
            const allTemplates = getTemplates();
            const selectedTemplate = allTemplates[index];
            
            // ØªØ­Ø¯ÙŠØ¯ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù‚Ø§Ù„Ø¨ Ù…Ø´ØªØ±Ùƒ Ø£Ù… Ø®Ø§Øµ
            const userTemplates = JSON.parse(localStorage.getItem(getUserTemplatesKey()) || '[]');
            const sharedTemplates = JSON.parse(localStorage.getItem(SHARED_TEMPLATES_KEY) || '[]');
            
            const isShared = sharedTemplates.some(t => t.id === selectedTemplate.id);
            
            if (isShared) {
                return;
            }
            
            if(confirm(`Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ù‡Ø°Ø§ Ø§Ù„Ù‚Ø§Ù„Ø¨ØŸ\n"${selectedTemplate.name}"\n\nÙ„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù† Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡.`)) {
                // Ø­Ø°Ù Ù…Ù† Ø§Ù„Ù‚ÙˆØ§Ù„Ø¨ Ø§Ù„Ø®Ø§ØµØ© ÙÙ‚Ø·
                const updatedUserTemplates = userTemplates.filter(t => t.id !== selectedTemplate.id);
                saveTemplates(updatedUserTemplates, false);
                alert('âœ… ØªÙ… Ø­Ø°Ù Ø§Ù„Ù‚Ø§Ù„Ø¨.');
                select.value = "";
            }
        }

        // --- Ù…ÙŠØ²Ø© Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø£ØµÙˆÙ„ (ÙØªØ­ ÙƒØ¹Ù†Ø§ØµØ±) ---
        function openTemplateAsAssets() {
            const select = document.getElementById('template-select');
            const index = select.value;
            
            if (index === "") {
                alert('ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ù‚Ø§Ù„Ø¨ Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø£ÙˆÙ„Ø§Ù‹ Ù„ÙØªØ­Ù‡ ÙƒØ¹Ù†Ø§ØµØ±.');
                return;
            }

            const templates = getTemplates();
            const template = templates[index];
            if (!template) return;

            // ØªØ­Ù„ÙŠÙ„ Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù‚Ø§Ù„Ø¨ Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„ØµÙˆØ± ÙˆØ§Ù„Ù†ØµÙˆØµ
            const parser = new DOMParser();
            const doc = parser.parseFromString(template.html, 'text/html');
            
            const images = [];
            doc.querySelectorAll('.image-layer img').forEach(img => {
                images.push(img.src);
            });

            const texts = [];
            doc.querySelectorAll('.text-layer .user-text').forEach(txt => {
                if(txt.innerText.trim()) texts.push(txt.innerText);
            });

            if (images.length === 0 && texts.length === 0) {
                alert('Ù‡Ø°Ø§ Ø§Ù„Ù‚Ø§Ù„Ø¨ Ù„Ø§ ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ØµÙˆØ± Ø£Ùˆ Ù†ØµÙˆØµ Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬.');
                return;
            }

            // ØªØ¹Ø¨Ø¦Ø© Ø§Ù„Ù†Ø§ÙØ°Ø© Ø§Ù„Ø¹Ø§Ø¦Ù…Ø©
            const contentDiv = document.getElementById('asset-content');
            contentDiv.innerHTML = '';

            // Ø¥Ø¶Ø§ÙØ© Ø§Ù„ØµÙˆØ±
            images.forEach(src => {
                const item = document.createElement('div');
                item.className = 'asset-item';
                item.innerHTML = `<img src="${src}" alt="asset">`;
                item.onclick = () => addAssetImage(src);
                contentDiv.appendChild(item);
            });

            // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù†ØµÙˆØµ
            texts.forEach(txt => {
                const item = document.createElement('div');
                item.className = 'asset-item';
                item.innerHTML = `<div class="asset-item-text">${txt.substring(0, 20)}${txt.length>20?'...':''}</div>`;
                item.onclick = () => { addTextToCanvas(txt, false); saveState(); };
                contentDiv.appendChild(item);
            });

            // Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ù†Ø§ÙØ°Ø©
            document.getElementById('asset-window').style.display = 'flex';
        }

        // Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ø¥Ø¶Ø§ÙØ© ØµÙˆØ±Ø© Ù…Ù† Ø±Ø§Ø¨Ø· Ù…Ø¨Ø§Ø´Ø± (Ù„Ù„Ø£ØµÙˆÙ„)
        function addAssetImage(src) {
            const wrapper = createWrapper('image-layer');
            const contentWrapper = wrapper.querySelector('.content-wrapper');
            wrapper.style.width = '60%';
            wrapper.style.height = '60%';
            contentWrapper.style.width = '100%';
            contentWrapper.style.height = '100%';
            contentWrapper.style.overflow = 'hidden';
            contentWrapper.style.borderRadius = '8px';
            contentWrapper.style.display = 'flex';
            
            const img = document.createElement('img');
            img.crossOrigin = "anonymous";
            img.src = src;
            img.loading = "eager";
            img.style.width = '100%';
            img.style.height = '100%';
            img.style.objectFit = 'fill';
            img.style.pointerEvents = 'none';
            
            // Ø­ÙØ¸ Ø§Ù„Ø£ØµÙ„
            wrapper.setAttribute('data-original-image', src);
            
            contentWrapper.appendChild(img);
            document.getElementById('card').appendChild(wrapper);
            selectEl(wrapper);
            setupInteract(wrapper, 'box');
            saveState();
        }

        // Ø¯Ø§Ù„Ø© Ù„ØªØ­Ø±ÙŠÙƒ Ù†Ø§ÙØ°Ø© Ø§Ù„Ø£ØµÙˆÙ„
        function initAssetWindowDrag() {
            const el = document.getElementById('asset-window');
            const header = document.getElementById('asset-header');
            
            let isDragging = false;
            let startX, startY, initialLeft, initialTop;

            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                initialLeft = el.offsetLeft;
                initialTop = el.offsetTop;
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                el.style.left = `${initialLeft + dx}px`;
                el.style.top = `${initialTop + dy}px`;
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            // Touch support for dragging window
            header.addEventListener('touchstart', (e) => {
                isDragging = true;
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                initialLeft = el.offsetLeft;
                initialTop = el.offsetTop;
                e.preventDefault();
            });

            document.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const dx = e.touches[0].clientX - startX;
                const dy = e.touches[0].clientY - startY;
                el.style.left = `${initialLeft + dx}px`;
                el.style.top = `${initialTop + dy}px`;
            });

            document.addEventListener('touchend', () => {
                isDragging = false;
            });
        }

        // --- ÙˆØ¸Ø§Ø¦Ù Ø§Ù„Ø­ÙØ¸ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ø§Ù„Ù…Ø¨Ø§Ø´Ø±Ø© ---

        async function saveWorkDirectly() {
             const overlay = document.getElementById('export-overlay');
             const loadingText = overlay.querySelector('.text-white');
             if(loadingText) loadingText.innerText = "Ø¬Ø§Ø±ÙŠ Ø­ÙØ¸ Ø§Ù„Ø¹Ù…Ù„...";
             overlay.style.display = 'flex';

             try {
                deselect();
                const card = document.getElementById('card');
                await new Promise(r => setTimeout(r, 200));

                // Ø§Ù„Ø­ÙØ¸ Ø¨Ø§Ù„Ø­Ø¬Ù… Ø§Ù„ÙØ¹Ù„ÙŠ Ø¨Ø¯Ù‚Ø© 300 DPI
                const pixelRatio = 4; // Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø¬ÙˆØ¯Ø© Ø¹Ø§Ù„ÙŠØ©
                const actualWidth = parseInt(card.getAttribute('data-card-width')) || card.offsetWidth;
                const actualHeight = parseInt(card.getAttribute('data-card-height')) || card.offsetHeight;
                
                const dataUrl = await htmlToImage.toPng(card, {
                    pixelRatio: pixelRatio, 
                    cacheBust: true,
                    width: actualWidth,
                    height: actualHeight,
                    style: { 
                        transform: 'none', 
                        boxShadow: 'none', 
                        margin: '0',
                        border: 'none'
                    }
                });

                const link = document.createElement('a');
                link.download = `design-${Date.now()}.png`;
                link.href = dataUrl;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

             } catch (err) {
                 console.error(err);
                 alert("Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø­ÙØ¸");
             } finally {
                 overlay.style.display = 'none';
             }
        }

        // Ø¯Ø§Ù„Ø© Ø¥ØºÙ„Ø§Ù‚ Ù…ÙˆØ¯Ø§Ù„ Ø§Ù„Ø·Ø¨Ø§Ø¹Ø© A4 Ù…Ø¹ Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø²ÙˆÙ…
        function closeA4Modal() {
            document.getElementById('save-modal').style.display = 'none';
            // Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø²ÙˆÙ… Ø¥Ù„Ù‰ Ù…Ø§ ÙƒØ§Ù† Ø¹Ù„ÙŠÙ‡ Ù‚Ø¨Ù„ ÙØªØ­ Ø§Ù„Ù…ÙˆØ¯Ø§Ù„
            if (savedZoomBeforeA4 !== null) {
                setCustomZoom(savedZoomBeforeA4);
            }
        }

        async function generateA4Sheet() {
            const loadingText = document.querySelector('#export-overlay .text-white');
            if(loadingText) loadingText.innerText = "Ø¬Ø§Ø±ÙŠ ØªØ­Ø¶ÙŠØ± ØµÙØ­Ø© A4...";
            
            const overlay = document.getElementById('export-overlay');
            overlay.style.display = 'flex';

            deselect();
            
            // Ø­ÙØ¸ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø²ÙˆÙ… Ø§Ù„Ø­Ø§Ù„ÙŠ ÙÙŠ Ù…ØªØºÙŠØ± Ø¹Ø§Ù…
            savedZoomBeforeA4 = window.currentZoom || 100;
            const card = document.getElementById('card');
            
            try {
                // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø²ÙˆÙ… Ø¥Ù„Ù‰ 100% Ù„Ø¶Ù…Ø§Ù† Ø¯Ù‚Ø© Ø§Ù„Ø·Ø¨Ø§Ø¹Ø©
                setCustomZoom(100);
                
                // Ø§Ù†ØªØ¸Ø§Ø± Ø°ÙƒÙŠ Ù„ØµÙˆØ± Ø§Ù„Ù…Ø­ØªÙˆÙ‰ (Ø­Ø¯ Ø£Ù‚ØµÙ‰ 3 Ø«ÙˆØ§Ù†ÙŠ)
                await Promise.race([
                    waitForImagesLoad(card),
                    new Promise(r => setTimeout(r, 3000))
                ]);
                
                // ØªØ£Ø®ÙŠØ± Ø¨Ø³ÙŠØ· Ù„Ø§Ù†Ø¹Ø§Ø´ Ø§Ù„ÙˆØ§Ø¬Ù‡Ø©
                await new Promise(r => setTimeout(r, 200));

                let cardDataUrl = null;

                // --- Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ø§Ù„ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ù…ØªØ¹Ø¯Ø¯ (ÙØ´Ù„ -> Ù…Ø­Ø§ÙˆÙ„Ø© Ø£Ø®Ø±Ù‰) ---
                
                // Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„ØªØ´ØºÙŠÙ„ html2canvas
                const tryHtml2Canvas = async (scaleVal = 2) => {
                    if (typeof html2canvas === 'undefined') throw new Error("html2canvas missing");
                    const canvas = await html2canvas(card, {
                        scale: scaleVal,
                        useCORS: true, 
                        allowTaint: true,
                        backgroundColor: '#ffffff',
                        logging: false, // ØªØ¹Ø·ÙŠÙ„ Ø§Ù„Ø³Ø¬Ù„Ø§Øª Ù„ØªØ®ÙÙŠÙ Ø§Ù„Ø¶ØºØ·
                        scrollX: 0, scrollY: 0, x: 0, y: 0,
                        width: card.offsetWidth,
                        height: card.offsetHeight
                    });
                    return canvas.toDataURL('image/png');
                };

                // Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„ØªØ´ØºÙŠÙ„ htmlToImage
                const tryHtmlToImage = async (pixelRatioVal = 2) => {
                    if (typeof htmlToImage === 'undefined') throw new Error("htmlToImage missing");
                    return await htmlToImage.toPng(card, {
                        pixelRatio: pixelRatioVal,
                        cacheBust: true,
                        allowTaint: true,
                        useCORS: true,
                        backgroundColor: '#ffffff',
                        width: card.offsetWidth,
                        height: card.offsetHeight,
                        style: { transform: 'none', boxShadow: 'none', margin: '0' }
                    });
                };

                // 1. Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰: htmlToImage (Ø§Ù„Ø£ÙØ¶Ù„ Ù„Ù„Ù†ØµÙˆØµ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©)
                try {
                    cardDataUrl = await Promise.race([
                        tryHtmlToImage(2),
                        new Promise((_, r) => setTimeout(() => r(new Error('Timeout 1')), 10000))
                    ]);
                } catch (err1) {
                    console.warn("ÙØ´Ù„Øª Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰ (htmlToImage)ØŒ Ø¬Ø§Ø±ÙŠ ØªØ¬Ø±Ø¨Ø© html2canvas...", err1);
                    
                    // 2. Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ©: html2canvas (Ø¨Ø¯ÙŠÙ„)
                    try {
                        cardDataUrl = await Promise.race([
                            tryHtml2Canvas(2),
                            new Promise((_, r) => setTimeout(() => r(new Error('Timeout 2')), 7000))
                        ]);
                    } catch (err2) {
                        console.warn("ÙØ´Ù„Øª Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ©ØŒ Ø¬Ø§Ø±ÙŠ ØªØ¬Ø±Ø¨Ø© Ø¬ÙˆØ¯Ø© Ø£Ù‚Ù„...", err2);
                        
                        // 3. Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø«Ø§Ù„Ø«Ø©: htmlToImage (Ø¬ÙˆØ¯Ø© Ø£Ù‚Ù„) - Ø§Ù„Ù…Ù„Ø§Ø° Ø§Ù„Ø£Ø®ÙŠØ±
                        try {
                             cardDataUrl = await Promise.race([
                                tryHtmlToImage(1),
                                new Promise((_, r) => setTimeout(() => r(new Error('Timeout 3')), 5000))
                            ]);
                        } catch (err3) {
                            throw new Error("ÙØ´Ù„Øª Ø¬Ù…ÙŠØ¹ Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØµÙˆØ±Ø©. ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„ØµÙˆØ± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…Ø© ØµØ§Ù„Ø­Ø©.");
                        }
                    }
                }

                if (!cardDataUrl) throw new Error("Ù„Ù… ÙŠØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØµÙˆØ±Ø©");

                currentCardData = cardDataUrl;

                // Ø¥Ø¹Ø¯Ø§Ø¯ Ø£Ø¨Ø¹Ø§Ø¯ A4 (300 DPI)
                const A4_WIDTH = 2480;
                const A4_HEIGHT = 3508;
                
                const cardW = card.offsetWidth; 
                const cardH = card.offsetHeight;
                const GAP = 40; 

                // Ø­Ø³Ø§Ø¨ Ø§Ù„ØªÙˆØ²ÙŠØ¹
                const portraitCols = Math.floor((A4_WIDTH + GAP) / (cardW + GAP));
                const portraitRows = Math.floor((A4_HEIGHT + GAP) / (cardH + GAP));
                const portraitCount = portraitCols * portraitRows;

                const landscapeCols = Math.floor((A4_HEIGHT + GAP) / (cardW + GAP));
                const landscapeRows = Math.floor((A4_WIDTH + GAP) / (cardH + GAP));
                const landscapeCount = landscapeCols * landscapeRows;

                let finalCanvasW, finalCanvasH, cols, rows;

                if (landscapeCount > portraitCount) {
                    finalCanvasW = A4_HEIGHT; finalCanvasH = A4_WIDTH;  
                    cols = landscapeCols; rows = landscapeRows;
                } else {
                    finalCanvasW = A4_WIDTH; finalCanvasH = A4_HEIGHT;
                    cols = portraitCols; rows = portraitRows;
                }
                
                currentA4Layout = {
                    canvasW: finalCanvasW, canvasH: finalCanvasH,
                    cols: cols, rows: rows,
                    cardW: cardW, cardH: cardH,
                    gap: GAP,
                    maxCopies: cols * rows
                };

                // Ø¹Ø±Ø¶ Ø§Ù„Ù…ÙˆØ¯Ø§Ù„ Ø¨Ø¹Ø¯ ØªØ¬Ù‡ÙŠØ² Ø§Ù„ØµÙˆØ±Ø©
                const img = new Image();
                img.onload = () => {
                    cachedCardImage = img;
                    
                    document.getElementById('a4-count').max = currentA4Layout.maxCopies;
                    document.getElementById('a4-count').value = currentA4Layout.maxCopies;
                    document.getElementById('a4-max-text').innerText = `(Ù…Ù† Ø£ØµÙ„ ${currentA4Layout.maxCopies})`;
                    
                    renderA4Preview(currentA4Layout.maxCopies);
                    
                    overlay.style.display = 'none';
                    document.getElementById('save-modal').style.display = 'flex';
                    
                    // Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø²ÙˆÙ… Ø¨Ø¹Ø¯ Ø§Ù„Ù†Ø¬Ø§Ø­
                    setCustomZoom(savedZoomBeforeA4);
                };
                img.onerror = () => { throw new Error("ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ù…Ù†Ø´Ø£Ø©"); };
                img.src = cardDataUrl;

            } catch (err) {
                console.error("Ø®Ø·Ø£ ÙÙŠ A4:", err);
                overlay.style.display = 'none';
                // Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø²ÙˆÙ… Ø¹Ù†Ø¯ Ø§Ù„ÙØ´Ù„
                setCustomZoom(savedZoomBeforeA4);
                showInfoModal('Ø­Ø¯Ø«Øª Ù…Ø´ÙƒÙ„Ø© Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©. Ø­Ø§ÙˆÙ„ ØªÙ‚Ù„ÙŠÙ„ Ø¹Ø¯Ø¯ Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø£Ùˆ Ø¬ÙˆØ¯Ø© Ø§Ù„ØµÙˆØ±.', 'Ø¹Ø°Ø±Ø§Ù‹', 'âš ï¸');
            }
        }
        
        // Ø¯Ø§Ù„Ø© Ù„Ù„Ø§Ù†ØªØ¸Ø§Ø± Ù„ØªØ­Ù…ÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØµÙˆØ±
        function waitForImagesLoad(element) {
            const images = element.querySelectorAll('img');
            
            if (images.length === 0) {
                return Promise.resolve();
            }
            
            const promises = Array.from(images).map(img => {
                return new Promise(resolve => {
                    if (!img.src) {
                        resolve();
                        return;
                    }
                    
                    if (img.complete && img.naturalWidth > 0) {
                        resolve();
                        return;
                    }
                    
                    const onLoad = () => {
                        img.removeEventListener('load', onLoad);
                        img.removeEventListener('error', onLoad);
                        resolve();
                    };
                    
                    img.addEventListener('load', onLoad, { once: true });
                    img.addEventListener('error', onLoad, { once: true });
                    
                    setTimeout(resolve, 2000);
                });
            });
            
            return Promise.all(promises);
        }

        // Ø¯Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© Ø¹Ù†Ø¯ ØªØºÙŠÙŠØ± Ø§Ù„Ø±Ù‚Ù…
        function updateA4Count() {
            const input = document.getElementById('a4-count');
            let count = parseInt(input.value);
            
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¯ÙˆØ¯
            if (isNaN(count) || count < 1) count = 1;
            if (count > currentA4Layout.maxCopies) count = currentA4Layout.maxCopies;
            
            renderA4Preview(count);
        }
        
        // Ø¯Ø§Ù„Ø© Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ù…Ù†ÙØµÙ„Ø©
        function renderA4Preview(count) {
            if (!cachedCardImage || !currentA4Layout) return;
            
            const canvas = document.createElement('canvas');
            canvas.width = currentA4Layout.canvasW;
            canvas.height = currentA4Layout.canvasH;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const totalW = currentA4Layout.cols * currentA4Layout.cardW + (currentA4Layout.cols - 1) * currentA4Layout.gap;
            const totalH = currentA4Layout.rows * currentA4Layout.cardH + (currentA4Layout.rows - 1) * currentA4Layout.gap;
            const startX = (canvas.width - totalW) / 2;
            const startY = (canvas.height - totalH) / 2;
            
            let drawnCount = 0;
            const showCutLines = document.getElementById('show-cut-lines').checked;
            
            // Ø±Ø³Ù… Ø§Ù„Ù†Ø³Ø® Ø­Ø³Ø¨ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨
            outerLoop:
            for (let j = 0; j < currentA4Layout.rows; j++) {
                for (let i = 0; i < currentA4Layout.cols; i++) {
                    if (drawnCount >= count) break outerLoop;
                    
                    const x = startX + (i * (currentA4Layout.cardW + currentA4Layout.gap));
                    const y = startY + (j * (currentA4Layout.cardH + currentA4Layout.gap));
                    
                    ctx.drawImage(cachedCardImage, x, y, currentA4Layout.cardW, currentA4Layout.cardH);
                    
                    // Ø¥Ø·Ø§Ø± Ø§Ù„Ù‚Øµ Ø§Ù„Ø±Ù…Ø§Ø¯ÙŠ - ÙÙ‚Ø· Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù€ checkbox Ù…ÙØ¹Ù„
                    if (showCutLines) {
                        ctx.strokeStyle = '#94a3b8'; 
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x, y, currentA4Layout.cardW, currentA4Layout.cardH);
                    }
                    
                    drawnCount++;
                }
            }
            
            const saveImg = document.getElementById('save-img');
            saveImg.src = canvas.toDataURL('image/png');
        }
        
        function downloadPDF() {
            const { jsPDF } = window.jspdf;
            const imgData = document.getElementById('save-img').src;
            // A4 size in mm: 210 x 297
            const pdf = new jsPDF('p', 'mm', 'a4');
            const width = pdf.internal.pageSize.getWidth();
            const height = pdf.internal.pageSize.getHeight();
            pdf.addImage(imgData, 'PNG', 0, 0, width, height);
            
            const randomNum = Math.floor(Math.random() * 1000000);
            pdf.save(`template_${randomNum}.pdf`);
        }

        async function sendToTelegramPDF(btnElement) {
            if (TG_BOT_TOKEN === "YOUR_BOT_TOKEN_HERE" || TG_CHAT_ID === "YOUR_CHAT_ID_HERE") {
                alert("Ø§Ù„Ø±Ø¬Ø§Ø¡ ÙˆØ¶Ø¹ Ø§Ù„ØªÙˆÙƒÙ† ÙˆØ§Ù„Ø´Ø§Øª Ø¢ÙŠØ¯ÙŠ ÙÙŠ Ø§Ù„ÙƒÙˆØ¯ Ø£ÙˆÙ„Ø§Ù‹ (ÙÙŠ Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„Ø³ÙƒØ±Ø¨Øª)!");
                return;
            }

            const originalText = btnElement.innerHTML;
            btnElement.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„...';
            btnElement.disabled = true;
            btnElement.classList.add('opacity-75', 'cursor-not-allowed');

            try {
                const { jsPDF } = window.jspdf;
                const imgData = document.getElementById('save-img').src;
                // A4 size in mm: 210 x 297
                const pdf = new jsPDF('p', 'mm', 'a4');
                const width = pdf.internal.pageSize.getWidth();
                const height = pdf.internal.pageSize.getHeight();
                pdf.addImage(imgData, 'PNG', 0, 0, width, height);
                
                // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù€ PDF Ø¥Ù„Ù‰ Blob
                const pdfBlob = pdf.output('blob');
                
                const randomNum = Math.floor(Math.random() * 1000000);
                
                // ØªØ¬Ù‡ÙŠØ² Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù„Ø¥Ø±Ø³Ø§Ù„
                const formData = new FormData();
                formData.append("chat_id", TG_CHAT_ID);
                formData.append("document", pdfBlob, `template_${randomNum}.pdf`);
                formData.append("caption", "ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªØµÙ…ÙŠÙ… ğŸ¨âœ¨");

                // Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ø¥Ù„Ù‰ ØªÙ„ÙŠØ¬Ø±Ø§Ù…
                const response = await fetch(`https://api.telegram.org/bot${TG_BOT_TOKEN}/sendDocument`, {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();
                
                if (result.ok) {
                    alert("âœ… ØªÙ… Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ø¨Ù†Ø¬Ø§Ø­ Ø¥Ù„Ù‰ ØªÙ„ÙŠØ¬Ø±Ø§Ù…!");
                } else {
                    console.error(result);
                    alert("âŒ ÙØ´Ù„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„: " + (result.description || "Ø®Ø·Ø£ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ"));
                }

            } catch (error) {
                console.error(error);
                alert("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨ØªÙ„ÙŠØ¬Ø±Ø§Ù…");
            } finally {
                btnElement.innerHTML = originalText;
                btnElement.disabled = false;
                btnElement.classList.remove('opacity-75', 'cursor-not-allowed');
            }
        }

        // --- Ø¨Ø§Ù‚ÙŠ Ø§Ù„ÙˆØ¸Ø§Ø¦Ù Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ---

        // ÙŠÙØ³ØªØ¯Ø¹Ù‰ Ø¨Ø¹Ø¯ Ø£ÙŠ ØªØºÙŠÙŠØ± Ù„Ø­ÙØ¸ Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
        function saveState() {
            const card = document.getElementById('card');
            const currentState = {
                html: card.innerHTML,
                width: card.style.width,
                height: card.style.height
            };
            
            // ØªØ¬Ù†Ø¨ Ø­ÙØ¸ Ù†ÙØ³ Ø§Ù„Ø­Ø§Ù„Ø© Ù…Ø±ØªÙŠÙ† Ù…ØªØªØ§Ù„ÙŠØªÙŠÙ†
            if (undoStack.length > 0) {
                const lastState = undoStack[undoStack.length - 1];
                if (lastState.html === currentState.html && 
                    lastState.width === currentState.width && 
                    lastState.height === currentState.height) {
                    return; // Ù†ÙØ³ Ø§Ù„Ø­Ø§Ù„Ø©ØŒ Ù„Ø§ Ø¯Ø§Ø¹ÙŠ Ù„Ù„Ø­ÙØ¸
                }
            }
            
            undoStack.push(currentState);
            // Keep max 50 states
            if (undoStack.length > 50) undoStack.shift();
            // Clear redo when new action is taken
            redoStack = [];
            
            console.log('State saved. Undo stack size:', undoStack.length);
        }

        function updateHistoryButtons() {
            // Visual feedback (optional)
        }

        function undoAction() {
            console.log('Undo called. Stack size:', undoStack.length);
            
            // Ù†Ø­ØªØ§Ø¬ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„ Ø­Ø§Ù„ØªÙŠÙ†: Ø§Ù„Ø­Ø§Ù„ÙŠØ© ÙˆØ§Ù„Ø³Ø§Ø¨Ù‚Ø©
            if(undoStack.length < 2) {
                console.log('Nothing to undo - need at least 2 states');
                return;
            }
            
            // Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© (Ø¢Ø®Ø± Ø¹Ù†ØµØ±) Ù†Ø¶Ø¹Ù‡Ø§ ÙÙŠ redo
            const currentState = undoStack.pop();
            redoStack.push(currentState);
            
            // Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© (Ø§Ù„Ø¢Ù† Ø¢Ø®Ø± Ø¹Ù†ØµØ± Ø¨Ø¹Ø¯ pop)
            const previousState = undoStack[undoStack.length - 1];
            
            console.log('Restoring to previous state. Undo stack now:', undoStack.length);
            
            // Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©
            applyState(previousState);
        }

        function redoAction() {
            console.log('Redo called. Stack size:', redoStack.length);
            
            if(redoStack.length === 0) {
                console.log('Nothing to redo');
                return;
            }
            
            // Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø§Ù„Ø­Ø§Ù„Ø© Ù…Ù† redo
            const nextState = redoStack.pop();
            
            // Ø¥Ø¶Ø§ÙØªÙ‡Ø§ Ø¥Ù„Ù‰ undo
            undoStack.push(nextState);
            
            console.log('Restoring next state. Undo stack now:', undoStack.length);
            
            // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø­Ø§Ù„Ø©
            applyState(nextState);
        }

        // ØªØ·Ø¨ÙŠÙ‚ Ø­Ø§Ù„Ø© Ø¨Ø¯ÙˆÙ† Ø­ÙØ¸Ù‡Ø§ (Ù„ØªØ¬Ù†Ø¨ Ø§Ù„ØªÙƒØ±Ø§Ø±)
        function applyState(state) {
            const card = document.getElementById('card');
            
            if (typeof state === 'string') {
                card.innerHTML = state;
            } else {
                card.innerHTML = state.html;
                if (state.width && state.height) {
                    const w = parseFloat(state.width);
                    const h = parseFloat(state.height);
                    setCardSize(w, h);
                    
                    const customWidth = document.getElementById('custom-width');
                    const customHeight = document.getElementById('custom-height');
                    if(customWidth && customHeight) {
                        const cmW = w / DPI_RATIO;
                        const cmH = h / DPI_RATIO;
                        customWidth.value = cmW.toFixed(2);
                        customHeight.value = cmH.toFixed(2);
                    }
                }
            }
            
            rebindEvents();
            deselect();
        }

        // Ø¯Ø§Ù„Ø© Ù‚Ø¯ÙŠÙ…Ø© Ù„Ù„ØªÙˆØ§ÙÙ‚ÙŠØ©
        function restoreState(state) {
            applyState(state);
        }

        function rebindEvents() {
            document.querySelectorAll('.draggable-el').forEach(el => {
                // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© Ù„ÙØ±Ø¶ Ø¥Ø¹Ø§Ø¯Ø© Ø±Ø¨Ø· Ø§Ù„Ø£Ø­Ø¯Ø§Ø«
                el.removeAttribute('data-events-bound');
                setupInteract(el, el.classList.contains('text-layer') ? 'text' : 'box');
            });
        }

        function createWrapper(type) {
            const div = document.createElement('div');
            div.className = `draggable-el ${type} selected`;
            
            // ØªØ¹ÙŠÙŠÙ† z-index Ø§ÙØªØ±Ø§Ø¶ÙŠ Ø­Ø³Ø¨ Ù†ÙˆØ¹ Ø§Ù„Ø¹Ù†ØµØ±
            const card = document.getElementById('card');
            const layers = card.querySelectorAll('.draggable-el:not(.bg-image)');
            let maxZ = 10;
            layers.forEach(layer => {
                const z = parseInt(layer.style.zIndex) || 10;
                if (z > maxZ) maxZ = z;
            });
            div.style.zIndex = maxZ + 1;
            
            const controls = `
                <div class="control-btn delete-btn" onclick="removeEl(this.parentNode)" ontouchend="removeEl(this.parentNode); event.preventDefault(); event.stopPropagation();"><i class="fas fa-times"></i></div>
                <div class="control-btn duplicate-btn" onclick="duplicateElement(this.parentNode)" ontouchend="duplicateElement(this.parentNode); event.preventDefault(); event.stopPropagation();"><i class="fas fa-clone"></i></div>
                <div class="control-btn rotate-btn" onclick="rotateElement(this.parentNode)" ontouchend="rotateElement(this.parentNode); event.preventDefault(); event.stopPropagation();"><i class="fas fa-redo"></i></div>
                <div class="control-btn layer-up-btn" onclick="bringToFront(this.parentNode)" ontouchend="bringToFront(this.parentNode); event.preventDefault(); event.stopPropagation();" title="Ù„Ù„Ø£Ù…Ø§Ù…"><i class="fas fa-arrow-up"></i></div>
                <div class="control-btn layer-down-btn" onclick="sendToBack(this.parentNode)" ontouchend="sendToBack(this.parentNode); event.preventDefault(); event.stopPropagation();" title="Ù„Ù„Ø®Ù„Ù"><i class="fas fa-arrow-down"></i></div>
                <div class="move-handle" title="Ø§Ø³Ø­Ø¨ Ù„Ù„ØªØ­Ø±ÙŠÙƒ"><i class="fas fa-arrows-alt"></i></div>
                <div class="handle resize-nw"></div>
                <div class="handle resize-ne"></div>
                <div class="handle resize-sw"></div>
                <div class="handle resize-se"></div>
                <div class="handle resize-n"></div>
                <div class="handle resize-e"></div>
                <div class="handle resize-s"></div>
            `;
            div.innerHTML = controls;
            
            const contentWrapper = document.createElement('div');
            contentWrapper.className = 'content-wrapper';
            contentWrapper.style.width = '100%';
            contentWrapper.style.height = '100%';
            div.appendChild(contentWrapper);
            
            div.insertBefore(contentWrapper, div.lastChild);
            
            return div;
        }

        function addUserText() {
            const input = document.getElementById('user-text-input');
            const text = input.value.trim();
            if(!text) return;
            
            addTextToCanvas(text, false);
            saveState();
            input.value = '';
        }

        function addTextToCanvas(content, isQuran) {
            const wrapper = createWrapper('text-layer');
            wrapper.style.color = '#1e293b';
            wrapper.style.fontSize = '40px';
            wrapper.style.fontFamily = "'Cairo', sans-serif";
            wrapper.style.fontWeight = '600';
            wrapper.style.letterSpacing = '0.3px';
            
            const textDiv = document.createElement('div');
            textDiv.className = 'user-text';
            textDiv.contentEditable = true;
            textDiv.innerText = content;
            textDiv.onblur = function() { if(this.innerText.trim() === '') this.innerText = 'Ù†Øµ...'; saveState(); };

            wrapper.appendChild(textDiv);
            document.getElementById('card').appendChild(wrapper);
            
            selectEl(wrapper);
            setupInteract(wrapper, 'text');
        }

        function toggleFrameDropdown() {
             const dropdown = document.getElementById('frames-dropdown');
             const shapesDropdown = document.getElementById('shapes-dropdown');
             
             // Ø£ØºÙ„Ù‚ Ø§Ù„Ù‚ÙˆØ§Ø¦Ù… Ø§Ù„Ø£Ø®Ø±Ù‰
             if(shapesDropdown) shapesDropdown.classList.add('hidden');
             
             if (dropdown.classList.contains('hidden')) {
                 dropdown.classList.remove('hidden');
             } else {
                 dropdown.classList.add('hidden');
             }
        }

        function closeFramesDropdown() {
            const dropdown = document.getElementById('frames-dropdown');
            if(dropdown) dropdown.classList.add('hidden');
        }

        function addFrameType(type) {
            const wrapper = createWrapper('frame-layer');
            wrapper.style.borderColor = '#1e293b';
            wrapper.style.borderWidth = '3px';
            wrapper.style.backgroundColor = 'transparent';
            
            // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø­Ø¬Ù… Ø¨Ù‡ÙˆØ§Ù…Ø´ Ø¢Ù…Ù†Ø©
            wrapper.style.width = '50%';
            wrapper.style.height = '50%';
            
            // ØªØ·Ø¨ÙŠÙ‚ Ù†ÙˆØ¹ Ø§Ù„Ø¥Ø·Ø§Ø±
            if (type === 'circle') {
                 wrapper.style.borderRadius = '50%';
            } else if (type === 'rounded') {
                 // Ø§Ù†Ø­Ù†Ø§Ø¡ ÙƒØ¨ÙŠØ± ÙƒÙ…Ø§ Ø·Ù„Ø¨ Ø§Ù„Ø¹Ù…ÙŠÙ„
                 wrapper.style.borderRadius = '30px'; 
            } else {
                 wrapper.style.borderRadius = '0';
            }
            
            document.getElementById('card').appendChild(wrapper);
            selectEl(wrapper);
            setupInteract(wrapper, 'box');
            saveState();
            
            closeFramesDropdown();
        }

        // Ø¯Ø§Ù„Ø© Ù‚Ø¯ÙŠÙ…Ø©ØŒ ØªØ±ÙƒØª Ù„Ù„ØªÙˆØ§ÙÙ‚ Ø¥Ø°Ø§ ØªÙ… Ø§Ø³ØªØ¯Ø¹Ø§Ø¤Ù‡Ø§ Ù…Ù† Ù…ÙƒØ§Ù† Ø¢Ø®Ø±
        function addFrame() {
            addFrameType('square');
        }

        function addShape() {
            // ÙØªØ­/Ø¥ØºÙ„Ø§Ù‚ dropdown Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø£Ø´ÙƒØ§Ù„
            const dropdown = document.getElementById('shapes-dropdown');
            if (dropdown.classList.contains('hidden')) {
                dropdown.classList.remove('hidden');
            } else {
                dropdown.classList.add('hidden');
            }
        }
        
        function closeShapesDropdown() {
            const dropdown = document.getElementById('shapes-dropdown');
            dropdown.classList.add('hidden');
        }
        
        function addShapeType(type) {
            const wrapper = createWrapper('frame-layer');
            wrapper.style.width = '60%';
            wrapper.style.height = '60%';
            
            // Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø´ÙƒØ§Ù„ Ø¨Ù†ÙØ³ Ø§Ù„Ù„ÙˆÙ† Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ
            wrapper.style.backgroundColor = '#6366f1';
            
            if (type === 'square') {
                wrapper.style.borderRadius = '2px';
            } else if (type === 'circle') {
                wrapper.style.borderRadius = '50%';
            } else if (type === 'line') {
                // Ø®Ø· Ù…Ø³ØªÙ‚ÙŠÙ…
                wrapper.style.width = '80%';
                wrapper.style.height = '2px';
                wrapper.style.backgroundColor = '#6366f1';
            } else if (type === 'rounded') {
                wrapper.style.borderRadius = '12px';
            }
            
            wrapper.style.borderWidth = '0px';
            document.getElementById('card').appendChild(wrapper);
            selectEl(wrapper);
            setupInteract(wrapper, 'box');
            saveState();
            closeShapesDropdown();
        }

        function addImageLayer(input) {
            if (input.files && input.files[0]) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'draggable-el image-layer bg-image is-locked';
                    const img = document.createElement('img');
                    img.crossOrigin = "anonymous"; // Ø¥Ø¶Ø§ÙØ© CrossOrigin
                    img.src = e.target.result; 
                    img.loading = "eager";
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.objectFit = 'cover';
                    img.style.pointerEvents = 'none';
                    wrapper.appendChild(img);
                    const card = document.getElementById('card');
                    const gradient = document.getElementById('card-gradient');
                    if(gradient.nextSibling) card.insertBefore(wrapper, gradient.nextSibling);
                    else card.appendChild(wrapper);
                    setupInteract(wrapper, 'box');
                    saveState();
                };
                reader.readAsDataURL(input.files[0]);
                input.value = ''; 
            }
        }

        function addRegularImage(input) {
            if (input.files && input.files[0]) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const wrapper = createWrapper('image-layer');
                    const contentWrapper = wrapper.querySelector('.content-wrapper');
                    wrapper.style.width = '60%';
                    wrapper.style.height = '60%';
                    contentWrapper.style.width = '100%';
                    contentWrapper.style.height = '100%';
                    contentWrapper.style.overflow = 'hidden';
                    contentWrapper.style.borderRadius = '8px';
                    contentWrapper.style.display = 'flex';
                    
                    const img = document.createElement('img');
                    img.crossOrigin = "anonymous"; // Ø¥Ø¶Ø§ÙØ© CrossOrigin
                    img.src = e.target.result;
                    img.loading = "eager";
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.objectFit = 'fill';
                    img.style.pointerEvents = 'none';
                    img.style.imageRendering = 'high-quality';
                    
                    wrapper.setAttribute('data-original-image', e.target.result);
                    
                    contentWrapper.appendChild(img);
                    document.getElementById('card').appendChild(wrapper);
                    selectEl(wrapper);
                    setupInteract(wrapper, 'box');
                    saveState();
                };
                reader.readAsDataURL(input.files[0]);
                input.value = '';
            }
        }

        function toggleEraserMode() {
            eraserMode = !eraserMode;
            
            if (eraserMode) {
                if (lassoMode) exitLassoMode();

                magicMode = false;
                const magicControls = document.getElementById('magic-tolerance-control');
                if (magicControls) {
                    magicControls.classList.add('hidden');
                    magicControls.classList.remove('flex');
                }

                deselect();
                const controls = document.getElementById('eraser-controls');
                controls.classList.add('active');
                
                document.getElementById('card').style.cursor = 'crosshair';
                initEraserCanvas();
                // Disable interaction with other layers while erasing
                document.querySelectorAll('.draggable-el').forEach(el => el.style.pointerEvents = 'none');
            } else {
                exitEraserMode();
                return;
            }
            updateToolButtons();
        }
        
        function toggleMagicMode() {
            magicMode = !magicMode;
            const magicControls = document.getElementById('magic-tolerance-control');
            if(magicMode) {
                document.getElementById('card').style.cursor = 'alias';
                magicControls.classList.remove('hidden');
                magicControls.classList.add('flex');
            } else {
                document.getElementById('card').style.cursor = 'crosshair';
                magicControls.classList.add('hidden');
                magicControls.classList.remove('flex');
            }
            updateToolButtons();
        }

        function exitEraserMode() {
            eraserMode = false;
            magicMode = false;
            
            const controls = document.getElementById('eraser-controls');
            controls.classList.remove('active');
            
            document.getElementById('card').style.cursor = 'default';
            if(eraserCanvas) {
                eraserCanvas.remove();
                eraserCanvas = null;
            }
            // Re-enable interaction with other layers
            document.querySelectorAll('.draggable-el').forEach(el => el.style.pointerEvents = '');
            updateToolButtons();
        }

        // --- Ø¯ÙˆØ§Ù„ Ø§Ù„Ù‚Øµ Ø§Ù„Ø°ÙƒÙŠ (Lasso) ---
        function toggleLassoMode() {
            if(!lassoMode && (!activeEl || !activeEl.classList.contains('image-layer'))) {
                alert('ÙŠØ±Ø¬Ù‰ ØªØ­Ø¯ÙŠØ¯ Ø·Ø¨Ù‚Ø© ØµÙˆØ±Ø© Ø£ÙˆÙ„Ø§Ù‹ Ù„Ù„Ù‚Øµ Ù…Ù†Ù‡Ø§.');
                return;
            }
            lassoMode = !lassoMode;
            
            if (lassoMode) {
                if (eraserMode) exitEraserMode();

                magicMode = false;
                document.getElementById('card').style.cursor = 'crosshair';
                initLassoCanvas();
            } else {
                exitLassoMode();
            }
            updateToolButtons();
        }

        function updateToolButtons() {
            const eraserBtn = document.getElementById('btn-eraser');
            const lassoBtn = document.getElementById('btn-lasso');
            const magicBtn = document.getElementById('btn-magic');
            
            // Reset styles
            [eraserBtn, lassoBtn, magicBtn].forEach(btn => {
                if(btn) {
                    btn.classList.remove('bg-[#6366f1]', 'text-white');
                    btn.classList.remove('bg-white'); // Ensure white is gone to prevent conflict
                    btn.classList.add('bg-[#f8fafc]', 'text-[#1e293b]'); 
                }
            });

            if(eraserMode) {
                if(eraserBtn) {
                    eraserBtn.classList.add('bg-[#6366f1]', 'text-white');
                    eraserBtn.classList.remove('bg-[#f8fafc]', 'text-[#1e293b]');
                }
            }
            if(lassoMode) {
                if(lassoBtn) {
                    lassoBtn.classList.add('bg-[#6366f1]', 'text-white'); // Ù„ÙˆÙ† Ø§Ù„Ù‚Øµ
                    lassoBtn.classList.remove('bg-[#f8fafc]', 'text-[#1e293b]');
                }
            }
            if(magicMode && eraserMode) { // Magic is sub-mode of eraser
                 if(magicBtn) {
                    magicBtn.classList.add('bg-[#6366f1]', 'text-white');
                    magicBtn.classList.remove('bg-[#f8fafc]', 'text-[#1e293b]');
                 }
            }
        }

        function initLassoCanvas() {
            if(lassoCanvas) lassoCanvas.remove();
            const card = document.getElementById('card');
            
            lassoCanvas = document.createElement('canvas');
            lassoCanvas.width = card.offsetWidth;
            lassoCanvas.height = card.offsetHeight;
            lassoCanvas.style.position = 'absolute';
            lassoCanvas.style.top = '0';
            lassoCanvas.style.left = '0';
            lassoCanvas.style.cursor = 'crosshair';
            lassoCanvas.style.zIndex = '500';
            
            const ctx = lassoCanvas.getContext('2d');
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#6366f1';
            ctx.setLineDash([5, 5]);

            let isDrawing = false;
            let points = [];

            function getMousePos(e) {
                const rect = lassoCanvas.getBoundingClientRect();
                const scaleX = lassoCanvas.width / rect.width;
                const scaleY = lassoCanvas.height / rect.height;
                
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                return {
                    x: (clientX - rect.left) * scaleX,
                    y: (clientY - rect.top) * scaleY
                };
            }

            function startDraw(e) {
                isDrawing = true;
                points = [];
                const pos = getMousePos(e);
                points.push(pos);
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
            }

            function draw(e) {
                if(!isDrawing) return;
                e.preventDefault();
                const pos = getMousePos(e);
                points.push(pos);
                ctx.lineTo(pos.x, pos.y);
                ctx.clearRect(0, 0, lassoCanvas.width, lassoCanvas.height);
                
                ctx.beginPath();
                if(points.length > 0) {
                    ctx.moveTo(points[0].x, points[0].y);
                    for(let i=1; i<points.length; i++) ctx.lineTo(points[i].x, points[i].y);
                }
                ctx.stroke();
            }

            function endDraw(e) {
                if(!isDrawing) return;
                e.preventDefault();
                e.stopPropagation();
                isDrawing = false;
                ctx.closePath();
                ctx.stroke();
                performLassoCut(points);
                exitLassoMode();
            }

            lassoCanvas.addEventListener('mousedown', startDraw);
            lassoCanvas.addEventListener('mousemove', draw);
            lassoCanvas.addEventListener('mouseup', endDraw);
            
            lassoCanvas.addEventListener('touchstart', startDraw, {passive: false});
            lassoCanvas.addEventListener('touchmove', draw, {passive: false});
            lassoCanvas.addEventListener('touchend', endDraw);

            card.appendChild(lassoCanvas);
        }

        function performLassoCut(points) {
            if(!activeEl || points.length < 3) return;
            const sourceImg = activeEl.querySelector('img');
            if(!sourceImg) return;

            const oldEl = activeEl;
            const imgLeft = activeEl.offsetLeft;
            const imgTop = activeEl.offsetTop;
            const imgWidth = activeEl.offsetWidth;
            const imgHeight = activeEl.offsetHeight;

            const naturalWidth = sourceImg.naturalWidth || imgWidth;
            const naturalHeight = sourceImg.naturalHeight || imgHeight;
            const ratioX = naturalWidth / imgWidth;
            const ratioY = naturalHeight / imgHeight;

            const cornerX = imgLeft - (imgWidth / 2);
            const cornerY = imgTop - (imgHeight / 2);

            // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù€ bounding box Ù„Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ù‚ØµÙˆØµØ©
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            for(let i = 0; i < points.length; i++) {
                const px = (points[i].x - cornerX) * ratioX;
                const py = (points[i].y - cornerY) * ratioY;
                if(px < minX) minX = px;
                if(py < minY) minY = py;
                if(px > maxX) maxX = px;
                if(py > maxY) maxY = py;
            }

            const croppedWidth = Math.max(1, maxX - minX);
            const croppedHeight = Math.max(1, maxY - minY);

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = croppedWidth;
            tempCanvas.height = croppedHeight;
            const tCtx = tempCanvas.getContext('2d');

            tCtx.beginPath();
            const startX = (points[0].x - cornerX) * ratioX - minX;
            const startY = (points[0].y - cornerY) * ratioY - minY;

            tCtx.moveTo(startX, startY);
            for(let i=1; i<points.length; i++) {
                const px = (points[i].x - cornerX) * ratioX - minX;
                const py = (points[i].y - cornerY) * ratioY - minY;
                tCtx.lineTo(px, py);
            }
            tCtx.closePath();
            tCtx.clip();
            tCtx.drawImage(sourceImg, -minX, -minY, naturalWidth, naturalHeight);

            const newDataUrl = tempCanvas.toDataURL('image/png');
            
            const wrapper = createWrapper('image-layer');
            const contentWrapper = wrapper.querySelector('.content-wrapper');
            
            // Ø§Ø³ØªØ®Ø¯Ù… Ø­Ø¬Ù… Ø§Ù„Ù€ canvas Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ø­Ø³Ø§Ø¨ Ù†Ø³Ø¨ÙŠ
            const displayWidth = croppedWidth / ratioX;
            const displayHeight = croppedHeight / ratioY;
            
            wrapper.style.width = displayWidth + 'px';
            wrapper.style.height = displayHeight + 'px';
            wrapper.style.left = (imgLeft - imgWidth / 2 + minX / ratioX + displayWidth / 2) + 'px';
            wrapper.style.top = (imgTop - imgHeight / 2 + minY / ratioY + displayHeight / 2) + 'px';
            wrapper.style.transform = 'translate(-50%, -50%)';
            
            contentWrapper.style.width = '100%';
            contentWrapper.style.height = '100%';
            contentWrapper.style.display = 'flex';

            const newImg = document.createElement('img');
            newImg.src = newDataUrl;
            newImg.style.width = '100%';
            newImg.style.height = '100%';
            newImg.style.objectFit = 'fill';
            newImg.style.pointerEvents = 'none';

            contentWrapper.appendChild(newImg);
            document.getElementById('card').appendChild(wrapper);
            
            if(oldEl) oldEl.classList.remove('selected');
            
            setTimeout(() => {
                selectEl(wrapper);
                setupInteract(wrapper, 'box');
                saveState();
            }, 50);
        }

        function exitLassoMode() {
            lassoMode = false;
            if(updateToolButtons) updateToolButtons();
            document.getElementById('card').style.cursor = 'default';
            if(lassoCanvas) {
                lassoCanvas.remove();
                lassoCanvas = null;
            }
        }

        // --- Crop Tool Functions ---
        function toggleCropMode() {
            cropMode = !cropMode;
            const cropBtn = document.getElementById('btn-crop');
            
            if (cropMode) {
                // Disable other modes
                if (eraserMode) exitEraserMode();
                if (lassoMode) exitLassoMode();
                
                // Show crop overlay
                const overlay = document.getElementById('crop-overlay');
                overlay.classList.remove('hidden');
                
                // Initialize crop area
                const card = document.getElementById('card');
                const cardRect = card.getBoundingClientRect();
                const cardParentRect = document.getElementById('card-wrapper').getBoundingClientRect();
                
                // Set initial crop area (80% of card)
                const w = card.offsetWidth * 0.8;
                const h = card.offsetHeight * 0.8;
                const x = (card.offsetWidth - w) / 2;
                const y = (card.offsetHeight - h) / 2;
                
                const cropArea = document.getElementById('crop-area');
                cropArea.style.left = x + 'px';
                cropArea.style.top = y + 'px';
                cropArea.style.width = w + 'px';
                cropArea.style.height = h + 'px';
                
                cropStartX = x;
                cropStartY = y;
                cropStartWidth = w;
                cropStartHeight = h;
                
                // Attach event listeners
                attachCropEventListeners();
                
                // Update button style
                cropBtn.classList.add('bg-[#6366f1]', 'text-white');
                cropBtn.classList.remove('bg-[#f8fafc]', 'text-[#1e293b]');
            } else {
                exitCropMode();
            }
        }

        function attachCropEventListeners() {
            const cropArea = document.getElementById('crop-area');
            const handles = ['tl', 'tr', 'bl', 'br', 't', 'b', 'l', 'r'];
            const card = document.getElementById('card');
            
            // Make crop area draggable
            cropArea.addEventListener('mousedown', startDragCrop);
            cropArea.addEventListener('touchstart', startDragCrop, { passive: false });
            
            // Make handles draggable
            handles.forEach(handle => {
                const el = document.getElementById('crop-handle-' + handle);
                el.addEventListener('mousedown', (e) => startResizeCrop(e, handle));
                el.addEventListener('touchstart', (e) => startResizeCrop(e, handle), { passive: false });
            });
            
            function startDragCrop(e) {
                if (handles.some(h => e.target.id === 'crop-handle-' + h)) return; // Don't drag from handles
                isDraggingCrop = true;
                cropInitialX = e.touches ? e.touches[0].clientX : e.clientX;
                cropInitialY = e.touches ? e.touches[0].clientY : e.clientY;
                cropStartX = parseFloat(cropArea.style.left);
                cropStartY = parseFloat(cropArea.style.top);
                
                document.addEventListener('mousemove', dragCrop);
                document.addEventListener('touchmove', dragCrop, { passive: false });
                document.addEventListener('mouseup', stopDragCrop);
                document.addEventListener('touchend', stopDragCrop);
            }
            
            function dragCrop(e) {
                if (!isDraggingCrop) return;
                e.preventDefault();
                
                // Ø­Ø³Ø§Ø¨ Scale Ù„Ø¶Ù…Ø§Ù† Ø¯Ù‚Ø© Ø§Ù„Ø³Ø­Ø¨ Ù…Ø¹ Ø§Ù„ØªÙƒØ¨ÙŠØ±
                const zoomFactor = (window.currentZoom || 100) / 100;

                const currentX = e.touches ? e.touches[0].clientX : e.clientX;
                const currentY = e.touches ? e.touches[0].clientY : e.clientY;
                
                // Ù†Ù‚Ø³Ù… Ø§Ù„ÙØ±Ù‚ Ø¹Ù„Ù‰ Ù…Ø¹Ø§Ù…Ù„ Ø§Ù„ØªÙƒØ¨ÙŠØ± Ù„ØªØ­ÙˆÙŠÙ„ Ø­Ø±ÙƒØ© Ø§Ù„Ù…Ø§ÙˆØ³ (Ø¨ÙƒØ³Ù„ Ø´Ø§Ø´Ø©) Ø¥Ù„Ù‰ ÙˆØ­Ø¯Ø§Øª Ù…Ø­Ù„ÙŠØ©
                const deltaX = (currentX - cropInitialX) / zoomFactor;
                const deltaY = (currentY - cropInitialY) / zoomFactor;
                
                let newX = cropStartX + deltaX;
                let newY = cropStartY + deltaY;
                
                // Keep within bounds
                newX = Math.max(0, Math.min(newX, card.offsetWidth - cropArea.offsetWidth));
                newY = Math.max(0, Math.min(newY, card.offsetHeight - cropArea.offsetHeight));
                
                cropArea.style.left = newX + 'px';
                cropArea.style.top = newY + 'px';
                updateCropOverlay();
            }
            
            function stopDragCrop() {
                isDraggingCrop = false;
                document.removeEventListener('mousemove', dragCrop);
                document.removeEventListener('touchmove', dragCrop);
                document.removeEventListener('mouseup', stopDragCrop);
                document.removeEventListener('touchend', stopDragCrop);
            }
            
            function startResizeCrop(e, handle) {
                e.preventDefault();
                e.stopPropagation();
                draggedHandle = handle;
                cropInitialX = e.touches ? e.touches[0].clientX : e.clientX;
                cropInitialY = e.touches ? e.touches[0].clientY : e.clientY;
                cropStartX = parseFloat(cropArea.style.left);
                cropStartY = parseFloat(cropArea.style.top);
                cropStartWidth = cropArea.offsetWidth;
                cropStartHeight = cropArea.offsetHeight;
                
                document.addEventListener('mousemove', resizeCrop);
                document.addEventListener('touchmove', resizeCrop, { passive: false });
                document.addEventListener('mouseup', stopResizeCrop);
                document.addEventListener('touchend', stopResizeCrop);
            }
            
            function resizeCrop(e) {
                if (!draggedHandle) return;
                e.preventDefault();
                
                // Ø­Ø³Ø§Ø¨ Scale Ù„Ø¶Ù…Ø§Ù† Ø¯Ù‚Ø© Ø§Ù„ØªØ­Ø¬ÙŠÙ… Ù…Ø¹ Ø§Ù„ØªÙƒØ¨ÙŠØ±
                const zoomFactor = (window.currentZoom || 100) / 100;
                
                const currentX = e.touches ? e.touches[0].clientX : e.clientX;
                const currentY = e.touches ? e.touches[0].clientY : e.clientY;
                
                // ØªØµØ­ÙŠØ­ Ø§Ù„Ø­Ø±ÙƒØ© Ø¨Ù†Ø§Ø¡ Ø¹Ù„Ù‰ Ø§Ù„Ø²ÙˆÙˆÙ…
                const deltaX = (currentX - cropInitialX) / zoomFactor;
                const deltaY = (currentY - cropInitialY) / zoomFactor;
                
                let newX = cropStartX;
                let newY = cropStartY;
                let newW = cropStartWidth;
                let newH = cropStartHeight;
                
                // Handle different corner/edge resizes
                if (draggedHandle.includes('l')) {
                    newX = Math.max(0, cropStartX + deltaX);
                    newW = cropStartWidth - (newX - cropStartX);
                }
                if (draggedHandle.includes('r')) {
                    newW = Math.max(20, cropStartWidth + deltaX);
                }
                if (draggedHandle.includes('t')) {
                    newY = Math.max(0, cropStartY + deltaY);
                    newH = cropStartHeight - (newY - cropStartY);
                }
                if (draggedHandle.includes('b')) {
                    newH = Math.max(20, cropStartHeight + deltaY);
                }
                
                // Keep within bounds
                newW = Math.min(newW, card.offsetWidth - newX);
                newH = Math.min(newH, card.offsetHeight - newY);
                
                cropArea.style.left = newX + 'px';
                cropArea.style.top = newY + 'px';
                cropArea.style.width = newW + 'px';
                cropArea.style.height = newH + 'px';
                updateCropOverlay();
            }
            
            function stopResizeCrop() {
                draggedHandle = null;
                document.removeEventListener('mousemove', resizeCrop);
                document.removeEventListener('touchmove', resizeCrop);
                document.removeEventListener('mouseup', stopResizeCrop);
                document.removeEventListener('touchend', stopResizeCrop);
            }
        }

        function updateCropOverlay() {
            const cropArea = document.getElementById('crop-area');
            const cropOverlay = document.getElementById('crop-overlay');
            const card = document.getElementById('card');
            
            // Update dimensions display (optional - for visual feedback)
            const x = parseFloat(cropArea.style.left);
            const y = parseFloat(cropArea.style.top);
            const w = cropArea.offsetWidth;
            const h = cropArea.offsetHeight;
            
            // Store for applying later
            cropArea.dataset.x = x;
            cropArea.dataset.y = y;
            cropArea.dataset.w = w;
            cropArea.dataset.h = h;
        }

        // Format number with thousand separators
        function formatNumberWithSeparators(num) {
            return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
        }

        function applyCrop() {
            const cropArea = document.getElementById('crop-area');
            const card = document.getElementById('card');
            
            const x = parseFloat(cropArea.style.left);
            const y = parseFloat(cropArea.style.top);
            const w = cropArea.offsetWidth;
            const h = cropArea.offsetHeight;
            
            // Save current state
            saveState();
            
            // First: Snapshot element dimensions to pixels to prevent distortion
            const allElements = Array.from(card.querySelectorAll('.draggable-el'));
            
            allElements.forEach(el => {
                // Get current logical size in pixels
                const currentW = el.offsetWidth;
                const currentH = el.offsetHeight;
                
                // Freeze dimensions with !important to override CSS classes like .bg-image
                el.style.cssText += `width: ${currentW}px !important; height: ${currentH}px !important;`;
                
                // If it was a bg-image, it is no longer distinct from a normal image in terms of sizing
                // We should also remove the class that forces position to 0,0 if we want it to move
                if (el.classList.contains('bg-image')) {
                    el.classList.remove('bg-image');
                    el.classList.add('image-layer'); // Ensure it keeps base styling
                    
                    // We need to set its position explicitly because removing bg-image might reset it
                    // bg-image forced left:0, top:0.
                    // We want it to stay visually where it is (0,0 relative to OLD card).
                    el.style.left = '0px';
                    el.style.top = '0px';
                    // Reset transform because bg-image usually has none, but we might have added some
                    el.style.transform = 'none'; 
                }
            });

            // Second: Adjust all elements positions relative to crop area BEFORE changing card size
            const elementsToKeep = [];
            
            allElements.forEach(el => {
                // Use offsetLeft/Top which are in logical (unzoomed) pixels relative to the card
                // This fixes the issue where zoom level caused incorrect position calculations
                // NOTE: 'offsetLeft' returns the visual Left edge only if there's no transform shifting it.
                // Our elements have "transform: translate(-50%, -50%)" usually.
                // IF element has that transform, offsetLeft is roughly the Center X position.
                // IF element is bg-image (transform: none), offsetLeft is Left Edge.
                
                const hasCenterTransform = el.style.transform.includes('translate(-50%') || 
                                          getComputedStyle(el).transform !== 'none' && el.style.transform.includes('-50%');

                // We need the VISUAL bounding box relative to the card, in unzoomed CSS pixels.
                // Standard offsetLeft/Top logic:
                let visualX, visualY, visualW, visualH;
                
                // For bg-image (full width/height, no transform)
                if (el.classList.contains('bg-image')) {
                     visualX = 0; 
                     visualY = 0;
                     visualW = card.offsetWidth;
                     visualH = card.offsetHeight;
                } else {
                    // Start with offset positions (usually center if transformed)
                    let baseX = el.offsetLeft;
                    let baseY = el.offsetTop;
                    const wEl = el.offsetWidth;
                    const hEl = el.offsetHeight;
                    
                    if (hasCenterTransform) {
                        visualX = baseX - (wEl / 2);
                        visualY = baseY - (hEl / 2);
                    } else {
                        visualX = baseX;
                        visualY = baseY;
                    }
                    visualW = wEl;
                    visualH = hEl;
                }

                // Intersection Check (AABB)
                // Crop Box: x, y, w, h
                
                // Allow keeping if ANY part overlaps? Or mostly inside?
                // Let's use Overlap.
                const overlaps = (visualX < x + w) && (visualX + visualW > x) &&
                                 (visualY < y + h) && (visualY + visualH > y);
                                 
                if (overlaps) {
                    
                    // Adjust position to new coordinate system
                    // New Card 0,0 corresponds to Old Card x,y
                    
                    // If element was centered at (cx, cy) in old card.
                    // It should be centered at (cx - x, cy - y) in new card.
                    
                    // IF element relies on Left/Top as Center:
                    if (hasCenterTransform) {
                         const currentLeft = el.offsetLeft; // Center X in old
                         const currentTop = el.offsetTop;   // Center Y in old
                         
                         const newLeft = currentLeft - x;
                         const newTop = currentTop - y;
                         
                         el.style.left = newLeft + 'px';
                         el.style.top = newTop + 'px';
                    } 
                    else if (el.classList.contains('bg-image')) {
                        // Background image special case:
                        // It covers the whole old card.
                        // We want it to cover the new card (cropped view).
                        // BUT bg-image usually has "width: 100%, height: 100%".
                        // If we just leave it, it will shrink to fit the new small card (distorted or just cropped automatically).
                        // User expects "Crop" to act like a window.
                        // So we should probably convert it to a regular image OR adjust object-position?
                        
                        // If it's an <img> inside a div.
                        // If we want to maintain the specific visual crop:
                        // The easiest way for bg-image is to let it fail/reset since it's "Background".
                        // OR, if the user cropped the canvas, valid "bg-image" concepts implies it resizes.
                        // BUT "Lasso/Crop studio" implies cutting the image.
                        
                        // Let's assume typical elements for now.
                        // If it's bg-image, it auto-resizes.
                    }
                    else {
                        // Standard positioning (Left/Top corner)
                        const currentLeft = el.offsetLeft;
                        const currentTop = el.offsetTop;
                        
                        const newLeft = currentLeft - x;
                        const newTop = currentTop - y;
                        
                        el.style.left = newLeft + 'px';
                        el.style.top = newTop + 'px';
                    }
                    
                    elementsToKeep.push(el);
                }
            });
            
            // Remove elements that are outside crop area
            allElements.forEach(el => {
                if (!elementsToKeep.includes(el)) {
                    el.remove();
                }
            });
            
            // Update card dimensions using DPI_RATIO
            const customWidth = document.getElementById('custom-width');
            const customHeight = document.getElementById('custom-height');
            
            // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¨ÙƒØ³Ù„ Ø¥Ù„Ù‰ Ø³Ù†ØªÙŠÙ…ØªØ± (DPI_RATIO Ù‡Ùˆ Ø¨ÙƒØ³Ù„ Ù„ÙƒÙ„ Ø³Ù…ØŒ ÙˆÙ„ÙŠØ³ Ø¨ÙƒØ³Ù„ Ù„ÙƒÙ„ Ø¥Ù†Ø´)
            // DPI_RATIO = 118.11 px/cm
            const newWidthMM = w / DPI_RATIO;
            const newHeightMM = h / DPI_RATIO;
            
            customWidth.value = newWidthMM.toFixed(2);
            customHeight.value = newHeightMM.toFixed(2);
            
            // Apply new card size
            setCardSize(w, h);
            
            // Also adjust gradient overlay if exists
            const gradientOverlay = document.getElementById('card-gradient');
            if (gradientOverlay) {
                gradientOverlay.style.width = w + 'px';
                gradientOverlay.style.height = h + 'px';
            }
            
            exitCropMode();
            saveState();
        }

        function exitCropMode() {
            cropMode = false;
            const cropBtn = document.getElementById('btn-crop');
            cropBtn.classList.remove('bg-[#6366f1]', 'text-white');
            cropBtn.classList.add('bg-[#f8fafc]', 'text-[#1e293b]');
            
            const overlay = document.getElementById('crop-overlay');
            overlay.classList.add('hidden');
            
            document.getElementById('card').style.cursor = 'default';
        }

        // --- Hand Tool Functions ---
        function toggleHandMode() {
            handMode = !handMode;
            const handBtn = document.getElementById('btn-hand');
            const previewArea = document.querySelector('.preview-area');
            
            if (handMode) {
                // Disable other modes
                if (eraserMode) exitEraserMode();
                if (lassoMode) exitLassoMode();
                if (cropMode) exitCropMode();
                
                // Update button style
                handBtn.classList.add('bg-[#6366f1]', 'text-white');
                handBtn.classList.remove('bg-[#f8fafc]', 'text-[#1e293b]');
                
                // Change cursor
                previewArea.style.cursor = 'grab';
                
                // Add event listeners
                previewArea.addEventListener('mousedown', startHandDrag);
                previewArea.addEventListener('touchstart', startHandDrag, { passive: false });
            } else {
                exitHandMode();
            }
        }

        function startHandDrag(e) {
            if (!handMode) return;
            
            // Don't activate if clicking on elements inside card
            if (e.target.closest('.draggable-el')) return;
            
            e.preventDefault();
            isHandDragging = true;
            
            const previewArea = document.querySelector('.preview-area');
            previewArea.style.cursor = 'grabbing';
            
            handStartX = e.touches ? e.touches[0].clientX : e.clientX;
            handStartY = e.touches ? e.touches[0].clientY : e.clientY;
            handScrollLeft = previewArea.scrollLeft;
            handScrollTop = previewArea.scrollTop;
            
            document.addEventListener('mousemove', doHandDrag);
            document.addEventListener('touchmove', doHandDrag, { passive: false });
            document.addEventListener('mouseup', stopHandDrag);
            document.addEventListener('touchend', stopHandDrag);
        }

        function doHandDrag(e) {
            if (!isHandDragging) return;
            e.preventDefault();
            
            const previewArea = document.querySelector('.preview-area');
            const currentX = e.touches ? e.touches[0].clientX : e.clientX;
            const currentY = e.touches ? e.touches[0].clientY : e.clientY;
            
            const deltaX = currentX - handStartX;
            const deltaY = currentY - handStartY;
            
            previewArea.scrollLeft = handScrollLeft - deltaX;
            previewArea.scrollTop = handScrollTop - deltaY;
        }

        function stopHandDrag() {
            isHandDragging = false;
            
            const previewArea = document.querySelector('.preview-area');
            if (handMode) {
                previewArea.style.cursor = 'grab';
            }
            
            document.removeEventListener('mousemove', doHandDrag);
            document.removeEventListener('touchmove', doHandDrag);
            document.removeEventListener('mouseup', stopHandDrag);
            document.removeEventListener('touchend', stopHandDrag);
        }

        function exitHandMode() {
            handMode = false;
            isHandDragging = false;
            
            const handBtn = document.getElementById('btn-hand');
            if (handBtn) {
                handBtn.classList.remove('bg-[#6366f1]', 'text-white');
                handBtn.classList.add('bg-[#f8fafc]', 'text-[#1e293b]');
            }
            
            const previewArea = document.querySelector('.preview-area');
            previewArea.style.cursor = 'default';
            
            // Remove event listeners
            previewArea.removeEventListener('mousedown', startHandDrag);
            previewArea.removeEventListener('touchstart', startHandDrag);
        }

        function initEraserCanvas() {
            const card = document.getElementById('card');
            if(eraserCanvas) eraserCanvas.remove();
            eraserCanvas = document.createElement('canvas');
            eraserCanvas.width = card.offsetWidth;
            eraserCanvas.height = card.offsetHeight;
            eraserCanvas.style.position = 'absolute';
            eraserCanvas.style.top = '0';
            eraserCanvas.style.left = '0';
            eraserCanvas.style.cursor = 'crosshair';
            eraserCanvas.style.zIndex = '200';
            const ctx = eraserCanvas.getContext('2d', { willReadFrequently: true });
            let isDrawing = false;
            
            eraserCanvas.addEventListener('mousedown', startErasing);
            eraserCanvas.addEventListener('touchstart', startErasing, { passive: false });
            
            function startErasing(e) {
                e.preventDefault();
                const rect = eraserCanvas.getBoundingClientRect();
                const cardRect = card.getBoundingClientRect();
                const x = (e.touches ? e.touches[0].clientX : e.clientX) - cardRect.left;
                const y = (e.touches ? e.touches[0].clientY : e.clientY) - cardRect.top;
                
                if(magicMode) {
                    saveState();
                    magicErase(x, y, ctx);
                    return;
                }
                isDrawing = true;
                saveState();
                erase(x, y, ctx);
            }
            
            // Ø¯Ø§Ù„Ø© Ø§Ù„Ù…Ù…Ø­Ø§Ø© Ø§Ù„Ø³Ø­Ø±ÙŠØ© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© (Flood Fill)
            function magicErase(x, y, ctx) {
                const protectBg = document.getElementById('eraser-protect-bg').checked;
                const images = Array.from(card.querySelectorAll('.image-layer')).reverse();
                
                for (let imgLayer of images) {
                    if(protectBg && imgLayer.classList.contains('bg-image')) continue;
                    
                    const rect = imgLayer.getBoundingClientRect();
                    const cardRect = card.getBoundingClientRect();
                    const layerLeft = rect.left - cardRect.left;
                    const layerTop = rect.top - cardRect.top;
                    
                    const relX = Math.floor(x - layerLeft);
                    const relY = Math.floor(y - layerTop);
                    const width = rect.width;
                    const height = rect.height;
                    
                    // Check if click is inside this layer
                    if(relX >= 0 && relX < width && relY >= 0 && relY < height) {
                        const img = imgLayer.querySelector('img');
                        if(!img) continue;
                        
                        // Create or use existing canvas
                        if(!imgLayer.magicCanvas) {
                            imgLayer.magicCanvas = document.createElement('canvas');
                            imgLayer.magicCanvas.width = img.naturalWidth || width;
                            imgLayer.magicCanvas.height = img.naturalHeight || height;
                            const magicCtx = imgLayer.magicCanvas.getContext('2d');
                            magicCtx.drawImage(img, 0, 0, imgLayer.magicCanvas.width, imgLayer.magicCanvas.height);
                        }
                        
                        performFloodFill(imgLayer, relX, relY, width, height);
                        break;
                    }
                }
                
                function performFloodFill(imgLayer, clickX, clickY, displayWidth, displayHeight) {
                    const img = imgLayer.querySelector('img');
                    const canvas = imgLayer.magicCanvas;
                    const imgCtx = canvas.getContext('2d', { willReadFrequently: true });
                    const imageData = imgCtx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    
                    // Scale click position to image coordinates
                    const scaleX = canvas.width / displayWidth;
                    const scaleY = canvas.height / displayHeight;
                    const imgX = Math.floor(clickX * scaleX);
                    const imgY = Math.floor(clickY * scaleY);
                    
                    // Check bounds
                    if(imgX < 0 || imgX >= canvas.width || imgY < 0 || imgY >= canvas.height) return;
                    
                    const startIdx = (imgY * canvas.width + imgX) * 4;
                    const sr = data[startIdx];
                    const sg = data[startIdx + 1];
                    const sb = data[startIdx + 2];
                    const sa = data[startIdx + 3];
                    
                    if(sa === 0) return; // Clicked on transparent
                    
                    const tolerance = magicTolerance;
                    
                    function colorsMatch(r, g, b, a) {
                        if(a === 0) return false;
                        const dr = r - sr;
                        const dg = g - sg;
                        const db = b - sb;
                        return (Math.abs(dr) + Math.abs(dg) + Math.abs(db)) < (tolerance * 3 * 2.55);
                    }
                    
                    // Flood fill using queue
                    const queue = [startIdx];
                    const visited = new Set();
                    visited.add(startIdx);
                    
                    while(queue.length > 0) {
                        const idx = queue.shift();
                        data[idx + 3] = 0; // Make transparent
                        
                        const pixelIndex = idx / 4;
                        const px = pixelIndex % canvas.width;
                        const py = Math.floor(pixelIndex / canvas.width);
                        
                        // Check 4 neighbors
                        const neighbors = [
                            {x: px - 1, y: py},
                            {x: px + 1, y: py},
                            {x: px, y: py - 1},
                            {x: px, y: py + 1}
                        ];
                        
                        for(let neighbor of neighbors) {
                            if(neighbor.x >= 0 && neighbor.x < canvas.width && neighbor.y >= 0 && neighbor.y < canvas.height) {
                                const nIdx = (neighbor.y * canvas.width + neighbor.x) * 4;
                                if(!visited.has(nIdx)) {
                                    visited.add(nIdx);
                                    const nr = data[nIdx];
                                    const ng = data[nIdx + 1];
                                    const nb = data[nIdx + 2];
                                    const na = data[nIdx + 3];
                                    
                                    if(colorsMatch(nr, ng, nb, na)) {
                                        queue.push(nIdx);
                                    }
                                }
                            }
                        }
                    }
                    
                    imgCtx.putImageData(imageData, 0, 0);
                    img.src = canvas.toDataURL();
                }
            }
            
            function erase(x, y, ctx) {
                const protectBg = document.getElementById('eraser-protect-bg').checked;
                const images = card.querySelectorAll('.image-layer');
                images.forEach(imgLayer => {
                    if(protectBg && imgLayer.classList.contains('bg-image')) {
                        return;
                    }
                    const rect = imgLayer.getBoundingClientRect();
                    const cardRect = card.getBoundingClientRect();
                    const relX = rect.left - cardRect.left;
                    const relY = rect.top - cardRect.top;
                    const width = rect.width;
                    const height = rect.height;
                    if(x >= relX && x <= relX + width && y >= relY && y <= relY + height) {
                        const img = imgLayer.querySelector('img');
                        if(img && img.complete) {
                            // Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø¯Ù‚Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ© Ù„Ù„ØµÙˆØ±Ø©ØŒ Ù„Ø§ Ø§Ù„Ø¨ÙƒØ³Ù„ Ø§Ù„Ù…Ø¹Ø±ÙˆØ¶
                            const naturalWidth = img.naturalWidth || width;
                            const naturalHeight = img.naturalHeight || height;
                            
                            if(!imgLayer.canvas) {
                                imgLayer.canvas = document.createElement('canvas');
                                imgLayer.canvas.width = naturalWidth;
                                imgLayer.canvas.height = naturalHeight;
                                const imgCtx = imgLayer.canvas.getContext('2d');
                                imgCtx.drawImage(img, 0, 0, naturalWidth, naturalHeight);
                            }
                            
                            // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø¯Ù‚Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ©
                            const scaleX = naturalWidth / width;
                            const scaleY = naturalHeight / height;
                            const scaledX = (x - relX) * scaleX;
                            const scaledY = (y - relY) * scaleY;
                            const scaledSize = (eraserSize / 2) * Math.max(scaleX, scaleY);
                            
                            const imgCtx = imgLayer.canvas.getContext('2d');
                            imgCtx.globalCompositeOperation = 'destination-out';
                            imgCtx.shadowBlur = eraserSoftness * Math.max(scaleX, scaleY);
                            imgCtx.shadowColor = "black";
                            imgCtx.fillStyle = "black";
                            imgCtx.beginPath();
                            imgCtx.arc(scaledX, scaledY, scaledSize, 0, Math.PI * 2);
                            imgCtx.fill();
                            img.src = imgLayer.canvas.toDataURL();
                        }
                    }
                });
            }
            
            eraserCanvas.addEventListener('mousemove', (e) => {
                if(!isDrawing) return;
                const rect = eraserCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                erase(x, y, ctx);
            });
            
            eraserCanvas.addEventListener('touchmove', (e) => {
                if(!isDrawing) return;
                e.preventDefault();
                const rect = eraserCanvas.getBoundingClientRect();
                const x = e.touches[0].clientX - rect.left;
                const y = e.touches[0].clientY - rect.top;
                erase(x, y, ctx);
            });
            
            eraserCanvas.addEventListener('mouseup', () => { isDrawing = false; });
            eraserCanvas.addEventListener('touchend', () => { isDrawing = false; });
            
            card.appendChild(eraserCanvas);
        }

        document.addEventListener('DOMContentLoaded', () => {
            // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù‚ÙˆØ§Ù„Ø¨ Ù…Ù† GitHub Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø©
            loadTemplatesFromGitHub();
            
            const eraserSizeInput = document.getElementById('eraser-size');
            const eraserSoftnessInput = document.getElementById('eraser-softness');
            const magicToleranceInput = document.getElementById('magic-tolerance');
            
            if(eraserSizeInput) {
                eraserSizeInput.addEventListener('input', (e) => {
                    eraserSize = parseInt(e.target.value);
                    document.getElementById('eraser-size-display').textContent = eraserSize;
                });
            }
            if(eraserSoftnessInput) {
                eraserSoftnessInput.addEventListener('input', (e) => {
                    eraserSoftness = parseInt(e.target.value);
                    document.getElementById('eraser-softness-display').textContent = eraserSoftness;
                });
            }
            if(magicToleranceInput) {
                magicToleranceInput.addEventListener('input', (e) => {
                    magicTolerance = parseInt(e.target.value);
                    document.getElementById('magic-tolerance-display').textContent = magicTolerance;
                });
            }
            
            // Ø±Ø¨Ø· event listeners Ù„Ù„ØªØ¯Ø±Ø¬
            const color1Input = document.getElementById('gradient-color1');
            const color2Input = document.getElementById('gradient-color2');
            const opacityInput = document.getElementById('gradient-opacity');
            const directionInput = document.getElementById('gradient-direction');
            const opacityDisplay = document.getElementById('gradient-opacity-display');
            
            if(color1Input) color1Input.addEventListener('change', updateGradientPreview);
            if(color2Input) color2Input.addEventListener('change', updateGradientPreview);
            if(opacityInput) {
                opacityInput.addEventListener('input', (e) => {
                    opacityDisplay.textContent = e.target.value;
                    updateGradientPreview();
                });
            }
            if(directionInput) directionInput.addEventListener('change', updateGradientPreview);
        });

        function setupInteract(el, type) {
            if(el.hasAttribute('data-events-bound')) return;
            el.setAttribute('data-events-bound', 'true');
            
            el.addEventListener('click', function(e) {
                e.stopPropagation();
            });
            
            el.addEventListener('mousedown', startDrag);
            el.addEventListener('touchstart', startDrag, {passive: false});

            function startDrag(e) {
                // Fix for iOS delete button tap - Check this FIRST
                if(e.target.closest('.control-btn')) return;

                if(el.classList.contains('is-locked')) return;
                
                // === ØªØ¹Ø¯ÙŠÙ„: Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù…Ù‚Ø¨Ø¶ Ø§Ù„ØªØ­Ø±ÙŠÙƒ Ø£ÙˆÙ„Ø§Ù‹ ===
                const isMoveHandle = e.target.classList.contains('move-handle') || e.target.closest('.move-handle');

                if (!isMoveHandle) {
                    // Content editable check - simple return allows focus
                    if(e.target.isContentEditable || e.target.closest('.user-text')) {
                        selectEl(el);
                        if (e.type === 'touchstart') {
                            e.target.focus(); 
                        }
                        return;
                    }
                }
                // ============================================
                
                const isTouch = e.type === 'touchstart';
                const startX = isTouch ? e.touches[0].clientX : e.clientX;
                const startY = isTouch ? e.touches[0].clientY : e.clientY;
                
                if(e.target.classList.contains('handle')) {
                    handleResize(e, el, e.target, startX, startY);
                    return;
                }
                
                if(el.classList.contains('frame-layer') && e.target === el) {
                    selectEl(el);
                    return;
                }


                // === ØªØ¹Ø¯ÙŠÙ„ Ø¬Ø¯ÙŠØ¯: Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„ØªØ­Ø±ÙŠÙƒ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø¹Ù†ØµØ± Ù…Ø­Ø¯Ø¯Ø§Ù‹ Ù…Ø³Ø¨Ù‚Ø§Ù‹ ===
                // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù‚Ø¨Ø¶ ÙˆÙ„Ù… ÙŠÙƒÙ† Ø§Ù„Ø¹Ù†ØµØ± Ù…Ø­Ø¯Ø¯Ø§Ù‹ØŒ Ù†ÙƒØªÙÙŠ Ø¨Ø§Ù„ØªØ­Ø¯ÙŠØ¯ (Ù„Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ø®ØªÙŠØ§Ø±Ù‡ Ø£ÙˆÙ„Ø§Ù‹)
                if (!isMoveHandle && !el.classList.contains('selected')) {
                    selectEl(el);
                    return;
                }
                // Ø£Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…Ø­Ø¯Ø¯Ø§Ù‹ØŒ ÙØ³ÙŠØªÙ… ØªØ¬Ø§ÙˆØ² Ù‡Ø°Ø§ Ø§Ù„Ø´Ø±Ø· ÙˆØ§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„Ø³Ø­Ø¨ Ù…Ù† Ø£ÙŠ Ù…ÙƒØ§Ù† (Ø­Ù„ Ù„Ù…Ø´ÙƒÙ„Ø© Ø§Ø®ØªÙØ§Ø¡ Ø§Ù„Ù…Ù‚Ø¨Ø¶)
                // ============================================

                e.preventDefault(); 
                e.stopPropagation();
                
                selectEl(el);

                const startLeft = el.offsetLeft;
                const startTop = el.offsetTop;

                function onMove(ev) {
                    ev.preventDefault();
                    
                    // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø²ÙˆÙˆÙ… Ù„Ø¶Ù…Ø§Ù† Ø­Ø±ÙƒØ© Ù…ØªØ·Ø§Ø¨Ù‚Ø©
                    const zoomFactor = (window.currentZoom || 100) / 100;
                    
                    const cx = isTouch ? ev.touches[0].clientX : ev.clientX;
                    const cy = isTouch ? ev.touches[0].clientY : ev.clientY;

                    // ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ø¥Ø²Ø§Ø­Ø© Ø¹Ù„Ù‰ Ù…Ø¹Ø§Ù…Ù„ Ø§Ù„Ø²ÙˆÙˆÙ…
                    const dx = (cx - startX) / zoomFactor;
                    const dy = (cy - startY) / zoomFactor;

                    let newLeft = startLeft + dx;
                    let newTop = startTop + dy;

                    el.style.left = `${newLeft}px`;
                    el.style.top = `${newTop}px`;
                    
                    const currentRotate = parseFloat(el.getAttribute('data-rotate')) || 0;
                    el.style.transform = `translate(-50%, -50%) rotate(${currentRotate}deg)`;
                }

                function onUp() {
                    document.removeEventListener(isTouch ? 'touchmove' : 'mousemove', onMove);
                    document.removeEventListener(isTouch ? 'touchend' : 'mouseup', onUp);
                    saveState();
                }

                document.addEventListener(isTouch ? 'touchmove' : 'mousemove', onMove, {passive: false});
                document.addEventListener(isTouch ? 'touchend' : 'mouseup', onUp);
            }
        }

        function handleResize(e, el, handle, startX, startY) {
            const isTouch = e.type === 'touchstart';
            const startW = el.offsetWidth;
            const startH = el.offsetHeight;
            const startLeft = el.offsetLeft;
            const startTop = el.offsetTop;
            // Ø­ÙØ¸ Ø­Ø¬Ù… Ø§Ù„Ø®Ø· Ø¹Ù†Ø¯ Ø¨Ø¯Ø¡ Ø§Ù„Ø³Ø­Ø¨
            const startFontSize = parseFloat(window.getComputedStyle(el).fontSize);

            function onResize(ev) {
                ev.preventDefault();
                ev.stopPropagation();
                
                const cx = isTouch ? ev.touches[0].clientX : ev.clientX;
                const cy = isTouch ? ev.touches[0].clientY : ev.clientY;
                
                const dx = cx - startX;
                const dy = cy - startY;

                let newW = startW;
                let newH = startH;
                let newLeft = startLeft;
                let newTop = startTop;

                // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù‚Ø¨Ø¶
                if (handle.classList.contains('resize-n') || handle.classList.contains('resize-ne') || handle.classList.contains('resize-nw')) {
                    let potentialH = startH - dy;
                    newH = Math.max(20, potentialH);
                    newTop = startTop - (newH - startH) / 2;
                } else if (handle.classList.contains('resize-s') || handle.classList.contains('resize-se') || handle.classList.contains('resize-sw')) {
                    let potentialH = startH + dy;
                    newH = Math.max(20, potentialH);
                    newTop = startTop + (newH - startH) / 2;
                }

                if (handle.classList.contains('resize-e') || handle.classList.contains('resize-ne') || handle.classList.contains('resize-se')) {
                    let potentialW = startW + dx;
                    newW = Math.max(20, potentialW);
                    newLeft = startLeft + (newW - startW) / 2;
                } else if (handle.classList.contains('resize-nw') || handle.classList.contains('resize-sw')) { 
                    let potentialW = startW - dx;
                    newW = Math.max(20, potentialW);
                    newLeft = startLeft - (newW - startW) / 2;
                }

                // === ØªØ¹Ø¯ÙŠÙ„: Ù…Ù†Ø·Ù‚ Ø®Ø§Øµ Ù„Ù„Ù†ØµÙˆØµ ===
                if (el.classList.contains('text-layer')) {
                    // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø³Ø­Ø¨ Ù…Ù† Ø§Ù„Ø²ÙˆØ§ÙŠØ§ (ØªÙƒØ¨ÙŠØ±/ØªØµØºÙŠØ± ØªÙ†Ø§Ø³Ø¨ÙŠ)
                    if (handle.classList.contains('resize-ne') || handle.classList.contains('resize-se') || 
                        handle.classList.contains('resize-nw') || handle.classList.contains('resize-sw')) {
                        
                        // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù†Ø³Ø¨Ø© Ø§Ù„ØªØºÙŠØ± ÙÙŠ Ø§Ù„Ø§Ø±ØªÙØ§Ø¹ Ù„ØªØºÙŠÙŠØ± Ø­Ø¬Ù… Ø§Ù„Ø®Ø·
                        const ratio = newH / startH;
                        let newFS = startFontSize * ratio;
                        
                        // Ø­Ø¯ÙˆØ¯ Ø­Ø¬Ù… Ø§Ù„Ø®Ø·
                        if (newFS < 10) newFS = 10;
                        if (newFS > 300) newFS = 300;
                        
                        // ØªØ·Ø¨ÙŠÙ‚ Ø­Ø¬Ù… Ø§Ù„Ø®Ø· Ø§Ù„Ø¬Ø¯ÙŠØ¯
                        el.style.fontSize = newFS + 'px';
                        
                        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ù‚ÙˆÙ„ ÙˆØ§Ù„Ø£Ø±Ù‚Ø§Ù… ÙÙŠ Ø§Ù„Ù„ÙˆØ­Ø© (Ø¨Ø¯ÙˆÙ† Ø­ÙØ¸ Ø§Ù„Ø­Ø§Ù„Ø© ÙÙŠ ÙƒÙ„ Ø¥Ø·Ø§Ø±)
                        document.getElementById('font-size').value = parseInt(newFS);
                        document.getElementById('font-size-input').value = parseInt(newFS);
                        document.getElementById('top-font-size').value = parseInt(newFS);
                        document.getElementById('top-font-size-input').value = parseInt(newFS);
                        
                        // Ø¬Ø¹Ù„ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ ØªÙ„Ù‚Ø§Ø¦ÙŠØ© Ù„ØªÙ†Ø§Ø³Ø¨ Ø§Ù„Ù†Øµ
                        el.style.width = 'auto';
                        el.style.height = 'auto';
                        
                        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…ÙˆÙ‚Ø¹
                        el.style.left = newLeft + 'px';
                        el.style.top = newTop + 'px';
                        
                    } else {
                        // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø³Ø­Ø¨ Ù…Ù† Ø§Ù„Ø¬ÙˆØ§Ù†Ø¨ (ØªØºÙŠÙŠØ± Ø¹Ø±Ø¶ ÙÙ‚Ø· Ù„Ù„ØªØ¯ÙÙ‚)
                        if (handle.classList.contains('resize-e') || handle.classList.contains('resize-w')) {
                            el.style.width = newW + 'px';
                            el.style.height = 'auto';
                            el.style.left = newLeft + 'px';
                            el.style.top = newTop + 'px';
                        }
                    }
                } else {
                    // Ù„Ù„ÙƒØ§Ø¦Ù†Ø§Øª Ø§Ù„Ø£Ø®Ø±Ù‰ (ØµÙˆØ±ØŒ Ø¥Ø·Ø§Ø±Ø§Øª)
                    // Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ù†Ø³Ø¨Ø© Ø§Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø§Ø±ØªÙØ§Ø¹ Ø¹Ù†Ø¯ Ø§Ù„Ø³Ø­Ø¨ Ù…Ù† Ø§Ù„Ø²ÙˆØ§ÙŠØ§
                    if ((handle.classList.contains('resize-ne') || handle.classList.contains('resize-se') || 
                         handle.classList.contains('resize-nw') || handle.classList.contains('resize-sw')) && !e.shiftKey) {
                        
                        const aspectRatio = startW / startH;
                        const widthChangePct = Math.abs((newW - startW) / startW);
                        const heightChangePct = Math.abs((newH - startH) / startH);

                        if (widthChangePct > heightChangePct) {
                             // Ø§Ù„Ø¹Ø±Ø¶ Ù‡Ùˆ Ø§Ù„Ø£Ø³Ø§Ø³
                             newH = newW / aspectRatio;
                             
                             if (handle.classList.contains('resize-n') || handle.classList.contains('resize-ne') || handle.classList.contains('resize-nw')) {
                                newTop = startTop - (newH - startH) / 2;
                             } else {
                                newTop = startTop + (newH - startH) / 2;
                             }
                        } else {
                             // Ø§Ù„Ø§Ø±ØªÙØ§Ø¹ Ù‡Ùˆ Ø§Ù„Ø£Ø³Ø§Ø³
                             newW = newH * aspectRatio;

                             if (handle.classList.contains('resize-nw') || handle.classList.contains('resize-sw')) { 
                                newLeft = startLeft - (newW - startW) / 2;
                             } else { 
                                newLeft = startLeft + (newW - startW) / 2;
                             }
                        }
                    }

                    el.style.width = newW + 'px';
                    el.style.height = newH + 'px';
                    el.style.left = newLeft + 'px';
                    el.style.top = newTop + 'px';
                }
                
                updateControlsPosition(el);
            }

            function onUp() {
                document.removeEventListener(isTouch ? 'touchmove' : 'mousemove', onResize);
                document.removeEventListener(isTouch ? 'touchend' : 'mouseup', onUp);
                saveState();
            }

            document.addEventListener(isTouch ? 'touchmove' : 'mousemove', onResize, {passive: false});
            document.addEventListener(isTouch ? 'touchend' : 'mouseup', onUp);
        }

        let lastSelectionTime = 0;
        let lastSelectedElement = null; // Ù…ØªØºÙŠØ± Ù„ØªØªØ¨Ø¹ Ø¢Ø®Ø± Ø¹Ù†ØµØ± ØªÙ… ØªØ­Ø¯ÙŠØ¯Ù‡
        let mouseDownOnElement = null; // Ù…ØªØºÙŠØ± Ù„ØªØªØ¨Ø¹ Ø§Ù„Ø¹Ù†ØµØ± Ø§Ù„Ø°ÙŠ ØªÙ… Ø§Ù„Ø¶ØºØ· Ø¹Ù„ÙŠÙ‡
        
        function selectEl(el) {
            if (el) updateControlsPosition(el);
            if(activeEl) activeEl.classList.remove('selected');
            
            activeEl = el;
            activeEl.classList.add('selected');
            lastSelectionTime = Date.now();
            lastSelectedElement = el; 

            // Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ù†Ø§ÙØ°Ø© Ø§Ù„Ø¹Ø§Ø¦Ù…Ø© ÙˆØ²Ø± Ø§Ù„Ø¥ØºÙ„Ø§Ù‚ (Ù„Ù„Ù†ØµÙˆØµ ÙÙ‚Ø· Ø§Ù„Ø¢Ù†)
            const floatToolbar = document.getElementById('floating-context-toolbar');
            const closeFloatBtn = document.getElementById('close-floating-toolbar');
            
            if (el.classList.contains('image-layer') || el.classList.contains('frame-layer')) {
                 if(floatToolbar) floatToolbar.classList.add('hidden');
                 if(closeFloatBtn) closeFloatBtn.classList.add('hidden');
            } else {
                 if(floatToolbar) floatToolbar.classList.remove('hidden');
                 if(closeFloatBtn) closeFloatBtn.classList.remove('hidden');
            }

            const panel = document.getElementById('style-panel');
            panel.classList.remove('opacity-50', 'pointer-events-none');
            
            document.getElementById('quick-props').classList.remove('hidden');
            document.getElementById('quick-props').classList.add('active');
            // no-selection-msg ÙŠØ¨Ù‚Ù‰ Ø¸Ø§Ù‡Ø± Ø¯Ø§Ø¦Ù…Ø§Ù‹
            
            // ØªØ­Ø¯ÙŠØ« Ù‚ÙŠÙ…Ø© Ø§Ù„Ø´ÙØ§ÙÙŠØ©
            const currentOpacity = parseFloat(el.style.opacity) || 1;
            const opacityPercent = Math.round(currentOpacity * 100);
            document.getElementById('layer-opacity').value = opacityPercent;
            document.getElementById('opacity-value').textContent = opacityPercent + '%';

            document.getElementById('text-controls').classList.add('hidden');
            document.getElementById('frame-controls').classList.add('hidden');
            document.getElementById('frame-controls-toolbar').classList.add('hidden');
            document.getElementById('colorable-controls-toolbar').classList.add('hidden');
            document.getElementById('gradient-toggle-row').classList.add('hidden'); // Ø¥Ø®ÙØ§Ø¡ Ø²Ø± Ø§Ù„ØªØ¯Ø±Ø¬ Ù…Ø¨Ø¯Ø¦ÙŠØ§Ù‹
            
            document.getElementById('top-font-controls').classList.add('hidden');
            
            // Ø¥Ø®ÙØ§Ø¡ Ù‚Ø³Ù… Ù„ÙˆÙ† Ø§Ù„Ù†Øµ Ø§ÙØªØ±Ø§Ø¶ÙŠØ§Ù‹
            document.getElementById('text-color-section').classList.add('hidden');

            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªÙ„ÙˆÙŠÙ†
            if(el.getAttribute('data-colorable') === 'true') {
                document.getElementById('colorable-controls-toolbar').classList.remove('hidden');
                document.getElementById('colorable-controls-toolbar').classList.add('flex');
                // ØªØ­Ø¯ÙŠØ« Ù„ÙˆÙ† Ø§Ù„Ù€ input Ù…Ù† Ù„ÙˆÙ† Ø§Ù„Ø®Ù„ÙÙŠØ© Ø§Ù„Ø­Ø§Ù„ÙŠ
                const currentBg = el.style.backgroundColor;
                if(currentBg && currentBg !== 'transparent') {
                    document.getElementById('colorable-color').value = rgbToHex(currentBg);
                }
            }

            if(el.classList.contains('text-layer')) {
                document.getElementById('text-controls').classList.remove('hidden');
                document.getElementById('top-font-controls').classList.remove('hidden');
                document.getElementById('top-font-controls').classList.add('flex');
                document.getElementById('gradient-toggle-row').classList.remove('hidden'); // Ø¥Ø¸Ù‡Ø§Ø± Ø²Ø± Ø§Ù„ØªØ¯Ø±Ø¬ Ù„Ù„Ù†ØµÙˆØµ
                document.getElementById('gradient-toggle-row').classList.add('flex'); // Ø¥Ø¶Ø§ÙØ© flex Ù„Ù„Ø¹Ø±Ø¶ Ø§Ù„ØµØ­ÙŠØ­
                
                // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„ØªØ¯Ø±Ø¬ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù‡Ø°Ø§ Ø§Ù„Ù†Øµ Ø¨Ø§Ù„ØªØ­Ø¯ÙŠØ¯
                updateGradientUIState(el);
                
                // Ø¥Ø¸Ù‡Ø§Ø± Ù‚Ø³Ù… Ù„ÙˆÙ† Ø§Ù„Ù†Øµ ÙÙ‚Ø· Ù…Ø¹ Ø§Ù„Ù†ØµÙˆØµ
                document.getElementById('text-color-section').classList.remove('hidden');
                
                const fSize = parseInt(window.getComputedStyle(el).fontSize); // Use computed style for accuracy
                document.getElementById('font-size').value = fSize;
                document.getElementById('font-size-input').value = fSize;
                document.getElementById('top-font-size').value = fSize;
                document.getElementById('top-font-size-input').value = fSize;
                
                const fontFamily = el.style.fontFamily.replace(/"/g, "'");
                document.getElementById('font-family').value = fontFamily;
                document.getElementById('top-font-family').value = fontFamily;
                document.getElementById('quick-color').value = rgbToHex(el.style.color);
                
                // ØªØ­Ø¯ÙŠØ« Ù„ÙˆÙ† Ø§Ù„Ù†Øµ ÙÙŠ Ø§Ù„Ù†Ø§ÙØ°Ø© Ø§Ù„Ø¹Ø§Ø¦Ù…Ø©
                const textDiv = el.querySelector('.user-text');
                if (textDiv) {
                    const textColor = textDiv.style.color || el.style.color || '#1e293b';
                    document.getElementById('top-text-color').value = rgbToHex(textColor);
                }
                
                updateBoldButtonState();
            } else if(el.classList.contains('frame-layer')) {
                document.getElementById('frame-controls').classList.remove('hidden');
                document.getElementById('frame-controls-toolbar').classList.remove('hidden');
                document.getElementById('frame-controls-toolbar').classList.add('flex');
                const borderColor = el.style.borderColor || el.style.backgroundColor || '#334155';
                document.getElementById('border-color').value = rgbToHex(borderColor);
            }
        }

        // Ø¯Ø§Ù„Ø© ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„Ø¨ÙˆÙ„Ø¯
        function toggleBold() {
            if (!activeEl) return;
            const currentWeight = activeEl.style.fontWeight;
            const btn = document.getElementById('btn-bold');
            
            if (currentWeight === 'bold' || currentWeight === '700') {
                activeEl.style.fontWeight = 'normal';
                btn.classList.remove('bg-[#6366f1]', 'text-white');
                btn.classList.add('bg-white', 'text-[#1e293b]');
            } else {
                activeEl.style.fontWeight = 'bold';
                btn.classList.add('bg-[#6366f1]', 'text-white');
                btn.classList.remove('bg-white', 'text-[#1e293b]');
            }
            saveState();
        }

        // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø²Ø± Ø§Ù„Ø¨ÙˆÙ„Ø¯ Ø¹Ù†Ø¯ Ø§Ù„ØªØ­Ø¯ÙŠØ¯
        function updateBoldButtonState() {
            const btn = document.getElementById('btn-bold');
            if (!activeEl || !btn) return;
            const currentWeight = activeEl.style.fontWeight;
            if (currentWeight === 'bold' || currentWeight === '700') {
                btn.classList.add('bg-[#6366f1]', 'text-white');
                btn.classList.remove('bg-white', 'text-[#1e293b]');
            } else {
                btn.classList.remove('bg-[#6366f1]', 'text-white');
                btn.classList.add('bg-white', 'text-[#1e293b]');
            }
        }

        const SHEET_CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTiWBnSkPTGN8S3-QjqwSjpJicszKs2ZuwI40iPph2EWQhgz9F10c7LIjMwa_cdPJr40OoDmqZDbP5F/pub?output=csv";
        const CORS_PROXIES = [
            "https://cors-anywhere.herokuapp.com/",
            "https://api.allorigins.win/raw?url=",
            "https://thingproxy.freeboard.io/fetch/"
        ];
        
        let subscriptionData = {};
        
        async function loadSubscriptionData() {
            try {
                let response = null;
                let csvText = null;
                
                try {
                    response = await fetch(SHEET_CSV_URL, { mode: 'cors' });
                    if (response.ok) {
                        csvText = await response.text();
                    }
                } catch (e) {
                    // Ù„Ø§ Ø´ÙŠØ¡
                }
                
                if (!csvText) {
                    for (let proxy of CORS_PROXIES) {
                        try {
                            let proxyUrl = proxy + encodeURIComponent(SHEET_CSV_URL);
                            response = await fetch(proxyUrl);
                            if (response.ok) {
                                csvText = await response.text();
                                break;
                            }
                        } catch (e) {
                            continue;
                        }
                    }
                }
                
                if (csvText) {
                    parseCSVData(csvText);
                    return true;
                } else {
                    throw new Error('ÙØ´Ù„ Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª');
                }
            } catch (error) {
                return false;
            }
        }
        
        function parseCSVData(csvText) {
            try {
                const lines = csvText.trim().split('\n');
                if (lines.length < 2) return;
                
                const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
                
                const codeIndex = headers.findIndex(h => h.includes('code'));
                const nameIndex = headers.findIndex(h => h.includes('name'));
                const expiryIndex = headers.findIndex(h => h.includes('expiry'));
                
                for (let i = 1; i < lines.length; i++) {
                    if (!lines[i].trim()) continue;
                    
                    const cells = lines[i].split(',').map(c => c.trim());
                    if (codeIndex >= 0 && nameIndex >= 0 && expiryIndex >= 0) {
                        const code = cells[codeIndex];
                        const name = cells[nameIndex];
                        const expiryDate = cells[expiryIndex];
                        
                        if (code && name && expiryDate) {
                            subscriptionData[code] = {
                                name: name,
                                expiryDate: expiryDate
                            };
                        }
                    }
                }
            } catch (error) {
                // Ù„Ø§ Ø´ÙŠØ¡
            }
        }
        
        async function verifyCode() {
            const input = document.getElementById('login-code-input');
            const code = input.value.trim();
            const errorMsg = document.getElementById('login-error');
            const loginBtn = document.getElementById('login-btn');
            const loadingDiv = document.getElementById('login-loading');
            
            errorMsg.style.display = 'none';
            errorMsg.innerHTML = '';
            
            if (!code) {
                errorMsg.innerHTML = 'âš ï¸ Ø£Ø¯Ø®Ù„ Ø§Ù„ÙƒÙˆØ¯ Ù…Ù† ÙØ¶Ù„Ùƒ';
                errorMsg.style.display = 'block';
                return;
            }
            
            loginBtn.disabled = true;
            loadingDiv.style.display = 'block';
            
            try {
                if (Object.keys(subscriptionData).length === 0) {
                    const loaded = await loadSubscriptionData();
                    if (!loaded) {
                        errorMsg.innerHTML = 'âš ï¸ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª';
                        errorMsg.style.display = 'block';
                        throw new Error('ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª');
                    }
                }
                
                if (subscriptionData[code]) {
                    const userData = subscriptionData[code];
                    
                    let expiryDate = null;
                    const dateStr = userData.expiryDate.trim();
                    
                    if (dateStr.match(/^\d{2}-\d{2}-\d{4}$/)) {
                        const [day, month, year] = dateStr.split('-');
                        expiryDate = new Date(`${year}-${month}-${day}`);
                    }
                    else if (dateStr.match(/^\d{4}-\d{2}-\d{2}$/)) {
                        expiryDate = new Date(dateStr);
                    }
                    else if (dateStr.match(/^\d{2}\/\d{2}\/\d{4}$/)) {
                        expiryDate = new Date(dateStr);
                    }
                    
                    if (!expiryDate || isNaN(expiryDate.getTime())) {
                        errorMsg.innerHTML = `âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ§Ø±ÙŠØ® Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡`;
                        errorMsg.style.display = 'block';
                        throw new Error('ØªØ§Ø±ÙŠØ® ØºÙŠØ± ØµØ­ÙŠØ­');
                    }
                    
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    expiryDate.setHours(0, 0, 0, 0);
                    
                    if (expiryDate >= today) {
                        // Ø¥Ù†Ø´Ø§Ø¡ Session ID Ø¹Ø´ÙˆØ§Ø¦ÙŠ
                        const sessionId = 'session_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
                        
                        sessionStorage.setItem('studioName', userData.name);
                        sessionStorage.setItem('expiryDate', userData.expiryDate);
                        sessionStorage.setItem('sessionId', sessionId);
                        
                        updateStudioName(userData.name);
                        document.getElementById('login-overlay').style.display = 'none';
                        showWelcomeNotification(userData.name);
                    } else {
                        const formattedDate = expiryDate.toLocaleDateString('ar-SA');
                        errorMsg.innerHTML = `â° Ø§Ø´ØªØ±Ø§ÙƒÙƒ Ø§Ù†ØªÙ‡Ù‰ ÙÙŠ ${formattedDate}<br><small style="font-size: 12px; color: #94a3b8;">ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ Ù„ØªØ¬Ø¯ÙŠØ¯ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ</small>`;
                        errorMsg.style.display = 'block';
                    }
                } else {
                    errorMsg.innerHTML = 'âŒ Ø§Ù„ÙƒÙˆØ¯ ØºÙŠØ± ØµØ­ÙŠØ­';
                    errorMsg.style.display = 'block';
                }
            } catch (error) {
                errorMsg.innerHTML = 'âŒ Ø­Ø¯Ø« Ø®Ø·Ø£. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰';
                errorMsg.style.display = 'block';
            } finally {
                loginBtn.disabled = false;
                loadingDiv.style.display = 'none';
            }
        }
        
        // ØªØ­Ø¯ÙŠØ« Ø§Ø³Ù… Ø§Ù„Ø§Ø³ØªÙˆØ¯ÙŠÙˆ ÙÙŠ Ø§Ù„ØµÙØ­Ø©
        function updateStudioName(name) {
            document.title = `Ø£Ø³ØªÙˆØ¯ÙŠÙˆ ${name} | Studio`;
            const studioNameDisplay = document.getElementById('studio-name-display');
            if (studioNameDisplay) {
                studioNameDisplay.textContent = `Ø£Ø³ØªÙˆØ¯ÙŠÙˆ ${name}`;
            }
        }
        
        function showWelcomeNotification(name) {
            console.log(`Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ø£Ø³ØªÙˆØ¯ÙŠÙˆ ${name}`);
        }
        
        window.addEventListener('load', async () => {
            loadSubscriptionData();
        });

        function deselect(e) {
            if(e && (e.target.closest('.draggable-el') || e.target.closest('#style-panel') || e.target.closest('#floating-context-toolbar') || e.target.closest('select') || e.target.closest('input') || e.target.closest('.controls-row'))) return;

            if(activeEl) activeEl.classList.remove('selected');
            activeEl = null;

            // Ø¥Ø®ÙØ§Ø¡ Ø§Ù„Ù†Ø§ÙØ°Ø© Ø§Ù„Ø¹Ø§Ø¦Ù…Ø©
            const floatToolbar = document.getElementById('floating-context-toolbar');
            const closeFloatBtn = document.getElementById('close-floating-toolbar');
            if(floatToolbar) floatToolbar.classList.add('hidden');
            if(closeFloatBtn) closeFloatBtn.classList.add('hidden');
            
            document.getElementById('quick-props').classList.add('hidden');
            document.getElementById('quick-props').classList.remove('active');
            document.getElementById('text-controls').classList.add('hidden');
            document.getElementById('frame-controls').classList.add('hidden');
            document.getElementById('frame-controls-toolbar').classList.add('hidden');
            document.getElementById('colorable-controls-toolbar').classList.add('hidden');
            document.getElementById('gradient-toggle-row').classList.add('hidden');
            
            document.getElementById('top-font-controls').classList.add('hidden');
            document.getElementById('top-font-controls').classList.remove('flex');
            
            // no-selection-msg ÙŠØ¨Ù‚Ù‰ Ø¸Ø§Ù‡Ø± Ø¯Ø§Ø¦Ù…Ø§Ù‹
            
            // Ø¥Ø®ÙØ§Ø¡ Ø´Ø±ÙŠØ· Ø§Ù„ØªØ¯Ø±Ø¬ Ù„Ù„Ø¹Ù†Ø§ØµØ±
            const gradControls = document.getElementById('grad-controls');
            const btnGrad = document.getElementById('btn-grad');
            const elementGradInputs = document.getElementById('element-grad-inputs');
            const globalGradInputs = document.getElementById('global-grad-inputs');
            
            if(gradControls.classList.contains('active') && !elementGradInputs.classList.contains('hidden')) {
                // ÙƒØ§Ù† ÙÙŠ ÙˆØ¶Ø¹ ØªØ¯Ø±Ø¬ Ø§Ù„Ø¹Ù†ØµØ±ØŒ Ù†Ø¹ÙŠØ¯Ù‡ Ù„Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø¹Ø§Ù…
                elementGradInputs.classList.add('hidden');
                elementGradInputs.classList.remove('flex');
                globalGradInputs.classList.remove('hidden');
                globalGradInputs.classList.add('flex');
                
                // Ø¥Ø°Ø§ Ù…Ø§ ÙÙŠÙ‡ ØªØ¯Ø±Ø¬ Ø¹Ø§Ù… Ù…ÙØ¹Ù„ØŒ Ù†Ø®ÙÙŠ Ø§Ù„Ø´Ø±ÙŠØ· ÙƒØ§Ù…Ù„
                if(!hasGradient) {
                    gradControls.classList.remove('active');
                    btnGrad.classList.remove('bg-[#6366f1]', 'text-white');
                    btnGrad.classList.add('bg-[#f8fafc]', 'text-[#1e293b]');
                }
            }
        }
        
        // Ø¯Ø§Ù„Ø© Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªØ­Ø¯ÙŠØ¯ Ø¹Ù†Ø¯ Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø© Ù…Ø¨Ø§Ø´Ø±Ø©
        function deselectOnCard(e) {
            // Ø­Ù…Ø§ÙŠØ©: Ø¥Ø°Ø§ Ø¶ØºØ· Ø¹Ù„Ù‰ Ø¹Ù†ØµØ± ÙˆÙÙŠ Ø­Ø±ÙƒØ© Ù…Ù† Ø§Ù„Ù…Ø§ÙˆØ³ Ù„Ù„Ø£Ø³ÙÙ„ ÙˆÙ„Ù„Ø£Ø¹Ù„Ù‰
            // Ù†ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù€ event Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø¶ØºØ·Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰ Ø¹Ù„Ù‰ Ø¹Ù†ØµØ±
            const elementUnderClick = document.elementFromPoint(
                e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : 0),
                e.clientY || (e.touches && e.touches[0] ? e.touches[0].clientY : 0)
            );
            
            // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø¹Ù†ØµØ± ØªØ­Øª Ø§Ù„Ù…Ø¤Ø´Ø± Ù‡Ùˆ draggable-el Ø£Ùˆ Ø¨Ø¯Ø§Ø®Ù„Ù‡
            if(elementUnderClick && elementUnderClick.closest('.draggable-el')) return;
            
            // ÙÙ‚Ø· Ø¥Ø°Ø§ Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø© Ø§Ù„ÙØ§Ø±ØºØ© Ø£Ùˆ Ø§Ù„Ù€ gradient Ù…Ø¨Ø§Ø´Ø±Ø©
            if(e.target.id !== 'card' && e.target.id !== 'card-gradient') return;
            
            // Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªØ­Ø¯ÙŠØ¯
            if(activeEl) activeEl.classList.remove('selected');
            activeEl = null;
            
            // Ø¥Ø®ÙØ§Ø¡ Ø§Ù„Ù†Ø§ÙØ°Ø© Ø§Ù„Ø¹Ø§Ø¦Ù…Ø©
            const floatToolbar = document.getElementById('floating-context-toolbar');
            const closeFloatBtn = document.getElementById('close-floating-toolbar');
            if(floatToolbar) floatToolbar.classList.add('hidden');
            if(closeFloatBtn) closeFloatBtn.classList.add('hidden');

            document.getElementById('quick-props').classList.add('hidden');
            document.getElementById('quick-props').classList.remove('active');
            document.getElementById('text-controls').classList.add('hidden');
            document.getElementById('frame-controls').classList.add('hidden');
            document.getElementById('frame-controls-toolbar').classList.add('hidden');
            document.getElementById('colorable-controls-toolbar').classList.add('hidden');
            document.getElementById('gradient-toggle-row').classList.add('hidden');
            
            document.getElementById('top-font-controls').classList.add('hidden');
            document.getElementById('top-font-controls').classList.remove('flex');
            
            // Ø¥Ø®ÙØ§Ø¡ Ø´Ø±ÙŠØ· Ø§Ù„ØªØ¯Ø±Ø¬ Ù„Ù„Ø¹Ù†Ø§ØµØ±
            const gradControls = document.getElementById('grad-controls');
            const btnGrad = document.getElementById('btn-grad');
            const elementGradInputs = document.getElementById('element-grad-inputs');
            const globalGradInputs = document.getElementById('global-grad-inputs');
            
            if(gradControls && gradControls.classList.contains('active') && elementGradInputs && !elementGradInputs.classList.contains('hidden')) {
                // ÙƒØ§Ù† ÙÙŠ ÙˆØ¶Ø¹ ØªØ¯Ø±Ø¬ Ø§Ù„Ø¹Ù†ØµØ±ØŒ Ù†Ø¹ÙŠØ¯Ù‡ Ù„Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø¹Ø§Ù…
                elementGradInputs.classList.add('hidden');
                elementGradInputs.classList.remove('flex');
                globalGradInputs.classList.remove('hidden');
                globalGradInputs.classList.add('flex');
                
                // Ø¥Ø°Ø§ Ù…Ø§ ÙÙŠÙ‡ ØªØ¯Ø±Ø¬ Ø¹Ø§Ù… Ù…ÙØ¹Ù„ØŒ Ù†Ø®ÙÙŠ Ø§Ù„Ø´Ø±ÙŠØ· ÙƒØ§Ù…Ù„
                if(!hasGradient) {
                    gradControls.classList.remove('active');
                    btnGrad.classList.remove('bg-[#6366f1]', 'text-white');
                    btnGrad.classList.add('bg-[#f8fafc]', 'text-[#1e293b]');
                }
            }
        }

        function toggleLock(el) {
            el.classList.toggle('is-locked');
            if(el.classList.contains('is-locked')) {
                el.classList.remove('selected');
                if(activeEl === el) deselect();
            }
        }

        // Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø®Ø·ÙˆØ· Ø§Ù„Ù…Ø®ØµØµØ© Ø§Ù„Ù…Ø±ÙÙˆØ¹Ø©
        let customFonts = [];
        
        // Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø®Ø·ÙˆØ· Ø§Ù„Ù…ÙØ¶Ù„Ø© (ØªÙØ­ÙØ¸ ÙÙŠ localStorage)
        let favoriteFonts = JSON.parse(localStorage.getItem('dalal_fav_fonts') || '[]');
        
        // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ÙØ¶Ù„Ø© Ø¹Ù†Ø¯ Ø¨Ø¯Ø¡ Ø§Ù„ØªØ´ØºÙŠÙ„
        function loadFavoriteFonts() {
            const favGroup = document.getElementById('fav-fonts-group');
            if (!favGroup) return;
            
            favGroup.innerHTML = '';
            
            if (favoriteFonts.length > 0) {
                favGroup.style.display = '';
                favoriteFonts.forEach(font => {
                    const opt = document.createElement('option');
                    opt.value = font.value;
                    opt.textContent = 'â­ ' + font.name;
                    opt.style.color = '#f59e0b';
                    favGroup.appendChild(opt);
                });
            } else {
                favGroup.style.display = 'none';
            }
        }
        
        // Ø¥Ø¶Ø§ÙØ©/Ø¥Ø²Ø§Ù„Ø© Ø®Ø· Ù…Ù† Ø§Ù„Ù…ÙØ¶Ù„Ø©
        function toggleFavoriteFont() {
            const select = document.getElementById('top-font-family');
            const currentValue = select.value;
            const currentText = select.options[select.selectedIndex]?.textContent || '';
            
            if (!currentValue || currentValue === '__ADD_CUSTOM_FONT__') {
                showInfoModal('Ø§Ø®ØªØ± Ø®Ø·Ø§Ù‹ Ø£ÙˆÙ„Ø§Ù‹ Ù„Ø¥Ø¶Ø§ÙØªÙ‡ Ù„Ù„Ù…ÙØ¶Ù„Ø©', 'ØªÙ†Ø¨ÙŠÙ‡', 'âš ï¸');
                return;
            }
            
            const btn = document.getElementById('btn-fav-font');
            const existingIndex = favoriteFonts.findIndex(f => f.value === currentValue);
            
            if (existingIndex > -1) {
                // Ø¥Ø²Ø§Ù„Ø© Ù…Ù† Ø§Ù„Ù…ÙØ¶Ù„Ø©
                favoriteFonts.splice(existingIndex, 1);
                btn.textContent = 'â˜†';
                btn.classList.remove('text-[#f59e0b]', 'border-[#f59e0b]');
                btn.classList.add('text-[#94a3b8]');
                showInfoModal('ØªÙ… Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø®Ø· Ù…Ù† Ø§Ù„Ù…ÙØ¶Ù„Ø©', 'ØªÙ…', 'ğŸ—‘ï¸');
            } else {
                // Ø¥Ø¶Ø§ÙØ© Ù„Ù„Ù…ÙØ¶Ù„Ø©
                const cleanName = currentText.replace(/^â­\s*/, '').trim();
                favoriteFonts.push({ value: currentValue, name: cleanName });
                btn.textContent = 'â­';
                btn.classList.add('text-[#f59e0b]', 'border-[#f59e0b]');
                btn.classList.remove('text-[#94a3b8]');
                showInfoModal('ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø®Ø· Ù„Ù„Ù…ÙØ¶Ù„Ø© â­', 'ØªÙ…', 'â­');
            }
            
            // Ø­ÙØ¸ ÙÙŠ localStorage
            localStorage.setItem('dalal_fav_fonts', JSON.stringify(favoriteFonts));
            loadFavoriteFonts();
        }
        
        // ØªØ­Ø¯ÙŠØ« Ø²Ø± Ø§Ù„Ù…ÙØ¶Ù„Ø© Ø¹Ù†Ø¯ ØªØºÙŠÙŠØ± Ø§Ù„Ø®Ø·
        function updateFavoriteButton(fontValue) {
            const btn = document.getElementById('btn-fav-font');
            if (!btn) return;
            
            const isFav = favoriteFonts.some(f => f.value === fontValue);
            if (isFav) {
                btn.textContent = 'â­';
                btn.classList.add('text-[#f59e0b]', 'border-[#f59e0b]');
                btn.classList.remove('text-[#94a3b8]');
            } else {
                btn.textContent = 'â˜†';
                btn.classList.remove('text-[#f59e0b]', 'border-[#f59e0b]');
                btn.classList.add('text-[#94a3b8]');
            }
        }
        
        // Ø¯Ø§Ù„Ø© ØªØ·Ø¨ÙŠÙ‚ Ù„ÙˆÙ† Ø§Ù„Ù†Øµ Ù…Ø¨Ø§Ø´Ø±Ø©
        function applyTextColor(color) {
            if (!activeEl || !activeEl.classList.contains('text-layer')) return;
            
            const textDiv = activeEl.querySelector('.user-text');
            if (textDiv) {
                // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªØ¯Ø±Ø¬ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹
                textDiv.style.backgroundImage = '';
                textDiv.style.webkitBackgroundClip = '';
                textDiv.style.webkitTextFillColor = '';
                textDiv.style.backgroundClip = '';
                activeEl.removeAttribute('data-has-gradient');
                
                // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù„ÙˆÙ† Ø§Ù„Ø¬Ø¯ÙŠØ¯
                textDiv.style.color = color;
                activeEl.style.color = color;
                
                // ØªØ­Ø¯ÙŠØ« Ø­Ù‚Ù„ Ø§Ù„Ù„ÙˆÙ† Ø§Ù„Ø³Ø±ÙŠØ¹
                const quickColor = document.getElementById('quick-color');
                if (quickColor) quickColor.value = color;
                
                // Ø¥Ø¹Ø§Ø¯Ø© Ø²Ø± Ø§Ù„ØªØ¯Ø±Ø¬ Ù„Ø­Ø§Ù„ØªÙ‡ Ø§Ù„Ø·Ø¨ÙŠØ¹ÙŠØ©
                const btn = document.getElementById('btn-toggle-gradient');
                const settings = document.getElementById('floating-grad-settings');
                if (btn && settings) {
                    settings.classList.add('hidden');
                    settings.style.display = 'none';
                    btn.classList.remove('bg-indigo-100', 'text-indigo-700', 'border-indigo-300');
                    btn.classList.add('bg-[#f8fafc]', 'text-[#334155]');
                    btn.innerHTML = '<i class="fas fa-fill-drip text-[8px]"></i> ØªØ¯Ø±Ø¬';
                }
            }
            saveState();
        }
        
        function handleFontSelection(selectEl) {
            const val = selectEl.value;
            if (val === '__ADD_CUSTOM_FONT__') {
                // ÙØªØ­ Ù†Ø§ÙØ°Ø© Ø±ÙØ¹ Ø§Ù„Ø®Ø·
                document.getElementById('custom-font-input').click();
                // Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ù„Ù„Ø®Ø· Ø§Ù„Ø³Ø§Ø¨Ù‚
                setTimeout(() => {
                    if (activeEl) {
                        selectEl.value = activeEl.style.fontFamily || "'Cairo', sans-serif";
                    }
                }, 100);
            } else {
                updateStyle('fontFamily', val);
                updateFavoriteButton(val);
            }
        }
        
        async function handleCustomFontUpload(input) {
            if (!input.files || !input.files[0]) return;
            
            const file = input.files[0];
            const fontName = file.name.replace(/\.[^/.]+$/, "").replace(/[^a-zA-Z0-9\u0600-\u06FF]/g, '_');
            
            try {
                // Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù…Ù„Ù ÙˆØªØ­ÙˆÙŠÙ„Ù‡ Ù„Ù€ URL
                const fontUrl = URL.createObjectURL(file);
                
                // ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø· ÙÙŠ Ø§Ù„Ù…ØªØµÙØ­
                const newFont = new FontFace(fontName, `url(${fontUrl})`);
                await newFont.load();
                document.fonts.add(newFont);
                
                // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø®Ø· Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹
                if (!customFonts.includes(fontName)) {
                    customFonts.push(fontName);
                    
                    // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø®Ø· Ù„Ù‚ÙˆØ§Ø¦Ù… Ø§Ù„Ø®Ø·ÙˆØ·
                    const fontSelects = document.querySelectorAll('#top-font-family');
                    fontSelects.forEach(sel => {
                        // Ø¥ÙŠØ¬Ø§Ø¯ Ø®ÙŠØ§Ø± "Ø¥Ø¶Ø§ÙØ© Ø®Ø· Ù…Ø®ØµØµ" ÙˆØ¥Ø¯Ø±Ø§Ø¬ Ù‚Ø¨Ù„Ù‡
                        const addOption = sel.querySelector('option[value="__ADD_CUSTOM_FONT__"]');
                        const separator = addOption ? addOption.previousElementSibling : null;
                        
                        const newOption = document.createElement('option');
                        newOption.value = `'${fontName}', sans-serif`;
                        newOption.textContent = `âœ¨ ${fontName} (Ù…Ø®ØµØµ)`;
                        newOption.style.color = '#10b981';
                        newOption.style.fontWeight = 'bold';
                        
                        if (separator) {
                            sel.insertBefore(newOption, separator);
                        } else if (addOption) {
                            sel.insertBefore(newOption, addOption);
                        } else {
                            sel.appendChild(newOption);
                        }
                    });
                }
                
                // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø®Ø· Ø¹Ù„Ù‰ Ø§Ù„Ø¹Ù†ØµØ± Ø§Ù„Ù…Ø­Ø¯Ø¯
                if (activeEl) {
                    updateStyle('fontFamily', `'${fontName}', sans-serif`);
                    document.getElementById('top-font-family').value = `'${fontName}', sans-serif`;
                }
                
                showInfoModal(`ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø®Ø· "${fontName}" Ø¨Ù†Ø¬Ø§Ø­! ğŸ‰`, 'Ù†Ø¬Ø§Ø­', 'âœ…');
                
            } catch (error) {
                console.error('Error loading font:', error);
                showInfoModal('ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø®Ø·. ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ù„Ù ØµØ§Ù„Ø­.', 'Ø®Ø·Ø£', 'âŒ');
            }
            
            input.value = ''; // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø­Ù‚Ù„
        }
        
        function updateStyle(prop, val) {
            if(!activeEl) return;
            
            activeEl.style[prop] = val;
            
            if(prop === 'fontSize') {
                const numVal = parseInt(val);
                document.getElementById('font-size').value = numVal;
                document.getElementById('font-size-input').value = numVal;
                document.getElementById('top-font-size').value = numVal;
                document.getElementById('top-font-size-input').value = numVal;
            }
            
            if(prop === 'color' || prop === 'borderColor') {
                document.getElementById('quick-color').value = val;
                // Ù…Ø²Ø§Ù…Ù†Ø© Ù„ÙˆÙ† Ø§Ù„Ù†Øµ ÙÙŠ Ø§Ù„Ù†Ø§ÙØ°Ø© Ø§Ù„Ø¹Ø§Ø¦Ù…Ø©
                const topTextColor = document.getElementById('top-text-color');
                if (topTextColor) topTextColor.value = val;
                const surahLabel = activeEl.querySelector('.surah-label');
                if(surahLabel) surahLabel.style.color = val;
            }
            saveState();
        }
        
        // ========== Ø¯ÙˆØ§Ù„ ØªÙ„ÙˆÙŠÙ† Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªÙ„ÙˆÙŠÙ† ==========
        function updateColorableColor(color) {
            if(!activeEl || activeEl.getAttribute('data-colorable') !== 'true') return;
            
            const img = activeEl.querySelector('img');
            if(!img) return;
            
            // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ØµÙˆØ±Ø© ÙƒÙ€ mask ÙˆØ§Ù„Ø®Ù„ÙÙŠØ© ÙƒÙ„ÙˆÙ†
            const contentWrapper = activeEl.querySelector('.content-wrapper');
            if(contentWrapper) {
                contentWrapper.style.backgroundColor = color;
                contentWrapper.style.backgroundImage = 'none';
                contentWrapper.style.webkitMaskImage = `url(${img.src})`;
                contentWrapper.style.maskImage = `url(${img.src})`;
                contentWrapper.style.webkitMaskSize = 'contain';
                contentWrapper.style.maskSize = 'contain';
                contentWrapper.style.webkitMaskRepeat = 'no-repeat';
                contentWrapper.style.maskRepeat = 'no-repeat';
                contentWrapper.style.webkitMaskPosition = 'center';
                contentWrapper.style.maskPosition = 'center';
                img.style.opacity = '0';
            }
            saveState();
        }
        
        function updateColorableGradient() {
            // ÙÙ‚Ø· ØªØ­Ø¯ÙŠØ« preview - Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ÙØ¹Ù„ÙŠ Ø¹Ù†Ø¯ Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ Ø²Ø± ØªØ·Ø¨ÙŠÙ‚
        }
        
        function applyColorableGradient() {
            if(!activeEl || activeEl.getAttribute('data-colorable') !== 'true') return;
            
            const img = activeEl.querySelector('img');
            if(!img) return;
            
            const startColor = document.getElementById('colorable-grad-start').value;
            const endColor = document.getElementById('colorable-grad-end').value;
            
            // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ØµÙˆØ±Ø© ÙƒÙ€ mask ÙˆØ§Ù„ØªØ¯Ø±Ø¬ ÙƒØ®Ù„ÙÙŠØ©
            const contentWrapper = activeEl.querySelector('.content-wrapper');
            if(contentWrapper) {
                contentWrapper.style.backgroundImage = `linear-gradient(to top, ${startColor}, ${endColor})`;
                contentWrapper.style.backgroundColor = 'transparent';
                contentWrapper.style.webkitMaskImage = `url(${img.src})`;
                contentWrapper.style.maskImage = `url(${img.src})`;
                contentWrapper.style.webkitMaskSize = 'contain';
                contentWrapper.style.maskSize = 'contain';
                contentWrapper.style.webkitMaskRepeat = 'no-repeat';
                contentWrapper.style.maskRepeat = 'no-repeat';
                contentWrapper.style.webkitMaskPosition = 'center';
                contentWrapper.style.maskPosition = 'center';
                img.style.opacity = '0';
            }
            saveState();
        }
        
        function resetColorableColor() {
            if(!activeEl || activeEl.getAttribute('data-colorable') !== 'true') return;
            
            // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù„ÙˆÙ† ÙˆØ§Ù„ØªØ¯Ø±Ø¬ ÙˆØ¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØµÙˆØ±Ø©
            const contentWrapper = activeEl.querySelector('.content-wrapper');
            const img = activeEl.querySelector('img');
            
            if(contentWrapper) {
                contentWrapper.style.backgroundColor = 'transparent';
                contentWrapper.style.backgroundImage = 'none';
                contentWrapper.style.webkitMaskImage = 'none';
                contentWrapper.style.maskImage = 'none';
            }
            if(img) {
                img.style.opacity = '1';
            }
            saveState();
        }
        
        // Ø¯Ø§Ù„Ø© ØªØ­Ø¯ÙŠØ« Ø´ÙØ§ÙÙŠØ© Ø§Ù„Ø·Ø¨Ù‚Ø©
        function updateLayerOpacity(val) {
            if(!activeEl) return;
            const opacity = val / 100;
            activeEl.style.opacity = opacity;
            document.getElementById('opacity-value').textContent = val + '%';
            saveState();
        }

        // Ø¯Ø§Ù„Ø© Ø¹Ø±Ø¶ Ø§Ù„Ù†Ø§ÙØ°Ø© Ø§Ù„Ø¬Ù…ÙŠÙ„Ø©
        function showInfoModal(message, title = 'ØªÙ†Ø¨ÙŠÙ‡', icon = 'ğŸ’¡') {
            document.getElementById('info-modal-icon').textContent = icon;
            document.getElementById('info-modal-title').textContent = title;
            document.getElementById('info-modal-message').textContent = message;
            document.getElementById('info-modal').style.display = 'flex';
        }
        
        // Ø¯Ø§Ù„Ø© Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ù†Ø§ÙØ°Ø© Ø§Ù„Ø¬Ù…ÙŠÙ„Ø©
        function closeInfoModal() {
            document.getElementById('info-modal').style.display = 'none';
        }

        function removeEl(el) {
            el.remove();
            deselect();
            saveState();
        }
        
        function duplicateElement(el) {
            // Ø¹Ù…Ù„ Ù†Ø³Ø®Ø© Ù…Ù† Ø§Ù„Ø¹Ù†ØµØ±
            const clone = el.cloneNode(true);
            
            // ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ù†Ø³Ø®Ø© Ù‚Ù„ÙŠÙ„Ø§Ù‹ Ù„Ø¥Ø¸Ù‡Ø§Ø± Ø£Ù†Ù‡Ø§ Ø¬Ø¯ÙŠØ¯Ø©
            const currentLeft = parseFloat(el.style.left) || 0;
            const currentTop = parseFloat(el.style.top) || 0;
            clone.style.left = (currentLeft + 20) + 'px';
            clone.style.top = (currentTop + 20) + 'px';
            
            // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù†Ø³Ø®Ø© Ø¥Ù„Ù‰ Ø§Ù„Ù€ card
            const card = document.getElementById('card');
            card.appendChild(clone);
            
            // Ø¥Ø¹Ø§Ø¯Ø© ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø£Ø­Ø¯Ø§Ø« Ù„Ù„Ø¹Ù†ØµØ± Ø§Ù„Ø¬Ø¯ÙŠØ¯
            rebindEvents();
            
            // ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ØªØºÙŠÙŠØ±
            saveState();
        }
        
        function updateControlsPosition(el) {
            const angleDeg = parseFloat(el.getAttribute('data-rotate')) || 0;
            const angleRad = angleDeg * Math.PI / 180;
            
            const w = el.offsetWidth;
            const h = el.offsetHeight;
            
            // Visual Dimensions
            const cos = Math.abs(Math.cos(angleRad));
            const sin = Math.abs(Math.sin(angleRad));
            const vw = w * cos + h * sin;
            const vh = w * sin + h * cos;
            
            const buttons = [
                { el: el.querySelector('.delete-btn'), defaultX: -18 },
                { el: el.querySelector('.duplicate-btn'), defaultX: 28 },
                { el: el.querySelector('.rotate-btn'), defaultX: 74 },
                { el: el.querySelector('.layer-up-btn'), defaultX: 120 },
                { el: el.querySelector('.layer-down-btn'), defaultX: 166 }
            ];
            
            const btnRadius = 18;
            const btnCenterY_rel_top = -32; // -50 (top) + 18 (radius)
            
            const cosA = Math.cos(angleRad);
            const sinA = Math.sin(angleRad);

            buttons.forEach(item => {
                if(!item.el) return;
                
                const gx = -vw/2 + item.defaultX + btnRadius;
                const gy = -vh/2 + btnCenterY_rel_top;
                
                const lx = gx * cosA + gy * sinA;
                const ly = -gx * sinA + gy * cosA;
                
                item.el.style.left = `calc(50% + ${lx}px)`;
                item.el.style.top = `calc(50% + ${ly}px)`;
                item.el.style.bottom = 'auto';
                item.el.style.right = 'auto';
                item.el.style.transform = `translate(-50%, -50%) rotate(${-angleDeg}deg)`;
            });
            
            const moveHandle = el.querySelector('.move-handle');
            if(moveHandle) {
                const gx = 0;
                const gy = -vh/2 - 30; // -30 is center of handle (-50 top + 20 half height)
                
                const lx = gx * cosA + gy * sinA;
                const ly = -gx * sinA + gy * cosA;
                
                moveHandle.style.left = `calc(50% + ${lx}px)`;
                moveHandle.style.top = `calc(50% + ${ly}px)`;
                moveHandle.style.bottom = 'auto';
                moveHandle.style.right = 'auto';
                moveHandle.style.transform = `translate(-50%, -50%) rotate(${-angleDeg}deg)`;
            }
        }

        function rotateElement(el) {
            // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„ØªØ¯ÙˆÙŠØ± Ø§Ù„Ø­Ø§Ù„ÙŠ Ø£Ùˆ 0
            const currentRotate = parseFloat(el.getAttribute('data-rotate')) || 0;
            // Ø¥Ø¶Ø§ÙØ© 90 Ø¯Ø±Ø¬Ø©
            const newRotate = (currentRotate + 90) % 360;
            
            // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªØ¯ÙˆÙŠØ± Ù…Ø¹ Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„ØªÙ…Ø±ÙƒØ²
            el.style.transform = `translate(-50%, -50%) rotate(${newRotate}deg)`;
            el.setAttribute('data-rotate', newRotate);
            
            updateControlsPosition(el);
            
            // ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ØªØºÙŠÙŠØ±
            saveState();
        }
        
        // Ø¯Ø§Ù„Ø© Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø·Ø¨Ù‚Ø© Ù„Ù„Ø£Ù…Ø§Ù…
        function bringToFront(el) {
            if (!el) return;
            const card = document.getElementById('card');
            const layers = card.querySelectorAll('.draggable-el:not(.bg-image)');
            let maxZ = 30;
            layers.forEach(layer => {
                const z = parseInt(layer.style.zIndex) || 0;
                if (z > maxZ) maxZ = z;
            });
            el.style.zIndex = maxZ + 1;
            saveState();
        }
        
        // Ø¯Ø§Ù„Ø© Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø·Ø¨Ù‚Ø© Ù„Ù„Ø®Ù„Ù
        function sendToBack(el) {
            if (!el) return;
            const card = document.getElementById('card');
            const layers = card.querySelectorAll('.draggable-el:not(.bg-image)');
            let minZ = 30;
            layers.forEach(layer => {
                const z = parseInt(layer.style.zIndex) || 30;
                if (z < minZ) minZ = z;
            });
            el.style.zIndex = Math.max(1, minZ - 1);
            saveState();
        }
        
        function deleteActive() {
            if(activeEl) removeEl(activeEl);
        }

        // Ø¯Ø§Ù„Ø© Ù…Ø²Ø§Ù…Ù†Ø© Ø¥Ø¯Ø®Ø§Ù„Ø§Øª Ø§Ù„ØªØ¯Ø±Ø¬ Ø¨ÙŠÙ† Ø§Ù„Ù†Ø§ÙØ°Ø© Ø§Ù„Ø¹Ø§Ø¦Ù…Ø© ÙˆØ§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
        function syncGradientInputs(type, value) {
            if (type === 'start') {
                document.getElementById('grad-start-color').value = value;
            } else if (type === 'end') {
                document.getElementById('grad-end-color').value = value;
            } else if (type === 'angle') {
                document.getElementById('grad-angle').value = value;
            }
        }
        
        // Ø¯Ø§Ù„Ø© Ù…Ø²Ø§Ù…Ù†Ø© Ù…Ù† Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ù„Ù„Ù†Ø§ÙØ°Ø© Ø§Ù„Ø¹Ø§Ø¦Ù…Ø©
        function syncFloatGradientInputs(type, value) {
            const floatStart = document.getElementById('float-grad-start');
            const floatEnd = document.getElementById('float-grad-end');
            const floatAngle = document.getElementById('float-grad-angle');
            if (type === 'start' && floatStart) floatStart.value = value;
            else if (type === 'end' && floatEnd) floatEnd.value = value;
            else if (type === 'angle' && floatAngle) floatAngle.value = value;
        }

        function updateElementGradient() {
            if(!activeEl) return;
            
            const color1 = document.getElementById('grad-start-color').value;
            const color2 = document.getElementById('grad-end-color').value;
            const angle = document.getElementById('grad-angle').value;
            const opacityEl = document.getElementById('grad-opacity');
            const opacity = opacityEl ? opacityEl.value : '1';
            
            // Ù…Ø²Ø§Ù…Ù†Ø© Ù…Ø¹ Ø§Ù„Ù†Ø§ÙØ°Ø© Ø§Ù„Ø¹Ø§Ø¦Ù…Ø©
            syncFloatGradientInputs('start', color1);
            syncFloatGradientInputs('end', color2);
            syncFloatGradientInputs('angle', angle);
            
            // Helper to convert hex to rgba
            const hexToRgba = (hex, alpha) => {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            };

            const rgba1 = hexToRgba(color1, opacity);
            const rgba2 = hexToRgba(color2, opacity);
            
            const gradient = `linear-gradient(${angle}deg, ${rgba1}, ${rgba2})`;
            
            if(activeEl.classList.contains('text-layer')) {
                // Apply gradient ONLY to the inner text div, not the wrapper
                const textDiv = activeEl.querySelector('.user-text');
                if(textDiv) {
                    if (!activeEl.hasAttribute('data-has-gradient')) {
                        activeEl.setAttribute('data-prev-color', textDiv.style.color);
                    }
                    
                    textDiv.style.backgroundImage = gradient;
                    textDiv.style.webkitBackgroundClip = 'text';
                    textDiv.style.webkitTextFillColor = 'transparent';
                    textDiv.style.backgroundClip = 'text';
                    textDiv.style.color = 'transparent';
                    textDiv.style.display = 'inline-block'; // Important for clip to work
                    // ØªÙ… Ø¥Ø²Ø§Ù„Ø© pointerEvents: none Ù„Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„ØªØ¹Ø¯ÙŠÙ„
                    
                    // Reset wrapper styles to prevent controls glitch
                    activeEl.style.backgroundImage = '';
                    activeEl.style.webkitBackgroundClip = '';
                    activeEl.style.webkitTextFillColor = '';
                     // Keep wrapper color as transparent wasn't good for controls
                    activeEl.style.color = ''; 
                }
            } else if(activeEl.classList.contains('image-layer') && activeEl.querySelector('img')) {
                // Ù„Ù„ØµÙˆØ±: Ù„Ø§ Ù†Ø·Ø¨Ù‚ Ø§Ù„ØªØ¯Ø±Ø¬ Ù„Ø£Ù†Ù‡ Ù„Ø§ ÙŠØ¸Ù‡Ø± Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­
                // Ø§Ù„ØªØ¯Ø±Ø¬ Ù„Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªÙ„ÙˆÙŠÙ† ÙÙ‚Ø· ÙŠØªÙ… Ù…Ù† Ø´Ø±ÙŠØ· Ø£Ø¯ÙˆØ§ØªÙ‡Ø§ Ø§Ù„Ø®Ø§Øµ
                showInfoModal('Ø§Ù„ØªØ¯Ø±Ø¬ ØºÙŠØ± Ù…ØªØ§Ø­ Ù„Ù„ØµÙˆØ± Ø§Ù„Ø¹Ø§Ø¯ÙŠØ©. Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ¯Ø±Ø¬ Ø§Ù„Ø¹Ø§Ù… Ù…Ù† Ø£Ø¹Ù„Ù‰ Ø£Ùˆ Ø£Ø¶Ù Ø¹Ù†Ø§ØµØ± Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªÙ„ÙˆÙŠÙ† Ù…Ù† Ø§Ù„Ù…ÙƒØªØ¨Ø©.', 'ØªÙ†Ø¨ÙŠÙ‡', 'ğŸ’¡');
                return;
            } else {
                if (!activeEl.hasAttribute('data-has-gradient')) {
                     let bg = activeEl.style.backgroundColor;
                     // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø­ÙØ¸ Ø§Ù„Ù„ÙˆÙ† Ø§Ù„Ø£ØµÙ„ÙŠ Ø­ØªÙ‰ Ù„Ùˆ Ù„Ù… ÙŠÙƒÙ† Ù…Ø­Ø¯Ø¯Ø§Ù‹ ÙÙŠ style
                     if (!bg || bg === '') {
                         bg = window.getComputedStyle(activeEl).backgroundColor;
                     }
                     activeEl.setAttribute('data-prev-bg', bg);
                }
                activeEl.style.backgroundImage = gradient;
                activeEl.style.backgroundColor = 'transparent';
            }
            
            activeEl.setAttribute('data-has-gradient', 'true');
            activeEl.setAttribute('data-grad-start', color1);
            activeEl.setAttribute('data-grad-end', color2);
            activeEl.setAttribute('data-grad-angle', angle);
            activeEl.setAttribute('data-grad-opacity', opacity);
            saveState();
        }
        
        // Ø¯Ø§Ù„Ø© Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªØ¯Ø±Ø¬ Ù…Ù† Ø§Ù„Ù†Øµ
        function removeTextGradient() {
            if(!activeEl) return;
            
            if(activeEl.classList.contains('text-layer')) {
                const textDiv = activeEl.querySelector('.user-text');
                if(textDiv) {
                    textDiv.style.backgroundImage = 'none';
                    textDiv.style.webkitBackgroundClip = 'unset';
                    textDiv.style.webkitTextFillColor = 'unset';
                    textDiv.style.backgroundClip = 'unset';
                    
                    const prevColor = activeEl.getAttribute('data-prev-color');
                    textDiv.style.color = prevColor && prevColor !== 'transparent' ? prevColor : '#1e293b'; 
                    textDiv.style.display = 'block';
                }
            } else {
                activeEl.style.backgroundImage = 'none';
                
                const prevBg = activeEl.getAttribute('data-prev-bg');
                if (prevBg && prevBg !== 'transparent' && prevBg !== 'rgba(0, 0, 0, 0)') {
                    activeEl.style.backgroundColor = prevBg;
                } else {
                    // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ Ù„ÙˆÙ† Ù…Ø­ÙÙˆØ¸ØŒ Ù†Ø­Ø§ÙØ¸ Ø¹Ù„Ù‰ Ø§Ù„Ø´ÙØ§ÙÙŠØ© ÙÙ‚Ø· Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø¥Ø·Ø§Ø± Ø´ÙØ§ÙØ§Ù‹ Ø¨Ø§Ù„Ø£ØµÙ„
                    // ÙˆÙ„ÙƒÙ† Ù„ØªÙØ§Ø¯ÙŠ Ù…Ø´ÙƒÙ„Ø© Ø§Ù„Ø§Ø®ØªÙØ§Ø¡ØŒ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø¹Ù†ØµØ± Ø¥Ø·Ø§Ø±Ø§Ù‹ Ù„Ù‡ Ø­Ø¯ÙˆØ¯ØŒ ÙØ§Ù„Ø´ÙØ§ÙÙŠØ© Ù…Ù‚Ø¨ÙˆÙ„Ø©
                    // Ø£Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø´ÙƒÙ„Ø§Ù‹ (Ø¨Ø¯ÙˆÙ† Ø­Ø¯ÙˆØ¯ ØªÙ‚Ø±ÙŠØ¨Ø§Ù‹) ÙÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ù„Ù‡ Ù„ÙˆÙ†
                    const borderWidth = parseFloat(activeEl.style.borderWidth) || 0;
                    if (borderWidth > 0) {
                        activeEl.style.backgroundColor = 'transparent';
                    } else {
                         // Ø§ÙØªØ±Ø§Ø¶ÙŠ Ù„Ù„Ø£Ø´ÙƒØ§Ù„ Ø¥Ø°Ø§ ÙÙ‚Ø¯Ù†Ø§ Ø§Ù„Ù„ÙˆÙ†
                        activeEl.style.backgroundColor = '#6366f1'; 
                    }
                }
            }
            
            activeEl.removeAttribute('data-has-gradient');
            activeEl.removeAttribute('data-grad-start');
            activeEl.removeAttribute('data-grad-end');
            activeEl.removeAttribute('data-grad-angle');
            activeEl.removeAttribute('data-grad-opacity');
            // ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø³Ù…Ø§Øª Ø§Ù„Ù…Ø¤Ù‚ØªØ©
            activeEl.removeAttribute('data-prev-bg');
            activeEl.removeAttribute('data-prev-color');
            
            saveState();
        }

        function toggleGradient() {
            // Ù…Ù†Ø¹ ØªÙØ¹ÙŠÙ„ Ø§Ù„ØªØ¯Ø±Ø¬ Ø¹Ù„Ù‰ Ø§Ù„Ø®Ù„ÙÙŠØ© Ø¥Ø°Ø§ Ù„Ù… ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø¹Ù†ØµØ±
            if (!activeEl) {
                // Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ø¬Ù…ÙŠÙ„Ø© Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ø§Ù„ØªÙ†Ø¨ÙŠÙ‡ Ø§Ù„Ø¹Ø§Ø¯ÙŠ
                showInfoModal('ÙŠØ±Ø¬Ù‰ ØªØ­Ø¯ÙŠØ¯ Ø¹Ù†ØµØ± (Ø´ÙƒÙ„ Ø£Ùˆ Ù†Øµ) Ø£ÙˆÙ„Ø§Ù‹ Ù„ØªÙØ¹ÙŠÙ„ Ø§Ù„ØªØ¯Ø±Ø¬ Ø¹Ù„ÙŠÙ‡.', 'ØªÙ†Ø¨ÙŠÙ‡', 'ğŸ¨');
                return;
            }

            const controls = document.getElementById('grad-controls');
            const btn = document.getElementById('btn-grad');
            const globalInputs = document.getElementById('global-grad-inputs');
            const elementInputs = document.getElementById('element-grad-inputs');

            // Ù…Ù†Ø·Ù‚ ØªÙØ¹ÙŠÙ„ Ø§Ù„ØªØ¯Ø±Ø¬ Ù„Ù„Ø¹Ù†ØµØ± Ø§Ù„Ù…Ø­Ø¯Ø¯ ÙÙ‚Ø·
            // Ù†ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† ØªØ¯Ø±Ø¬ Ø§Ù„Ø¹Ù†ØµØ± Ù…ÙØ¹Ù„Ø§Ù‹ Ø­Ø§Ù„ÙŠØ§Ù‹
            const isShowingElementGrad = controls.classList.contains('active') && !elementInputs.classList.contains('hidden');
            
            if (isShowingElementGrad) {
                // Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ØªØ¯Ø±Ø¬
                controls.classList.remove('active');
                btn.classList.remove('bg-[#6366f1]', 'text-white');
                btn.classList.add('bg-[#f8fafc]', 'text-[#1e293b]');
                
                // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªØ¯Ø±Ø¬ Ø¹Ù†Ø¯ Ø§Ù„Ø¥ØºÙ„Ø§Ù‚
                removeTextGradient();
                
                // Ø¥Ø®ÙØ§Ø¡ Ù„ÙˆØ­Ø© Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ù†ØµØ± ÙˆØ¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ø¹Ø§Ù…Ø©
                elementInputs.classList.add('hidden');
                elementInputs.classList.remove('flex');
                globalInputs.classList.remove('hidden');
                globalInputs.classList.add('flex');
            } else {
                // ØªØ´ØºÙŠÙ„ Ø§Ù„ØªØ¯Ø±Ø¬
                controls.classList.add('active');
                btn.classList.remove('bg-[#f8fafc]', 'text-[#1e293b]');
                btn.classList.add('bg-[#6366f1]', 'text-white');
                
                // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¸Ù‡ÙˆØ± Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ù†ØµØ± ÙˆØ¥Ø®ÙØ§Ø¡ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø®Ù„ÙÙŠØ© (Global)
                globalInputs.classList.add('hidden');
                globalInputs.classList.remove('flex');
                elementInputs.classList.remove('hidden');
                elementInputs.classList.add('flex');
                
                // ØªØ·Ø¨ÙŠÙ‚ ØªØ¯Ø±Ø¬ Ø§ÙØªØ±Ø§Ø¶ÙŠ Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù„Ù„Ø¹Ù†ØµØ± ØªØ¯Ø±Ø¬
                if(!activeEl.hasAttribute('data-has-gradient')) {
                    updateElementGradient(); 
                }
            }
        }
        
        function updateGlobalGradient() {
            const grad = document.getElementById('card-gradient');
            if(!grad) return;
            
            const startColor = document.getElementById('global-grad-start').value;
            const endColor = document.getElementById('global-grad-end').value;
            const opacity = document.getElementById('global-grad-opacity').value;
            const height = document.getElementById('global-grad-height').value;
            
            // Helper to convert hex to rgba
            const hexToRgba = (hex, alpha) => {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            };

            // Apply gradient using the chosen colors and opacity
            // Using "to top" to match previous behavior (Bottom -> Top)
            // Color 1 is start (Bottom), Color 2 is end (Top)
            const c1 = hexToRgba(startColor, opacity);
            const c2 = hexToRgba(endColor, opacity);
            
            grad.style.background = `linear-gradient(to top, ${c1}, ${c2})`;
            grad.style.opacity = '1'; // Opacity is handled in rgba
            grad.style.height = height + '%';
        }

        function setCardBackgroundColor(color) {
            isTransparent = false;
            document.getElementById('card').style.backgroundColor = color;
            const preview = document.getElementById('bg-color-preview');
            if(preview) preview.style.backgroundColor = color;
            saveState();
        }

        function setCardTransparent() {
            isTransparent = true;
            document.getElementById('card').style.backgroundColor = 'transparent';
            saveState();
        }

        function setCardSize(w, h) {
            const card = document.getElementById('card');
            // ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù…Ù‚Ø§Ø³ Ø¨Ø¯Ù‚Ø© - Ø¨Ø¯ÙˆÙ† Ø£ÙŠ Ø§Ù†Ø¶ØºØ§Ø· Ø£Ùˆ ØªÙˆØ³Ø¹
            card.style.width = w + 'px';
            card.style.height = h + 'px';
            card.style.minWidth = w + 'px';
            card.style.maxWidth = w + 'px';
            card.style.minHeight = h + 'px';
            card.style.maxHeight = h + 'px';
            
            // Ø­ÙØ¸ Ø§Ù„Ù…Ù‚Ø§Ø³ ÙÙŠ data attribute Ù„Ù„Ø·Ø¨Ø§Ø¹Ø©
            card.setAttribute('data-card-width', w);
            card.setAttribute('data-card-height', h);
            
            // Ø­Ø³Ø§Ø¨ zoom ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„Ù„Ø¹Ø±Ø¶ ÙÙŠ Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø©
            const previewArea = document.querySelector('.preview-area');
            const maxWidth = previewArea.offsetWidth - 100; // Ù…Ø³Ø§Ø­Ø© Ø¥Ø¶Ø§ÙÙŠØ© Ù„Ù„Ù…Ø³Ø§Ø·Ø±
            const maxHeight = previewArea.offsetHeight - 100; // Ù…Ø³Ø§Ø­Ø© Ø¥Ø¶Ø§ÙÙŠØ© Ù„Ù„Ù…Ø³Ø§Ø·Ø±
            
            const zoomByWidth = (maxWidth / w) * 100;
            const zoomByHeight = (maxHeight / h) * 100;
            const autoZoom = Math.min(zoomByWidth, zoomByHeight, 200); // Ø­Ø¯ Ø£Ù‚ØµÙ‰ 200%
            
            // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù€ zoom Ø§Ù„Ø£Ù…Ø«Ù„
            const optimalZoom = Math.max(25, Math.min(autoZoom, 200));
            setCustomZoom(optimalZoom);
            
            // ØªØ­Ø¯ÙŠØ« Ø¹Ø±Ø¶ Ø§Ù„Ù…Ù‚Ø§Ø³ Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø§Ø´Ø©
            const displayEl = document.getElementById('size-display');
            if (displayEl) {
                const cmW = (w / DPI_RATIO).toFixed(2);
                const cmH = (h / DPI_RATIO).toFixed(2);
                displayEl.textContent = `${formatNumberWithSeparators(w)} Ã— ${formatNumberWithSeparators(h)} px (${cmW} Ã— ${cmH} Ø³Ù…)`;
            }

            // Ø±Ø³Ù… Ø§Ù„Ù…Ø³Ø·Ø±Ø©
            drawRulers(w, h);
        }
        
        // Ø¯Ø§Ù„Ø© Ø±Ø³Ù… Ø§Ù„Ù…Ø³Ø·Ø±Ø©
        function drawRulers(w, h) {
            const rulerH = document.getElementById('ruler-h');
            const rulerV = document.getElementById('ruler-v');
            
            if(!rulerH || !rulerV) return;

            rulerH.innerHTML = '';
            rulerV.innerHTML = '';

            const cmW = Math.ceil(w / DPI_RATIO);
            const cmH = Math.ceil(h / DPI_RATIO);

            // Horizontal Ruler
            for (let i = 0; i <= cmW; i++) {
                const leftPos = i * DPI_RATIO;
                if(leftPos > w) break;

                const tick = document.createElement('div');
                tick.className = 'tick';
                tick.style.left = leftPos + 'px';
                tick.style.bottom = '0';
                tick.style.width = '1px';
                tick.style.height = '100%';
                
                const num = document.createElement('span');
                num.className = 'tick-num';
                num.innerText = i;
                num.style.left = (leftPos + 4) + 'px'; // offset slightly
                num.style.bottom = '4px';

                rulerH.appendChild(tick);
                rulerH.appendChild(num);
            }

            // Vertical Ruler
            for (let i = 0; i <= cmH; i++) {
                const topPos = i * DPI_RATIO;
                if(topPos > h) break;

                const tick = document.createElement('div');
                tick.className = 'tick';
                tick.style.top = topPos + 'px';
                tick.style.left = '0';
                tick.style.height = '1px';
                tick.style.width = '100%';
                
                const num = document.createElement('span');
                num.className = 'tick-num';
                num.innerText = i;
                num.style.top = (topPos + 4) + 'px';
                num.style.left = '4px';

                rulerV.appendChild(tick);
                rulerV.appendChild(num);
            }
        }

        function setCustomZoom(zoomValue) {
            currentZoom = Math.max(25, Math.min(zoomValue, 200)); // Ø¨ÙŠÙ† 25% Ùˆ 200%
            const zoomDecimal = currentZoom / 100;
            
            document.documentElement.style.setProperty('--card-zoom', zoomDecimal);
            
            // ØªØ­Ø¯ÙŠØ« Ø¹Ø±Ø¶ Ø§Ù„Ù†Ø³Ø¨Ø©
            const displayEl = document.getElementById('zoom-display');
            if (displayEl) {
                displayEl.textContent = `${Math.round(currentZoom)}%`;
            }
            
            // ØªØ­Ø¯ÙŠØ« Ù‚ÙŠÙ…Ø© Ø§Ù„Ù€ slider
            const slider = document.getElementById('zoom-slider');
            if (slider) {
                slider.value = currentZoom;
            }
            
            saveState();
        }

        function applyCustomSizeSimple() {
            const wInput = document.getElementById('custom-width');
            const hInput = document.getElementById('custom-height');
            
            let widthCm = parseFloat(wInput.value);
            let heightCm = parseFloat(hInput.value);
            
            if (!widthCm || !heightCm || widthCm <= 0 || heightCm <= 0) {
                showInfoModal('Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ù‚ÙŠÙ… ØµØ­ÙŠØ­Ø© Ù„Ù„Ø¹Ø±Ø¶ ÙˆØ§Ù„Ø§Ø±ØªÙØ§Ø¹', 'ØªÙ†Ø¨ÙŠÙ‡', 'âš ï¸');
                return;
            }
            
            // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø³Ù†ØªÙŠÙ…ØªØ± Ø¥Ù„Ù‰ Ø¨ÙƒØ³Ù„ Ø¨Ø¯Ù‚Ø© (1 Ø³Ù… = 118.11 Ø¨ÙƒØ³Ù„ @ 300 DPI)
            const widthPx = Math.round(widthCm * DPI_RATIO);
            const heightPx = Math.round(heightCm * DPI_RATIO);
            
            // --- Ù…Ù†Ø·Ù‚ ØªØºÙŠÙŠØ± Ø­Ø¬Ù… Ø§Ù„Ù…Ø­ØªÙˆÙ‰ (Scaling) ---
            const card = document.getElementById('card');
            // Ù†Ø³ØªØ®Ø¯Ù… style.width ÙˆÙ†Ø²ÙŠÙ„ 'px' Ù„Ø£Ù†Ù‡ Ø£Ø¯Ù‚ØŒ Ø£Ùˆ Ù†Ø³ØªØ®Ø¯Ù… offsetWidth ÙƒØ¨Ø¯ÙŠÙ„
            let oldW = parseFloat(card.style.width) || card.offsetWidth;
            let oldH = parseFloat(card.style.height) || card.offsetHeight;
            
            // ØªØ¬Ù†Ø¨ Ø§Ù„Ù‚Ø³Ù…Ø© Ø¹Ù„Ù‰ ØµÙØ± Ø£Ùˆ Ø§Ù„Ù‚ÙŠÙ… ØºÙŠØ± Ø§Ù„Ù…Ù†Ø·Ù‚ÙŠØ©
            if (oldW && oldH && oldW > 0 && oldH > 0) {
                const scaleX = widthPx / oldW;
                const scaleY = heightPx / oldH;
                
                // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ÙØ±Ù‚ ØµØºÙŠØ±Ø§ Ø¬Ø¯Ø§Ù‹ØŒ Ù„Ø§ Ø¯Ø§Ø¹ÙŠ Ù„Ù„ØªØºÙŠÙŠØ±
                if (Math.abs(widthPx - oldW) > 1 || Math.abs(heightPx - oldH) > 1) {
                    
                    const elements = card.querySelectorAll('.draggable-el');
                    elements.forEach(el => {
                        if (el.classList.contains('bg-image')) return; // Ø§Ù„Ø®Ù„ÙÙŠØ§Øª ØªØªØºÙŠØ± ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
                        
                        // ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù…ÙˆÙ‚Ø¹ (Left, Top)
                        // Ù†Ø¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ style.left Ù„Ø£Ù†Ù‡ ÙŠÙ…Ø«Ù„ Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…Ø«Ø¨ØªØ© Ø¨Ù€ px
                        if (el.style.left) {
                            // ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù‚ÙŠÙ…Ø© Ù…Ù† px
                            const currentLeft = parseFloat(el.style.left);
                            if (!isNaN(currentLeft)) {
                                el.style.left = (currentLeft * scaleX) + 'px';
                            }
                        }
                        
                        if (el.style.top) {
                            const currentTop = parseFloat(el.style.top);
                            if (!isNaN(currentTop)) {
                                el.style.top = (currentTop * scaleY) + 'px';
                            }
                        }
                        
                        // ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø­Ø¬Ù… (Width, Height) Ø¥Ø°Ø§ ÙƒØ§Ù† Ø¨Ù€ px
                        if (el.style.width && el.style.width.endsWith('px')) {
                             const currentW = parseFloat(el.style.width);
                             if (!isNaN(currentW)) {
                                 el.style.width = (currentW * scaleX) + 'px';
                             }
                        }
                        
                        if (el.style.height && el.style.height.endsWith('px')) {
                             const currentH = parseFloat(el.style.height);
                             if (!isNaN(currentH)) {
                                 el.style.height = (currentH * scaleY) + 'px';
                             }
                        }
                        
                        // ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø®Ø·ÙˆØ· (Font Size)
                        if (el.style.fontSize && el.style.fontSize.endsWith('px')) {
                             const currentFS = parseFloat(el.style.fontSize);
                             if (!isNaN(currentFS)) {
                                 // Ù†Ø³ØªØ®Ø¯Ù… scaleX ÙƒÙ…Ù‚ÙŠØ§Ø³ Ø£Ø³Ø§Ø³ÙŠ Ù„Ù„Ù†Øµ Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ ØªÙ†Ø§Ø³Ù‚Ù‡
                                 el.style.fontSize = (currentFS * scaleX) + 'px';
                             }
                        }
                        
                        // ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø­Ø¯ÙˆØ¯ (Borders)
                        if (el.style.borderWidth && el.style.borderWidth.endsWith('px')) {
                             const currentBW = parseFloat(el.style.borderWidth);
                             if (!isNaN(currentBW)) {
                                 el.style.borderWidth = (currentBW * scaleX) + 'px';
                             }
                        }
                         if (el.style.borderRadius && el.style.borderRadius.endsWith('px')) {
                             const currentBR = parseFloat(el.style.borderRadius);
                             if (!isNaN(currentBR)) {
                                 el.style.borderRadius = (currentBR * scaleX) + 'px';
                             }
                        }
                    });
                }
            }
            // ----------------------------------------
            
            setCardSize(widthPx, heightPx);
            saveState();
        }
        
        function rgbToHex(rgb) {
            if(!rgb || rgb === 'transparent') return '#000000';
            if(rgb.startsWith('#')) return rgb;
            try {
                return '#' + rgb.match(/\d+/g).map(x => (+x).toString(16).padStart(2, '0')).join('');
            } catch(e) { return '#000000'; }
        }

        function downloadImage() {
            const img = document.getElementById('save-img');
            const link = document.createElement('a');
            link.href = img.src;
            // Generate random number for filename
            const randomNum = Math.floor(Math.random() * 1000000);
            link.download = `template_${randomNum}.png`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function printDesignDirect() {
            // Ø­ÙØ¸ Ø§Ù„ØªØµÙ…ÙŠÙ… ÙˆØ·Ø¨Ø§Ø¹ØªÙ‡ Ù†Ø¸ÙŠÙ Ø¨Ø¯ÙˆÙ† Ø®Ù„ÙÙŠØ©
            const card = document.getElementById('card');
            const originalBg = card.style.backgroundColor;
            
            // ØªØ¹ÙŠÙŠÙ† Ø®Ù„ÙÙŠØ© Ø´ÙØ§ÙØ© Ù…Ø¤Ù‚ØªØ§Ù‹
            card.style.backgroundColor = 'transparent';
            
            html2canvas(card, {
                scale: 2,
                allowTaint: true,
                useCORS: true,
                backgroundColor: null,
                logging: false
            }).then(canvas => {
                // Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø§Ù„Ù„ÙˆÙ† Ø§Ù„Ø£ØµÙ„ÙŠ
                card.style.backgroundColor = originalBg;
                
                const printWindow = window.open('', '', 'width=800,height=600');
                const img = canvas.toDataURL('image/png');
                
                printWindow.document.write(`
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <meta charset="UTF-8">
                        <title>Ø·Ø¨Ø§Ø¹Ø©</title>
                        <style>
                            * { margin: 0; padding: 0; }
                            @page { margin: 0; padding: 0; }
                            body { margin: 0; padding: 0; }
                            img { display: block; }
                        </style>
                    </head>
                    <body onload="print()">
                        <img src="${img}" style="width: 100%; height: auto;">
                    </body>
                    </html>
                `);
                
                printWindow.document.close();
            });
        }

        // ===== Ø¯ÙˆØ§Ù„ Ø§Ù„ØªØ­Ø¯ÙŠØ¯ ÙˆØ§Ù„Ø­Ø°Ù =====
        
        // ===== Ø¯ÙˆØ§Ù„ Ø§Ù„Ø§Ø³ØªÙŠØ±Ø§Ø¯ ÙˆØ§Ù„ØªØ­Ù…ÙŠÙ„ =====
        function exportTemplates() {
            const templates = getTemplates();
            if (templates.length === 0) {
                alert('âš ï¸ Ù„Ø§ ØªÙˆØ¬Ø¯ Ù‚ÙˆØ§Ù„Ø¨ Ù„ØªØ­Ù…ÙŠÙ„Ù‡Ø§!');
                return;
            }
            
            // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù JSON
            const dataStr = JSON.stringify(templates, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            // Ø¥Ù†Ø´Ø§Ø¡ Ø±Ø§Ø¨Ø· Ø§Ù„ØªØ­Ù…ÙŠÙ„
            const link = document.createElement('a');
            link.href = url;
            link.download = `templates_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            alert('âœ… ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù‚ÙˆØ§Ù„Ø¨ Ø¨Ù†Ø¬Ø§Ø­!');
        }
        
        function importTemplates() {
            // Ø¥Ù†Ø´Ø§Ø¡ input Ù„Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ù„Ù
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.style.display = 'none';
            
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        let importedTemplates = JSON.parse(event.target.result);
                        
                        // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø­Ø§Ù„Ø© Ø£Ù† ÙŠÙƒÙˆÙ† Ø§Ù„Ù…Ù„Ù ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙƒØ§Ø¦Ù† ÙˆØ§Ø­Ø¯ Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ù…ØµÙÙˆÙØ©
                        if (!Array.isArray(importedTemplates)) {
                            // Ø¥Ø°Ø§ ÙƒØ§Ù† ÙƒØ§Ø¦Ù† ÙˆØ§Ø­Ø¯ØŒ Ø­ÙˆÙ„Ù‡ Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ©
                            if (typeof importedTemplates === 'object' && importedTemplates !== null) {
                                // ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ÙƒØ§Ø¦Ù† ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø®Ø§ØµÙŠØ© "templates"
                                if (Array.isArray(importedTemplates.templates)) {
                                    importedTemplates = importedTemplates.templates;
                                } else {
                                    importedTemplates = [importedTemplates];
                                }
                            } else {
                                alert('âŒ ØµÙŠØºØ© Ø§Ù„Ù…Ù„Ù ØºÙŠØ± ØµØ­ÙŠØ­Ø©! ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ù…ØµÙÙˆÙØ© Ø£Ùˆ ÙƒØ§Ø¦Ù† ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ù…ØµÙÙˆÙØ©.');
                                return;
                            }
                        }
                        
                        // ÙÙ„ØªØ±Ø© Ø§Ù„Ù‚ÙˆØ§Ù„Ø¨ Ø§Ù„ÙØ§Ø±ØºØ© Ø£Ùˆ ØºÙŠØ± Ø§Ù„ØµØ­ÙŠØ­Ø©
                        importedTemplates = importedTemplates.filter(t => t && typeof t === 'object');
                        
                        if (importedTemplates.length === 0) {
                            alert('âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ù‚ÙˆØ§Ù„Ø¨ ØµØ­ÙŠØ­Ø© ÙÙŠ Ø§Ù„Ù…Ù„Ù!');
                            return;
                        }
                        
                        // Ø³Ø¤Ø§Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
                        const currentTemplates = getTemplates();
                        let message = `Ø³ÙŠØªÙ… Ø§Ø³ØªÙŠØ±Ø§Ø¯ ${importedTemplates.length} Ù‚Ø§Ù„Ø¨.\n\n`;
                        
                        if (currentTemplates.length > 0) {
                            message += 'Ù‡Ù„ ØªØ±ÙŠØ¯:\nâœ… Ø¯Ù…Ø¬ Ø§Ù„Ù‚ÙˆØ§Ù„Ø¨ Ù…Ø¹ Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯\nâŒ Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù‚ÙˆØ§Ù„Ø¨';
                            
                            if (confirm(message)) {
                                // Ø¯Ù…Ø¬
                                const merged = [...currentTemplates, ...importedTemplates];
                                // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªÙƒØ±Ø§Ø±Ø§Øª Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø§Ø³Ù…
                                const uniqueTemplates = [];
                                const seen = new Set();
                                merged.forEach(t => {
                                    if (!seen.has(t.name)) {
                                        seen.add(t.name);
                                        uniqueTemplates.push(t);
                                    }
                                });
                                
                                if (uniqueTemplates.length > MAX_TEMPLATES) {
                                    alert(`âš ï¸ Ø³ÙŠØªÙ… Ø­ÙØ¸ Ø£ÙˆÙ„ ${MAX_TEMPLATES} Ù‚Ø§Ù„Ø¨ ÙÙ‚Ø· (Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰)`);
                                    saveTemplates(uniqueTemplates.slice(0, MAX_TEMPLATES));
                                } else {
                                    saveTemplates(uniqueTemplates);
                                }
                            } else {
                                // Ø§Ø³ØªØ¨Ø¯Ø§Ù„
                                if (importedTemplates.length > MAX_TEMPLATES) {
                                    alert(`âš ï¸ Ø³ÙŠØªÙ… Ø­ÙØ¸ Ø£ÙˆÙ„ ${MAX_TEMPLATES} Ù‚Ø§Ù„Ø¨ ÙÙ‚Ø· (Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰)`);
                                    saveTemplates(importedTemplates.slice(0, MAX_TEMPLATES));
                                } else {
                                    saveTemplates(importedTemplates);
                                }
                            }
                        } else {
                            // Ù„Ø§ ØªÙˆØ¬Ø¯ Ù‚ÙˆØ§Ù„Ø¨ Ù…ÙˆØ¬ÙˆØ¯Ø©ØŒ Ø§Ø³ØªÙˆØ±Ø¯ Ù…Ø¨Ø§Ø´Ø±Ø©
                            if (importedTemplates.length > MAX_TEMPLATES) {
                                alert(`âš ï¸ Ø³ÙŠØªÙ… Ø­ÙØ¸ Ø£ÙˆÙ„ ${MAX_TEMPLATES} Ù‚Ø§Ù„Ø¨ ÙÙ‚Ø· (Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰)`);
                                saveTemplates(importedTemplates.slice(0, MAX_TEMPLATES));
                            } else {
                                saveTemplates(importedTemplates);
                            }
                        }
                        
                        alert(`âœ… ØªÙ… Ø§Ø³ØªÙŠØ±Ø§Ø¯ ${importedTemplates.length} Ù‚Ø§Ù„Ø¨ Ø¨Ù†Ø¬Ø§Ø­!`);
                    } catch(error) {
                        alert('âŒ Ø®Ø·Ø£ ÙÙŠ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù…Ù„Ù!\n' + error.message);
                        console.error('Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø®Ø·Ø£:', error);
                    }
                };
                
                reader.readAsText(file);
            };
            
            document.body.appendChild(input);
            input.click();
            document.body.removeChild(input);
        }

        // --- Ø¯ÙˆØ§Ù„ ÙØªØ­ Ø§Ù„Ù…Ù„ÙØ§Øª Universal File Handling ---
        function handleUniversalFile(input) {
            if (!input.files || !input.files[0]) return;
            const file = input.files[0];
            const fileType = file.name.split('.').pop().toLowerCase();

            // 1. Project Files (Template internal format)
            if (fileType === 'template' || fileType === 'json') {
                loadProjectFromFile(file);
                input.value = '';
                return;
            } 
            
            // 2. High-Res Formats (PDF, AI, EPS) - Try PDF Header detection
            if (fileType === 'pdf' || fileType === 'ai' || fileType === 'eps') {
                const fileReader = new FileReader();
                fileReader.onload = function() {
                    const typedarray = new Uint8Array(this.result);
                    // Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ù‚Ø±Ø§Ø¡Ø© ÙƒÙ…Ø³ØªÙ†Ø¯ PDF (Ù„Ø£Ù† AI Ùˆ EPS Ø§Ù„Ø­Ø¯ÙŠØ«Ø© ØªØ¯Ø¹Ù… PDF)
                    pdfjsLib.getDocument(typedarray).promise.then(function(pdf) {
                        tryOpenPdfContent(pdf);
                    }).catch(function(err) {
                        // Ø¥Ø°Ø§ ÙØ´Ù„ ÙƒÙ…Ø³ØªÙ†Ø¯ PDFØŒ Ø­Ø§ÙˆÙ„ ÙØªØ­Ù‡ ÙƒØµÙˆØ±Ø© Ø¹Ø§Ø¯ÙŠØ© (EPS/Imagine)
                        console.warn('PDF/AI render failed, falling back to image layer:', err);
                        addImageLayer(input);
                    });
                };
                fileReader.readAsArrayBuffer(file);
                input.value = '';
                return;
            }

            // 3. TIFF Files
            if (fileType === 'tif' || fileType === 'tiff') {
                openTifProject(file);
                input.value = '';
                return;
            }

            // 4. PSD (Warning Only)
            if(fileType === 'psd') {
                alert('ØªÙ†Ø¨ÙŠÙ‡: Ø³ÙŠØªÙ… ÙØªØ­ Ù…Ù„Ù PSD ÙƒØµÙˆØ±Ø© Ù…Ø¯Ù…Ø¬Ø© (Flattened). Ù„ØªØ­Ø±ÙŠØ± Ø§Ù„Ø·Ø¨Ù‚Ø§ØªØŒ ÙŠØ±Ø¬Ù‰ Ø­ÙØ¸Ù‡Ø§ ÙƒÙ…Ù„Ù PNG Ù…Ù†ÙØµÙ„ Ù„ÙƒÙ„ Ø·Ø¨Ù‚Ø©.');
            }

            // 5. Default: Open as Image Layer (SVG, PNG, JPG, WEBP, etc.)
            // SVG opens here "as is" which renders perfectly in browsers
            addImageLayer(input);
            input.value = '';
        }

        // Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„ÙØªØ­ Ù…Ø­ØªÙˆÙ‰ PDF/AI
        function tryOpenPdfContent(pdf) {
            pdf.getPage(1).then(function(page) {
                const scale = 3; // Ø¯Ù‚Ø© Ø¹Ø§Ù„ÙŠØ©
                const viewport = page.getViewport({scale: scale});
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.height = viewport.height;
                canvas.width = viewport.width;

                const renderContext = {
                    canvasContext: context,
                    viewport: viewport
                };
                const renderTask = page.render(renderContext);
                renderTask.promise.then(function () {
                    const dataUrl = canvas.toDataURL('image/png');
                    const origW = viewport.width / scale;
                    const origH = viewport.height / scale;
                    
                    // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†Ù‚Ø§Ø· (72 DPI) Ø¥Ù„Ù‰ Ø³Ù…
                    const widthCm = (origW / 72) * 2.54;
                    const heightCm = (origH / 72) * 2.54;

                    document.getElementById('custom-width').value = widthCm.toFixed(2);
                    document.getElementById('custom-height').value = heightCm.toFixed(2);
                    
                    const newAppW = Math.round(widthCm * DPI_RATIO);
                    const newAppH = Math.round(heightCm * DPI_RATIO);
                    setCardSize(newAppW, newAppH);

                    const card = document.getElementById('card');
                    // ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø© Ù„Ø¨Ø¯Ø¡ Ù…Ø´Ø±ÙˆØ¹ Ø¬Ø¯ÙŠØ¯
                    card.innerHTML = '<div id="card-gradient"></div>';
                    
                    // Ø¥Ø¶Ø§ÙØ© Ø§Ù„ØµÙˆØ±Ø© ÙƒØ·Ø¨Ù‚Ø© Ø®Ù„ÙÙŠØ© Ù…Ù‚ÙÙ„Ø©
                    const wrapper = document.createElement('div');
                    wrapper.className = 'draggable-el image-layer bg-image is-locked';
                    const img = document.createElement('img');
                    img.src = dataUrl;
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.objectFit = 'fill';
                    img.style.pointerEvents = 'none';
                    wrapper.appendChild(img);
                    
                    card.appendChild(wrapper);
                    setupInteract(wrapper, 'box');
                    
                    // Ø¥Ø®ÙØ§Ø¡ Ø§Ù„ØªØ¯Ø±Ø¬ Ø¹Ù†Ø¯ ØªØ­Ù…ÙŠÙ„ Ù…Ù„Ù Ø¬Ø¯ÙŠØ¯
                    hasGradient = false;
                    const grad = document.getElementById('card-gradient');
                    if(grad) grad.style.display = 'none';
                    
                    saveState();
                    alert('âœ… ØªÙ… ÙØªØ­ Ø§Ù„Ù…Ù„Ù Ø¨Ù†Ø¬Ø§Ø­ Ø¨Ø¬ÙˆØ¯Ø© Ø¹Ø§Ù„ÙŠØ©!');
                });
            });
        }

        function openPdfProject(file) {
             // Deprecated in favor of handleUniversalFile logic, but kept just in case
             // Logic moved to tryOpenPdfContent
        }

        function openTifProject(fileInputOrFile) {
            let file;
            if (fileInputOrFile instanceof File) {
                file = fileInputOrFile;
            } else if (fileInputOrFile.files && fileInputOrFile.files[0]) {
                file = fileInputOrFile.files[0];
            } else {
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const buffer = e.target.result;
                    const ifds = UTIF.decode(buffer);
                    if (ifds.length === 0) {
                        alert('âŒ ÙØ´Ù„ Ù‚Ø±Ø§Ø¡Ø© Ù…Ù„Ù TIF');
                        return;
                    }
                    
                    const ifd = ifds[0];
                    UTIF.decodeImage(buffer, ifd);
                    const rgba = UTIF.toRGBA8(ifd);
                    
                    let widthPx = ifd.width;
                    let heightPx = ifd.height;
                    let xRes = ifd.t282 ? (ifd.t282[0] / ifd.t282[1]) : 72;
                    let yRes = ifd.t283 ? (ifd.t283[0] / ifd.t283[1]) : 72;
                    let unit = ifd.t296 ? ifd.t296[0] : 2;
                    
                    let widthCm, heightCm;
                    if (unit === 3) {
                        widthCm = widthPx / xRes;
                        heightCm = heightPx / yRes;
                    } else {
                        widthCm = (widthPx / xRes) * 2.54;
                        heightCm = (heightPx / yRes) * 2.54;
                    }
                    
                    const newAppW = Math.round(widthCm * DPI_RATIO);
                    const newAppH = Math.round(heightCm * DPI_RATIO);
                    
                    document.getElementById('custom-width').value = widthCm.toFixed(2);
                    document.getElementById('custom-height').value = heightCm.toFixed(2);
                    
                    setCardSize(newAppW, newAppH);
                    
                    const cnv = document.createElement('canvas');
                    cnv.width = widthPx;
                    cnv.height = heightPx;
                    const ctx = cnv.getContext('2d');
                    const imgData = ctx.createImageData(widthPx, heightPx);
                    imgData.data.set(rgba);
                    ctx.putImageData(imgData, 0, 0);
                    
                    const dataUrl = cnv.toDataURL();
                    
                    const card = document.getElementById('card');
                    card.innerHTML = '<div id="card-gradient"></div>';
                    
                    // Ø¥Ø®ÙØ§Ø¡ Ø§Ù„ØªØ¯Ø±Ø¬
                    hasGradient = false;
                    
                    const wrapper = document.createElement('div');
                    wrapper.className = 'draggable-el image-layer bg-image is-locked';
                    const img = document.createElement('img');
                    img.src = dataUrl;
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.objectFit = 'fill';
                    img.style.pointerEvents = 'none';
                    wrapper.appendChild(img);
                    
                    card.appendChild(wrapper);
                    setupInteract(wrapper, 'box');
                    saveState();
                    alert('âœ… ØªÙ… ÙØªØ­ Ù…Ù„Ù TIF Ø¨Ù†Ø¬Ø§Ø­!');
                } catch(err) {
                    alert('âŒ Ø®Ø·Ø£ ÙÙŠ ÙØªØ­ Ù…Ù„Ù TIF: ' + err.message);
                }
            };
            reader.readAsArrayBuffer(file);
        }

        function addImageLayer(input) {
            if (input.files && input.files[0]) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'draggable-el image-layer bg-image is-locked';
                    const img = document.createElement('img');
                    img.crossOrigin = "anonymous";
                    img.src = e.target.result;
                    img.loading = "eager";
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.objectFit = 'cover';
                    img.style.pointerEvents = 'none';
                    wrapper.appendChild(img);
                    const card = document.getElementById('card');
                    const gradient = document.getElementById('card-gradient');
                    if(gradient && gradient.nextSibling) card.insertBefore(wrapper, gradient.nextSibling);
                    else card.appendChild(wrapper);
                    setupInteract(wrapper, 'box');
                    saveState();
                    alert('âœ… ØªÙ… ÙØªØ­ Ø§Ù„Ù…Ù„Ù Ø¨Ù†Ø¬Ø§Ø­!');
                };
                reader.readAsDataURL(input.files[0]);
                input.value = '';
            }
        }

        // ==========================================
        //  ÙˆØ¸Ø§Ø¦Ù Ø§Ù„Ù†Ø§ÙØ°Ø© Ø§Ù„Ø¹Ø§Ø¦Ù…Ø© (Ø¥ØºÙ„Ø§Ù‚ + Ø³Ø­Ø¨)
        // ==========================================
        function closeFloatingToolbar() {
            const toolbar = document.getElementById('floating-context-toolbar');
            if (toolbar) toolbar.classList.add('hidden');
            
            // Ø¥Ù„ØºØ§Ø¡ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø¹Ù†ØµØ± Ø§Ù„Ù†Ø´Ø·
            if (activeEl) {
                activeEl.classList.remove('selected');
                activeEl.querySelectorAll('.resize-handle').forEach(h => h.style.display = 'none');
                activeEl = null;
                
                // Ø¥Ø®ÙØ§Ø¡ Ù„ÙˆØ­Ø© Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠØ©
                document.getElementById('style-panel').classList.remove('open');
            }
        }

        // Ø¯Ø§Ù„Ø© ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„ØªØ¯Ø±Ø¬ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø¹Ù†ØµØ± Ø§Ù„Ù…Ø­Ø¯Ø¯
        function updateGradientUIState(el) {
            const settings = document.getElementById('floating-grad-settings');
            const btn = document.getElementById('btn-toggle-gradient');
            if (!settings || !btn) return;
            
            // ÙØ­Øµ Ù‡Ù„ Ø§Ù„Ø¹Ù†ØµØ± Ù„Ù‡ ØªØ¯Ø±Ø¬ Ù…ÙØ¹Ù„
            const hasGradient = el && el.hasAttribute('data-has-gradient');
            
            if (hasGradient) {
                // Ø§Ù„Ø¹Ù†ØµØ± Ù„Ù‡ ØªØ¯Ø±Ø¬ - Ø¥Ø¸Ù‡Ø§Ø± Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ¯Ø±Ø¬ ÙˆØªØ­Ø¯ÙŠØ« Ø§Ù„Ø£Ù„ÙˆØ§Ù†
                settings.classList.remove('hidden');
                settings.style.display = 'flex';
                btn.classList.add('bg-indigo-100', 'text-indigo-700', 'border-indigo-300');
                btn.classList.remove('bg-[#f8fafc]', 'text-[#334155]');
                btn.innerHTML = '<i class="fas fa-fill-drip"></i> Ø¥Ù„ØºØ§Ø¡ ØªØ¯Ø±Ø¬ Ø§Ù„Ù†Øµ';
                
                // ØªØ­Ø¯ÙŠØ« Ø£Ù„ÙˆØ§Ù† Ø§Ù„ØªØ¯Ø±Ø¬ Ù…Ù† Ø§Ù„Ø¹Ù†ØµØ±
                const gradStart = el.getAttribute('data-grad-start') || '#6366f1';
                const gradEnd = el.getAttribute('data-grad-end') || '#ec4899';
                const gradAngle = el.getAttribute('data-grad-angle') || '90';
                document.getElementById('grad-start-color').value = gradStart;
                document.getElementById('grad-end-color').value = gradEnd;
                document.getElementById('grad-angle').value = gradAngle;
            } else {
                // Ø§Ù„Ø¹Ù†ØµØ± Ù„ÙŠØ³ Ù„Ù‡ ØªØ¯Ø±Ø¬ - Ø¥Ø®ÙØ§Ø¡ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ÙˆØ¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø²Ø± Ù„Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
                settings.classList.add('hidden');
                settings.style.display = 'none';
                btn.classList.remove('bg-indigo-100', 'text-indigo-700', 'border-indigo-300');
                btn.classList.add('bg-[#f8fafc]', 'text-[#334155]');
                btn.innerHTML = '<i class="fas fa-fill-drip"></i> ØªØ¯Ø±Ø¬ Ø§Ù„Ù†Øµ';
                
                // Ø¥Ø¹Ø§Ø¯Ø© Ø£Ù„ÙˆØ§Ù† Ø§Ù„ØªØ¯Ø±Ø¬ Ù„Ù„Ù‚ÙŠÙ… Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
                document.getElementById('grad-start-color').value = '#6366f1';
                document.getElementById('grad-end-color').value = '#ec4899';
                document.getElementById('grad-angle').value = '90';
            }
        }

        // Ø¯Ø§Ù„Ø© ØªÙØ¹ÙŠÙ„/Ø¥Ù„ØºØ§Ø¡ ÙˆØ¶Ø¹ Ø§Ù„ØªØ¯Ø±Ø¬ Ù…Ù† Ø§Ù„Ù†Ø§ÙØ°Ø© Ø§Ù„Ø¹Ø§Ø¦Ù…Ø©
        function toggleGradientMode() {
            const settings = document.getElementById('floating-grad-settings');
            const btn = document.getElementById('btn-toggle-gradient');
            
            if (settings.classList.contains('hidden')) {
                // ØªÙØ¹ÙŠÙ„ Ø§Ù„ØªØ¯Ø±Ø¬
                settings.classList.remove('hidden');
                settings.style.display = 'flex';
                btn.classList.add('bg-indigo-100', 'text-indigo-700', 'border-indigo-300');
                btn.classList.remove('bg-[#f8fafc]', 'text-[#334155]');
                btn.innerHTML = '<i class="fas fa-fill-drip"></i> Ø¥Ù„ØºØ§Ø¡ ØªØ¯Ø±Ø¬ Ø§Ù„Ù†Øµ';
                
                // ØªØ·Ø¨ÙŠÙ‚ ØªØ¯Ø±Ø¬ Ø§ÙØªØ±Ø§Ø¶ÙŠ Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹
                updateElementGradient();
            } else {
                // Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªØ¯Ø±Ø¬
                settings.classList.add('hidden');
                settings.style.display = 'none';
                btn.classList.remove('bg-indigo-100', 'text-indigo-700', 'border-indigo-300');
                btn.classList.add('bg-[#f8fafc]', 'text-[#334155]');
                btn.innerHTML = '<i class="fas fa-fill-drip"></i> ØªØ¯Ø±Ø¬ Ø§Ù„Ù†Øµ';
                
                removeTextGradient();
            }
        }

        // Ø¯Ø§Ù„Ø© Ø¬Ø¹Ù„ Ø§Ù„Ø¹Ù†Ø§ØµØ± Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„Ø³Ø­Ø¨ Ù…Ù† Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø¥Ù…Ø³Ø§Ùƒ (Header) - Ù†Ø³Ø®Ø© Ù…Ø­Ø³Ù†Ø© Ø³Ù„Ø³Ø©
        function makeElementDraggable(elmnt, handleId) {
            let startX = 0, startY = 0, initialLeft = 0, initialTop = 0;
            const header = document.getElementById(handleId);
            
            if (header) {
                header.onmousedown = dragMouseDown;
                header.ontouchstart = dragMouseDown;
            }

            function dragMouseDown(e) {
                e = e || window.event;
                
                // Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªÙØ§Ø¹Ù„ÙŠØ©
                if(e.target.closest('button') || e.target.closest('.clickable')) {
                    return;
                }

                // Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ Ù„Ù…Ù†Ø¹ Ø§Ù„Ù…Ø´Ø§ÙƒÙ„ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø³Ø­Ø¨
                e.preventDefault();

                if(e.type === 'touchstart') {
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                } else {
                    startX = e.clientX;
                    startY = e.clientY;
                }
                
                // Ø­ÙØ¸ Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø­Ø§Ù„ÙŠ Ù„Ù„Ø¹Ù†ØµØ± Ø¨Ø¯Ù‚Ø©
                const rect = elmnt.getBoundingClientRect();
                initialLeft = rect.left;
                initialTop = rect.top;
                
                // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªØ±Ø§Ù†Ø³ÙÙˆØ±Ù… ÙÙˆØ±Ø§Ù‹ Ù„ØªØ«Ø¨ÙŠØª Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª
                elmnt.style.transform = "none";
                elmnt.style.left = initialLeft + "px";
                elmnt.style.top = initialTop + "px";
                // Ù‡Ø§Ù…: ØªØºÙ„ÙŠØ¨ Ø§Ù„Ø¨ÙˆØ²ÙŠØ´Ù† Ù„ÙŠÙƒÙˆÙ† ÙÙŠÙƒØ³Ø¯ Ø£Ùˆ Ø§Ø¨Ø³Ù„ÙˆØª Ø­Ø³Ø¨ Ø§Ù„Ø­Ø§Ø¬Ø©
                // Ù‡Ù†Ø§ Ù‡Ùˆ fixed Ø­Ø³Ø¨ Ø§Ù„Ù€ CSS Ø§Ù„Ø£ØµÙ„ÙŠ

                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
                document.ontouchend = closeDragElement;
                document.ontouchmove = elementDrag;
            }

            function elementDrag(e) {
                e = e || window.event;
                e.preventDefault(); // Ù…Ù†Ø¹ Ø§Ù„ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ Ù„Ù„Ø´Ø§Ø´Ø© ÙÙŠ Ø§Ù„Ù„Ù…Ø³

                let clientX, clientY;
                if(e.type === 'touchmove') {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }

                // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¥Ø²Ø§Ø­Ø© (offset)
                const deltaX = clientX - startX;
                const deltaY = clientY - startY;

                // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø§Ø¨ØªØ¯Ø§Ø¦ÙŠ + Ø§Ù„Ø¥Ø²Ø§Ø­Ø©
                elmnt.style.left = (initialLeft + deltaX) + "px";
                elmnt.style.top = (initialTop + deltaY) + "px";
            }

            function closeDragElement() {
                document.onmouseup = null;
                document.onmousemove = null;
                document.ontouchend = null;
                document.ontouchmove = null;
            }
        }

        // ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø³Ø­Ø¨ Ù„Ù„Ù†Ø§ÙØ°Ø© Ø§Ù„Ø¹Ø§Ø¦Ù…Ø© Ø¹Ù†Ø¯ Ø§Ù„ØªØ­Ù…ÙŠÙ„
        document.addEventListener('DOMContentLoaded', function() {
            const floatingToolbar = document.getElementById('floating-context-toolbar');
            if(floatingToolbar) {
                makeElementDraggable(floatingToolbar, 'floating-toolbar-header');
            }
            // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø®Ø·ÙˆØ· Ø§Ù„Ù…ÙØ¶Ù„Ø©
            loadFavoriteFonts();
        });
        
        // Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ ÙÙˆØ±ÙŠ ÙÙŠ Ø­Ø§Ù„Ø© Ø¹Ø¯Ù… Ø§Ù†Ø·Ù„Ø§Ù‚ Ø§Ù„Ø­Ø¯Ø« (Ù„Ø£Ù† Ø§Ù„ØµÙØ­Ø© Ù…Ø­Ù…Ù„Ø© Ù…Ø³Ø¨Ù‚Ø§Ù‹)
        if(document.getElementById('floating-context-toolbar')) {
             makeElementDraggable(document.getElementById('floating-context-toolbar'), 'floating-toolbar-header');
        }
    </script>
</body>
</html>